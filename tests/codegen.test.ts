import { describe, it, expect } from 'vitest';
import { parseDMMF } from '../src/dmmf-parser.js';
import { buildCascadeGraph } from '../src/cascade-graph.js';
import {
  emitTypes,
  emitRuntime,
  emitCascadeGraph,
  emitIndex,
  resolveAuditTableConfig,
} from '../src/codegen/index.js';
import { buildToOneRelationWarningLines } from '../src/generator.js';
import { createMockField, createMockModel, createMockDMMF } from './helpers/mock-dmmf.js';

function createTestSchema() {
  const models = [
    createMockModel({
      name: 'User',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String', isUnique: true }),
        createMockField({
          name: 'posts',
          type: 'Post',
          kind: 'object',
          isList: true,
          relationName: 'UserPosts',
        }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
      ],
    }),
    createMockModel({
      name: 'Post',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'title', type: 'String' }),
        createMockField({ name: 'authorId', type: 'String' }),
        createMockField({
          name: 'author',
          type: 'User',
          kind: 'object',
          relationName: 'UserPosts',
          relationFromFields: ['authorId'],
          relationToFields: ['id'],
          relationOnDelete: 'Cascade',
        }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
      ],
    }),
    createMockModel({
      name: 'AuditLog',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'action', type: 'String' }),
      ],
    }),
  ];

  return parseDMMF(createMockDMMF(models));
}

// Default client import path for tests
const TEST_CLIENT_PATH = '../client';

function createSchemaWithDeletedBy() {
  const models = [
    createMockModel({
      name: 'Customer',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String', isUnique: true }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
        createMockField({
          name: 'deleted_by',
          type: 'String',
          isRequired: false,
        }),
      ],
    }),
    createMockModel({
      name: 'User',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String', isUnique: true }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
        // No deleted_by field
      ],
    }),
  ];

  return parseDMMF(createMockDMMF(models));
}

describe('emitTypes', () => {
  it('generates type definitions with correct header', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('// Auto-generated by prisma-safe-delete');
    expect(output).toContain('// @ts-nocheck');
    expect(output).toContain(`import type { PrismaClient, Prisma } from '${TEST_CLIENT_PATH}'`);
  });

  it('generates CascadeResult type', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export type CascadeResult = Record<string, number>;');
  });

  it('generates SafeUserDelegate with soft-delete methods', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export type SafeUserDelegate = Omit<');
    expect(output).toContain("'delete' | 'deleteMany'");
    expect(output).toContain('softDelete:');
    expect(output).toContain('softDeleteMany:');
    expect(output).toContain('restore:');
    expect(output).toContain('restoreMany:');
    expect(output).toContain('restoreCascade:');
    expect(output).toContain('__dangerousHardDelete:');
    expect(output).toContain('__dangerousHardDeleteMany:');
    expect(output).toContain('includingDeleted:');
  });

  it('generates softDelete with cascaded return type', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('softDelete: <T extends Prisma.UserDeleteArgs>(args: T');
    expect(output).toContain('Promise<{ record: Prisma.UserGetPayload<T>; cascaded: CascadeResult }>');
    expect(output).toContain('softDeleteMany: (args: Prisma.UserDeleteManyArgs');
    expect(output).toContain('Promise<{ count: number; cascaded: CascadeResult }>');
    expect(output).toContain('restoreCascade: <T extends Prisma.UserDeleteArgs>(args: T)');
    expect(output).toContain('Promise<{ record: Prisma.UserGetPayload<T> | null; cascaded: CascadeResult }>');
  });

  it('generates generic restore type', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('restore: <T extends Prisma.UserDeleteArgs>(args: T) => Promise<Prisma.UserGetPayload<T> | null>');
  });

  it('generates __dangerousHardDelete using native Prisma delete type', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain("__dangerousHardDelete: PrismaClient['user']['delete']");
  });

  it('generates required deletedBy for models with deleted_by field', () => {
    const schema = createSchemaWithDeletedBy();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // Customer has deleted_by field - deletedBy should be required (no ?)
    expect(output).toMatch(/SafeCustomerDelegate[\s\S]*softDelete:[\s\S]*\{ deletedBy: string \}/);
    expect(output).toMatch(/SafeCustomerDelegate[\s\S]*softDeleteMany:[\s\S]*\{ deletedBy: string \}/);
  });

  it('generates optional deletedBy for models without deleted_by field', () => {
    const schema = createSchemaWithDeletedBy();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // User has no deleted_by field - deletedBy should be optional (?)
    expect(output).toMatch(/SafeUserDelegate[\s\S]*softDelete:[\s\S]*\{ deletedBy\?: string \}/);
    expect(output).toMatch(/SafeUserDelegate[\s\S]*softDeleteMany:[\s\S]*\{ deletedBy\?: string \}/);
  });

  it('generates softDeletePreview type for soft-deletable models', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('softDeletePreview: (args: Prisma.UserDeleteManyArgs) => Promise<{ wouldDelete: CascadeResult }>');
    expect(output).toContain('softDeletePreview: (args: Prisma.PostDeleteManyArgs) => Promise<{ wouldDelete: CascadeResult }>');
  });

  it('generates standard delegate for non-soft-deletable models', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain("export type SafeAuditLogDelegate = PrismaClient['auditLog']");
  });

  it('generates SafePrismaClient interface', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export interface SafePrismaClient {');
    expect(output).toContain('user: SafeUserDelegate');
    expect(output).toContain('post: SafePostDelegate');
    expect(output).toContain('auditLog: SafeAuditLogDelegate');
    expect(output).toContain('$prisma: PrismaClient');
    expect(output).toContain('$includingDeleted: IncludingDeletedClient');
    expect(output).toContain('$onlyDeleted: OnlyDeletedClient');
  });

  it('generates IncludingDeletedClient interface', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export interface IncludingDeletedClient {');
  });

  it('generates OnlyDeletedClient interface', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export interface OnlyDeletedClient {');
  });
});

describe('emitCascadeGraph', () => {
  it('generates cascade graph constant', () => {
    const schema = createTestSchema();
    const graph = buildCascadeGraph(schema);
    const output = emitCascadeGraph(graph);

    expect(output).toContain('export const CASCADE_GRAPH: CascadeGraph');
    expect(output).toContain('"User"');
    expect(output).toContain('"Post"');
  });

  it('generates CascadeChild interface', () => {
    const schema = createTestSchema();
    const graph = buildCascadeGraph(schema);
    const output = emitCascadeGraph(graph);

    expect(output).toContain('export interface CascadeChild');
    expect(output).toContain('model: string');
    expect(output).toContain('foreignKey: string[]');
    expect(output).toContain('parentKey: string[]');
  });

  it('generates MODEL_NAMES constant', () => {
    const schema = createTestSchema();
    const graph = buildCascadeGraph(schema);
    const output = emitCascadeGraph(graph);

    expect(output).toContain('export const MODEL_NAMES');
    expect(output).toContain('export type ModelName');
  });
});

describe('emitRuntime', () => {
  it('generates runtime with correct imports', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('// @ts-nocheck');
    expect(output).toContain(`import { type PrismaClient, Prisma } from '${TEST_CLIENT_PATH}'`);
    expect(output).toContain("import { CASCADE_GRAPH");
    expect(output).toContain("import type { SafePrismaClient");
  });

  it('emits throwIfNotFound helper that throws P2025', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('function throwIfNotFound(count: number, modelName: string): void');
    expect(output).toContain("code: 'P2025'");
    expect(output).toContain('Prisma.PrismaClientKnownRequestError');
  });

  it('defaults to mangle uniqueStrategy', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain("const UNIQUE_STRATEGY: 'mangle' | 'none' | 'sentinel' = 'mangle'");
  });

  it('respects uniqueStrategy: none option', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    expect(output).toContain("const UNIQUE_STRATEGY: 'mangle' | 'none' | 'sentinel' = 'none'");
    // mangleUniqueFields should still exist but will return {} at runtime
    expect(output).toContain("if (UNIQUE_STRATEGY === 'none' || UNIQUE_STRATEGY === 'sentinel') return {}");
  });

  it('respects uniqueStrategy: mangle option', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).toContain("const UNIQUE_STRATEGY: 'mangle' | 'none' | 'sentinel' = 'mangle'");
  });

  it('generates SOFT_DELETABLE_MODELS map', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('const SOFT_DELETABLE_MODELS');
    expect(output).toContain('User: { deletedAtField:');
    expect(output).toContain('Post: { deletedAtField:');
    expect(output).not.toContain('AuditLog: {');
  });

  it('generates PRIMARY_KEYS map', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('const PRIMARY_KEYS');
  });

  it('generates injectFilters function', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('function injectFilters');
  });

  it('generates softDeleteWithCascade function', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function softDeleteWithCascade');
    expect(output).toContain('prisma.$transaction');
  });

  it('generates restore functions', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function restoreRecord');
    expect(output).toContain('async function restoreRecordInTx');
    expect(output).toContain('async function restoreManyRecords');
    expect(output).toContain('async function restoreManyInTx');
    expect(output).toContain('function unmangleUniqueFields');
  });

  it('generates cascade restore functions', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function restoreWithCascade');
    expect(output).toContain('async function restoreWithCascadeInTx');
    expect(output).toContain('async function restoreCascadeChildren');
    // Check that restoreCascade is added to model delegates
    expect(output).toContain('restoreCascade:');
  });

  it('generates model delegate creators', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('function createUserDelegate');
    expect(output).toContain('function createPostDelegate');
    expect(output).toContain('function createAuditLogDelegate');
  });

  it('generates wrapPrismaClient export', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export function wrapPrismaClient');
  });

  it('simple model (leaf, no unique strings) emits updateMany-based softDeleteMany', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Post is a leaf model with no unique string fields - should use fast path
    // Look for updateMany in the Post delegate's softDeleteMany
    expect(output).toMatch(/createPostDelegate[\s\S]*?original\.updateMany\(/);
    // Post delegate should NOT call softDeleteWithCascade
    const postDelegateMatch = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegateMatch).not.toBeNull();
    expect(postDelegateMatch![0]).not.toContain('softDeleteWithCascade');
  });

  it('complex model (has cascade children) emits softDeleteWithCascade', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // User has cascade child Post - should use complex path
    const userDelegateMatch = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegateMatch).not.toBeNull();
    expect(userDelegateMatch![0]).toContain('softDeleteWithCascade');
  });

  it('applies injectFilters to update and updateMany', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // update should use post-processing with injectFilters
    expect(output).toContain("const filtered = injectFilters(pp, 'User')");
    expect(output).toContain("postProcessRead(original.update(filtered), 'User'");
    // updateMany should still be a simple pass-through (returns count, not records)
    expect(output).toContain("updateMany: ((args: any) => original.updateMany(injectFilters(args, 'User'))) as PrismaClient['user']['updateMany']");
  });

  it('model with unique string fields but no children uses complex path with mangle strategy', () => {
    // Create a leaf model that has unique string fields
    const models = [
      createMockModel({
        name: 'Customer',
        fields: [
          createMockField({ name: 'id', type: 'String', isId: true }),
          createMockField({ name: 'email', type: 'String', isUnique: true }),
          createMockField({ name: 'deleted_at', type: 'DateTime', isRequired: false }),
        ],
      }),
    ];
    const schema = parseDMMF(createMockDMMF(models));
    const cascadeGraph = buildCascadeGraph(schema); // Customer has no children

    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Should use complex path because it has unique string fields that need mangling
    const customerDelegate = /function createCustomerDelegate[\s\S]*?^}/m.exec(output);
    expect(customerDelegate).not.toBeNull();
    expect(customerDelegate![0]).toContain('softDeleteWithCascade');
    expect(customerDelegate![0]).not.toContain('fast path');
  });

  it('model with unique string fields but no children uses fast path with none strategy', () => {
    // Same leaf model with unique string fields, but uniqueStrategy is 'none'
    const models = [
      createMockModel({
        name: 'Customer',
        fields: [
          createMockField({ name: 'id', type: 'String', isId: true }),
          createMockField({ name: 'email', type: 'String', isUnique: true }),
          createMockField({ name: 'deleted_at', type: 'DateTime', isRequired: false }),
        ],
      }),
    ];
    const schema = parseDMMF(createMockDMMF(models));
    const cascadeGraph = buildCascadeGraph(schema);

    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    // Should use fast path because uniqueStrategy='none' means no mangling regardless
    const customerDelegate = /function createCustomerDelegate[\s\S]*?^}/m.exec(output);
    expect(customerDelegate).not.toBeNull();
    expect(customerDelegate![0]).not.toContain('softDeleteWithCascade');
    expect(customerDelegate![0]).toContain('original.updateMany');
  });

  it('model with children always uses complex path regardless of uniqueStrategy', () => {
    const schema = createTestSchema(); // User has Post children
    const cascadeGraph = buildCascadeGraph(schema);

    // Even with uniqueStrategy='none', User should use complex path because it has children
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('softDeleteWithCascade');
  });

  it('fast-path softDelete returns { record, cascaded: {} }', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Post is a fast-path model. Check its softDelete returns { record, cascaded: {} }
    const postDelegate = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegate).not.toBeNull();
    expect(postDelegate![0]).toContain('return { record, cascaded: {} }');
  });

  it('fast-path softDeleteMany returns { count: result.count, cascaded: {} }', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const postDelegate = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegate).not.toBeNull();
    expect(postDelegate![0]).toContain('return { count: result.count, cascaded: {} }');
  });

  it('complex-path softDelete returns { record, cascaded }', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // User is a complex-path model
    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('return { record, cascaded }');
  });

  it('complex-path softDeleteMany returns { count, cascaded }', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('return { count, cascaded }');
  });

  it('transaction wrapper uses fast path for simple models', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Find the wrapTransactionClient function
    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];

    // Post (simple) should use tx.post.updateMany in softDelete, not softDeleteWithCascadeInTx
    const postSection = /post: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(postSection).not.toBeNull();
    expect(postSection![0]).toContain('tx.post.updateMany');
    expect(postSection![0]).not.toContain('softDeleteWithCascadeInTx');

    // User (complex) should use softDeleteWithCascadeInTx in transaction
    const userSection = /user: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(userSection).not.toBeNull();
    expect(userSection![0]).toContain('softDeleteWithCascadeInTx');
  });

  it('fast-path includes deleted_by support when model has deleted_by field', () => {
    const schema = createSchemaWithDeletedBy();
    // Customer has deleted_by but no children → if unique fields exist it depends on strategy
    // User has no deleted_by and no children
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    // Customer has unique string fields but uniqueStrategy='none' → fast path
    const customerDelegate = /function createCustomerDelegate[\s\S]*?^}/m.exec(output);
    expect(customerDelegate).not.toBeNull();
    const customerCode = customerDelegate![0];
    // Should reference deleted_by field in fast path
    expect(customerCode).toContain('deletedByField');
    expect(customerCode).toContain('deleted_by');
  });

  it('generates previewSoftDelete and previewCascadeChildren functions', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function previewSoftDelete');
    expect(output).toContain('async function previewSoftDeleteInTx');
    expect(output).toContain('async function previewCascadeChildren');
  });

  it('simple model delegate emits softDeletePreview with count', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Post is a simple model (leaf, no unique strings)
    const postDelegate = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegate).not.toBeNull();
    expect(postDelegate![0]).toContain('softDeletePreview');
    expect(postDelegate![0]).toContain('original.count');
    expect(postDelegate![0]).toContain('wouldDelete');
  });

  it('complex model delegate emits softDeletePreview with cascade preview', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // User is a complex model (has cascade children)
    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('softDeletePreview');
    expect(userDelegate![0]).toContain('previewSoftDelete');
  });

  it('transaction wrapper includes softDeletePreview for simple models', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];

    // Post (simple) should have softDeletePreview with tx.post.count
    const postSection = /post: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(postSection).not.toBeNull();
    expect(postSection![0]).toContain('softDeletePreview');
    expect(postSection![0]).toContain('tx.post.count');
  });

  it('transaction wrapper includes softDeletePreview for complex models', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];

    // User (complex) should have softDeletePreview with previewSoftDeleteInTx
    const userSection = /user: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(userSection).not.toBeNull();
    expect(userSection![0]).toContain('softDeletePreview');
    expect(userSection![0]).toContain('previewSoftDeleteInTx');
  });
});

function createSentinelSchema() {
  // Sentinel strategy: deleted_at is non-nullable DateTime with default
  const models = [
    createMockModel({
      name: 'User',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String' }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: true,
          hasDefaultValue: true,
        }),
      ],
      uniqueFields: [['email', 'deleted_at']],
      uniqueIndexes: [{ name: 'email_deleted_at', fields: ['email', 'deleted_at'] }],
    }),
    createMockModel({
      name: 'Post',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'title', type: 'String' }),
        createMockField({ name: 'authorId', type: 'String' }),
        createMockField({
          name: 'author',
          type: 'User',
          kind: 'object',
          relationName: 'UserPosts',
          relationFromFields: ['authorId'],
          relationToFields: ['id'],
          relationOnDelete: 'Cascade',
        }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: true,
          hasDefaultValue: true,
        }),
      ],
    }),
  ];

  return parseDMMF(createMockDMMF(models));
}

describe('emitRuntime - sentinel strategy', () => {
  it('emits ACTIVE_DELETED_AT_VALUE as Date for sentinel', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    expect(output).toContain("const ACTIVE_DELETED_AT_VALUE: Date = new Date('9999-12-31T00:00:00.000Z')");
  });

  it('emits ACTIVE_DELETED_AT_VALUE as null for mangle', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).toContain('const ACTIVE_DELETED_AT_VALUE: null = null');
  });

  it('emits ACTIVE_DELETED_AT_VALUE as null for none', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    expect(output).toContain('const ACTIVE_DELETED_AT_VALUE: null = null');
  });

  it('emits SENTINEL_COMPOUND_UNIQUES metadata for sentinel', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    expect(output).toContain('const SENTINEL_COMPOUND_UNIQUES');
    expect(output).toContain('User: [{ keyName: "email_deleted_at"');
  });

  it('does not emit SENTINEL_COMPOUND_UNIQUES for mangle', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).not.toContain('SENTINEL_COMPOUND_UNIQUES');
  });

  it('emits transformSentinelFindUniqueWhere for sentinel', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    expect(output).toContain('function transformSentinelFindUniqueWhere');
  });

  it('does not emit transformSentinelFindUniqueWhere for mangle', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).not.toContain('transformSentinelFindUniqueWhere');
  });

  it('sentinel uses fast path for leaf models (like none)', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // Post is a leaf model (no children) - should use fast path with sentinel
    const postDelegate = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegate).not.toBeNull();
    expect(postDelegate![0]).not.toContain('softDeleteWithCascade');
    expect(postDelegate![0]).toContain('original.updateMany');
  });

  it('sentinel uses complex path for models with children', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // User has cascade child Post - should use complex path
    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('softDeleteWithCascade');
  });

  it('sentinel create methods inject ACTIVE_DELETED_AT_VALUE', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // Model delegate should inject sentinel into create with post-processing
    expect(output).toContain("ACTIVE_DELETED_AT_VALUE");
    expect(output).toContain("postProcessRead(original.create(withSentinel)");
  });

  it('non-sentinel create methods use post-processing', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Create should use post-processing for to-one relation nullification
    expect(output).toContain("postProcessRead(original.create(pp)");
  });

  it('sentinel findUnique calls transformSentinelFindUniqueWhere', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    expect(output).toContain('transformSentinelFindUniqueWhere');
  });

  it('uses ACTIVE_DELETED_AT_VALUE in getModeFilter', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    expect(output).toContain('[deletedAtField]: ACTIVE_DELETED_AT_VALUE');
    expect(output).toContain('[deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE }');
  });

  it('uses ACTIVE_DELETED_AT_VALUE in soft delete where clauses', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // Simple-path softDelete should use ACTIVE_DELETED_AT_VALUE
    expect(output).toContain("['deleted_at']: ACTIVE_DELETED_AT_VALUE }");
  });

  it('mangle/unmangle return empty for sentinel', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    expect(output).toContain("if (UNIQUE_STRATEGY === 'none' || UNIQUE_STRATEGY === 'sentinel') return {}");
  });

  it('sentinel upsert injects ACTIVE_DELETED_AT_VALUE on create branch and applies transformSentinelFindUniqueWhere', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // Model delegate upsert should inject sentinel into create data, call injectFilters, transform where, and post-process
    expect(output).toContain("ACTIVE_DELETED_AT_VALUE");
    expect(output).toContain("filtered.where = transformSentinelFindUniqueWhere(filtered.where");
    expect(output).toContain("postProcessRead(original.upsert(filtered)");
  });

  it('non-sentinel upsert applies injectFilters and post-processing', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Upsert should call injectFilters and post-process for mangle strategy
    expect(output).toContain("injectFilters(pp, 'User')");
    expect(output).toContain("postProcessRead(original.upsert(filtered)");
  });
});

describe('emitTypes - $onlyDeleted parity', () => {
  it('OnlyDeletedClient includes all 8 read operations', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // OnlyDeletedClient should have parity with IncludingDeletedClient
    const onlyDeletedMatch = /export interface OnlyDeletedClient \{[\s\S]*?\}/.exec(output);
    expect(onlyDeletedMatch).not.toBeNull();
    const onlyDeletedBlock = onlyDeletedMatch![0];
    expect(onlyDeletedBlock).toContain("'findMany'");
    expect(onlyDeletedBlock).toContain("'findFirst'");
    expect(onlyDeletedBlock).toContain("'findFirstOrThrow'");
    expect(onlyDeletedBlock).toContain("'findUnique'");
    expect(onlyDeletedBlock).toContain("'findUniqueOrThrow'");
    expect(onlyDeletedBlock).toContain("'count'");
    expect(onlyDeletedBlock).toContain("'aggregate'");
    expect(onlyDeletedBlock).toContain("'groupBy'");
  });
});

describe('emitRuntime - $onlyDeleted parity', () => {
  it('$onlyDeleted client includes all 8 read operations', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // The createOnlyDeletedClient function should emit all 8 ops
    const onlyDeletedFunc = /function createOnlyDeletedClient[\s\S]*?^}/m.exec(output);
    expect(onlyDeletedFunc).not.toBeNull();
    const funcBody = onlyDeletedFunc![0];
    expect(funcBody).toContain('findMany');
    expect(funcBody).toContain('findFirst');
    expect(funcBody).toContain('findFirstOrThrow');
    expect(funcBody).toContain('findUnique');
    expect(funcBody).toContain('findUniqueOrThrow');
    expect(funcBody).toContain('count');
    expect(funcBody).toContain('aggregate');
    expect(funcBody).toContain('groupBy');
  });

  it('transaction $onlyDeleted includes all 8 read operations', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];
    // Find the $onlyDeleted section within the tx wrapper
    const onlyDeletedSection = /\$onlyDeleted: \{[\s\S]*?\},\n\n/.exec(txContent);
    expect(onlyDeletedSection).not.toBeNull();
    const section = onlyDeletedSection![0];
    expect(section).toContain("'only-deleted'");
    expect(section).toContain('findFirstOrThrow');
    expect(section).toContain('findUniqueOrThrow');
    expect(section).toContain('aggregate');
    expect(section).toContain('groupBy');
  });
});

describe('emitRuntime - sentinel transformSentinelFindUniqueWhere multi-compound', () => {
  it('transforms multiple compound uniques containing deleted_at', () => {
    // Create a model with two compound uniques both including deleted_at
    const models = [
      createMockModel({
        name: 'Member',
        fields: [
          createMockField({ name: 'id', type: 'String', isId: true }),
          createMockField({ name: 'email', type: 'String' }),
          createMockField({ name: 'orgId', type: 'String' }),
          createMockField({
            name: 'deleted_at',
            type: 'DateTime',
            isRequired: true,
            hasDefaultValue: true,
          }),
        ],
        uniqueFields: [['email', 'deleted_at'], ['orgId', 'deleted_at']],
        uniqueIndexes: [
          { name: 'email_deleted_at', fields: ['email', 'deleted_at'] },
          { name: 'orgId_deleted_at', fields: ['orgId', 'deleted_at'] },
        ],
      }),
    ];

    const schema = parseDMMF(createMockDMMF(models));
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // Should have both compound uniques in metadata
    expect(output).toContain('email_deleted_at');
    expect(output).toContain('orgId_deleted_at');
    // The transform function should not return early on first match
    expect(output).toContain('const consumedFields = new Set');
  });

  it('transform filters out deleted_at from field presence check', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // The function should filter deleted_at out of the fields check so that
    // a simple { email: 'foo' } where clause triggers the compound transform.
    // This is critical: without this, users must always pass the compound key form.
    expect(output).toContain('const nonDeletedAtFields = fields.filter');
    expect(output).toContain('f !== deletedAtField');
    expect(output).toContain('nonDeletedAtFields.every');
  });
});

describe('emitRuntime - cascade N+1 optimization', () => {
  it('emits bulk updateMany optimization in cascadeToChildren', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Should contain the bulk optimization path
    expect(output).toContain("const childNeedsMangling = UNIQUE_STRATEGY === 'mangle'");
    expect(output).toContain('childDelegate.updateMany');
  });

  it('emits bulk updateMany optimization in softDeleteWithCascadeInTx', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).toContain("const needsMangling = UNIQUE_STRATEGY === 'mangle'");
  });

  it('emits bulk updateMany optimization in restoreCascadeChildren', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).toContain("const childNeedsUnmangling = UNIQUE_STRATEGY === 'mangle'");
  });
});

describe('emitRuntime - bug fix regression tests', () => {
  it('#43: mangleUniqueFields does not have endsWith idempotency check', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // The idempotency check was removed because softDeleteWithCascade already
    // filters by ACTIVE_DELETED_AT_VALUE, so double-mangling can't happen via
    // normal paths. The check was harmful because field values that naturally
    // end with the suffix pattern would skip mangling.
    const mangleFn = /function mangleUniqueFields[\s\S]*?^}/m.exec(output);
    expect(mangleFn).not.toBeNull();
    expect(mangleFn![0]).not.toContain('endsWith(suffix)');
    expect(mangleFn![0]).not.toContain('already mangled');
  });

  it('#42: restoreCascadeChildren does not bail out on non-soft-deletable children', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // The old code had: if (!child.isSoftDeletable || !child.deletedAtField) continue;
    // This skipped non-soft-deletable intermediary nodes entirely, preventing
    // traversal to their soft-deletable grandchildren.
    const restoreCascadeFn = /async function restoreCascadeChildren[\s\S]*?^}/m.exec(output);
    expect(restoreCascadeFn).not.toBeNull();
    expect(restoreCascadeFn![0]).not.toContain('if (!child.isSoftDeletable || !child.deletedAtField) continue');
    // It should still gate restore operations behind the check
    expect(restoreCascadeFn![0]).toContain('if (child.isSoftDeletable && child.deletedAtField)');
  });

  it('#44: _count: true expands to select with filters instead of pass-through', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // The old code passed _count: true through unchanged.
    // Now it should expand to _count: { select: { ... } } with soft-delete filters.
    expect(output).toContain('getListRelationsForModel(parentModel)');
    expect(output).not.toContain('Simple _count: true - pass through');
  });

  it('#44: getListRelationsForModel helper is emitted', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).toContain('function getListRelationsForModel(modelName: string): string[]');
  });

  it('#45: restore updates have P2002 error handling', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // All 4 restore functions should have P2002 catch blocks
    expect(output).toContain("(e as Record<string, unknown>).code === 'P2002'");
    expect(output).toContain('unique constraint violation on');
    expect(output).toContain('An active record with the same unique value was created concurrently.');

    // Should appear in restoreRecordWithDelegate, restoreManyWithDelegate,
    // restoreWithCascadeInTx, and restoreCascadeChildren (4 locations)
    const p2002Matches = output.match(/\.code === 'P2002'/g);
    expect(p2002Matches).not.toBeNull();
    expect(p2002Matches!.length).toBe(4);
  });
});

describe('emitRuntime - cascade: false (empty cascade graph)', () => {
  it('model with children uses fast path when cascade graph is empty and strategy is none', () => {
    const schema = createTestSchema();
    const emptyCascadeGraph = {};
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph: emptyCascadeGraph });

    // With strategy='none' AND no children in graph → fast path (updateMany)
    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).not.toContain('softDeleteWithCascade');
    expect(userDelegate![0]).toContain('original.updateMany');
  });

  it('model with children still uses complex path when cascade is disabled but mangle needs it', () => {
    const schema = createTestSchema(); // User has unique string field (email)
    const emptyCascadeGraph = {};
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph: emptyCascadeGraph });

    // User has unique string fields (email) → still needs complex path for mangling
    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('softDeleteWithCascade');
  });

  it('model with children uses fast path when cascade graph is empty and strategy is sentinel', () => {
    const schema = createSentinelSchema();
    const emptyCascadeGraph = {};
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph: emptyCascadeGraph });

    // With strategy='sentinel' AND no children in graph → fast path
    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).not.toContain('softDeleteWithCascade');
    expect(userDelegate![0]).toContain('original.updateMany');
  });

  it('all models use fast path when cascade is disabled with none strategy', () => {
    const schema = createTestSchema();
    const emptyCascadeGraph = {};
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph: emptyCascadeGraph });

    // Both User and Post should use fast path
    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    const postDelegate = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(postDelegate).not.toBeNull();
    expect(userDelegate![0]).not.toContain('softDeleteWithCascade');
    expect(postDelegate![0]).not.toContain('softDeleteWithCascade');
  });

  it('transaction wrapper uses fast path for all models when cascade is disabled', () => {
    const schema = createTestSchema();
    const emptyCascadeGraph = {};
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph: emptyCascadeGraph });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];

    // User (normally complex) should now use updateMany in tx
    const userSection = /user: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(userSection).not.toBeNull();
    expect(userSection![0]).toContain('tx.user.updateMany');
    expect(userSection![0]).not.toContain('softDeleteWithCascadeInTx');
  });
});

describe('emitRuntime - upsert filter injection', () => {
  it('mangle upsert calls injectFilters and post-processes', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).toContain("injectFilters(pp, 'User')");
    expect(output).toContain("postProcessRead(original.upsert(filtered)");
  });

  it('none upsert calls injectFilters and post-processes', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    expect(output).toContain("injectFilters(pp, 'User')");
    expect(output).toContain("postProcessRead(original.upsert(filtered)");
  });

  it('transaction wrapper upsert calls injectFilters and post-processes for mangle', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = String(txWrapper?.[0]);
    expect(txContent).toContain("injectFilters(pp, 'User')");
    expect(txContent).toContain("postProcessRead(tx.user.upsert(filtered)");
  });

  it('transaction wrapper sentinel upsert applies transformSentinelFindUniqueWhere and post-processes', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = String(txWrapper?.[0]);
    // Sentinel tx upsert should call injectFilters, inject sentinel value, transform where, and post-process
    expect(txContent).toContain('ACTIVE_DELETED_AT_VALUE');
    expect(txContent).toContain('transformSentinelFindUniqueWhere(filtered.where');
    expect(txContent).toContain('postProcessRead(tx.user.upsert(filtered)');
  });
});

describe('emitIndex', () => {
  it('generates index with all exports', () => {
    const schema = createTestSchema();
    const output = emitIndex(schema);

    expect(output).toContain("export type { SafePrismaClient");
    expect(output).toContain("CascadeResult");
    expect(output).toContain("export type { SafeUserDelegate }");
    expect(output).toContain("export type { SafePostDelegate }");
    expect(output).toContain("export { CASCADE_GRAPH, MODEL_NAMES }");
    expect(output).toContain("export { wrapPrismaClient }");
    expect(output).toContain("export { onlyDeleted, excludeDeleted, includingDeleted }");
  });
});

describe('emitRuntime - to-one post-processing', () => {
  it('emits TO_ONE_SOFT_DELETABLE_RELATIONS metadata', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    // Post has a to-one relation 'author' -> User (soft-deletable)
    expect(output).toContain('TO_ONE_SOFT_DELETABLE_RELATIONS');
    expect(output).toContain('Post: ["author"]');
  });

  it('emits post-processing helper functions', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('function isRecordDeleted(');
    expect(output).toContain('function nullifyDeletedToOneRelations(');
    expect(output).toContain('function injectDeletedAtIntoToOneSelects');
    expect(output).toContain('function stripInjectedFields(');
    expect(output).toContain('function postProcessRead<T>(');
  });

  it('wraps read methods with postProcessRead', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    // findMany should use postProcessRead
    expect(output).toContain("postProcessRead(original.findMany(filtered), 'User'");
    expect(output).toContain("postProcessRead(original.findFirst(filtered), 'User'");
    expect(output).toContain("postProcessRead(original.findFirstOrThrow(filtered), 'User'");
    expect(output).toContain("postProcessRead(original.findUnique(filtered), 'User'");
    expect(output).toContain("postProcessRead(original.findUniqueOrThrow(filtered), 'User'");
  });

  it('does not wrap count/aggregate/groupBy with postProcessRead', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    // count/aggregate/groupBy should NOT use postProcessRead
    expect(output).not.toContain("postProcessRead(original.count(");
    expect(output).not.toContain("postProcessRead(original.aggregate(");
    expect(output).not.toContain("postProcessRead(original.groupBy(");
  });

  it('includingDeleted does not use postProcessRead', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    // includingDeleted sub-object passes directly through
    expect(output).toContain('includingDeleted: {\n      findMany: ((args?: any) => original.findMany(args))');
  });

  it('$includingDeleted client does not use postProcessRead', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    // $includingDeleted uses include-deleted mode but no postProcessRead
    expect(output).toContain("injectFilters(args[0], 'User', 'include-deleted')");
    // The include-deleted lines shouldn't have postProcessRead
    const includingDeletedSection = output.split('$includingDeleted')[1] ?? '';
    // In the $includingDeleted section of wrapTransactionClient, there should be no postProcessRead
    const sectionEnd = includingDeletedSection.indexOf('$queryRaw');
    const section = includingDeletedSection.slice(0, sectionEnd);
    expect(section).not.toContain('postProcessRead');
  });

  it('$onlyDeleted uses postProcessRead', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    // $onlyDeleted should use postProcessRead
    expect(output).toContain("injectFilters(pp, 'User', 'only-deleted')");
  });

  it('transaction wrapper uses postProcessRead for normal reads', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    // Transaction wrapper reads should use postProcessRead
    expect(output).toContain("postProcessRead(tx.user.findMany(filtered), 'User'");
    expect(output).toContain("postProcessRead(tx.user.findFirst(filtered), 'User'");
  });

  it('wraps write methods (create, update, upsert, createManyAndReturn, updateManyAndReturn) with postProcessRead', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    // Write methods that return records with relations should use postProcessRead
    expect(output).toContain("postProcessRead(original.create(pp)");
    expect(output).toContain("postProcessRead(original.update(filtered)");
    expect(output).toContain("postProcessRead(original.upsert(filtered)");
    expect(output).toContain("postProcessRead(original.createManyAndReturn(pp)");
    expect(output).toContain("postProcessRead(original.updateManyAndReturn(filtered)");
  });

  it('does not wrap createMany or updateMany with postProcessRead', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    // createMany and updateMany return {count} only, no relations to post-process
    expect(output).not.toContain("postProcessRead(original.createMany(");
    expect(output).not.toContain("postProcessRead(original.updateMany(");
  });

  it('transaction wrapper wraps write methods with postProcessRead', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = String(txWrapper?.[0]);

    expect(txContent).toContain("postProcessRead(tx.user.create(pp)");
    expect(txContent).toContain("postProcessRead(tx.user.update(filtered)");
    expect(txContent).toContain("postProcessRead(tx.user.upsert(filtered)");
    expect(txContent).toContain("postProcessRead(tx.user.createManyAndReturn(");
    expect(txContent).toContain("postProcessRead(tx.user.updateManyAndReturn(filtered)");
  });
});

describe('buildToOneRelationWarningLines', () => {
  it('warns about required to-one relations to soft-deletable models', () => {
    const schema = createTestSchema();
    const lines = buildToOneRelationWarningLines(schema, false);

    // Post.author is required and points to User (soft-deletable)
    expect(lines.join('\n')).toContain('Post.author -> User');
  });

  it('returns empty for models without required to-one soft-deletable relations', () => {
    const models = [
      createMockModel({
        name: 'User',
        fields: [
          createMockField({ name: 'id', type: 'String', isId: true }),
          createMockField({ name: 'deleted_at', type: 'DateTime', isRequired: false }),
        ],
      }),
    ];
    const schema = parseDMMF(createMockDMMF(models));
    const lines = buildToOneRelationWarningLines(schema, false);

    expect(lines).toEqual([]);
  });

  it('does not warn about optional to-one relations', () => {
    const models = [
      createMockModel({
        name: 'User',
        fields: [
          createMockField({ name: 'id', type: 'String', isId: true }),
          createMockField({ name: 'deleted_at', type: 'DateTime', isRequired: false }),
        ],
      }),
      createMockModel({
        name: 'Post',
        fields: [
          createMockField({ name: 'id', type: 'String', isId: true }),
          createMockField({ name: 'authorId', type: 'String', isRequired: false }),
          createMockField({
            name: 'author',
            type: 'User',
            kind: 'object',
            isRequired: false,
            relationName: 'UserPosts',
            relationFromFields: ['authorId'],
            relationToFields: ['id'],
          }),
        ],
      }),
    ];
    const schema = parseDMMF(createMockDMMF(models));
    const lines = buildToOneRelationWarningLines(schema, false);

    expect(lines).toEqual([]);
  });
});

// --- Audit logging tests ---

function createAuditSchema() {
  const models = [
    createMockModel({
      name: 'User',
      documentation: '/// @audit',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String', isUnique: true }),
        createMockField({ name: 'deleted_at', type: 'DateTime', isRequired: false }),
        createMockField({ name: 'deleted_by', type: 'String', isRequired: false }),
        createMockField({
          name: 'posts',
          type: 'Post',
          kind: 'object',
          isList: true,
          relationName: 'UserPosts',
        }),
      ],
    }),
    createMockModel({
      name: 'Post',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'title', type: 'String' }),
        createMockField({ name: 'authorId', type: 'String' }),
        createMockField({
          name: 'author',
          type: 'User',
          kind: 'object',
          relationName: 'UserPosts',
          relationFromFields: ['authorId'],
          relationToFields: ['id'],
          relationOnDelete: 'Cascade',
        }),
        createMockField({ name: 'deleted_at', type: 'DateTime', isRequired: false }),
      ],
    }),
    createMockModel({
      name: 'Product',
      documentation: '/// @audit(create, delete)',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'name', type: 'String' }),
      ],
    }),
    createMockModel({
      name: 'AuditEvent',
      documentation: '/// @audit-table',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'entity_type', type: 'String' }),
        createMockField({ name: 'entity_id', type: 'String' }),
        createMockField({ name: 'action', type: 'String' }),
        createMockField({ name: 'actor_id', type: 'String', isRequired: false }),
        createMockField({ name: 'event_data', type: 'Json' }),
        createMockField({ name: 'created_at', type: 'DateTime' }),
        createMockField({ name: 'parent_event_id', type: 'String', isRequired: false }),
      ],
    }),
  ];

  return parseDMMF(createMockDMMF(models));
}

describe('emitTypes - audit', () => {
  it('audited + soft-deletable model uses actorId instead of deletedBy', () => {
    const schema = createAuditSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // User is audited + soft-deletable: actorId replaces deletedBy
    expect(output).toMatch(/SafeUserDelegate[\s\S]*actorId\?: string \| null/);
    // Extract just the SafeUserDelegate block and check it doesn't contain deletedBy
    const userDelegateMatch = /export type SafeUserDelegate[\s\S]*?(?=export type Safe\w+Delegate|export interface)/.exec(output);
    expect(userDelegateMatch).not.toBeNull();
    expect(userDelegateMatch![0]).not.toContain('deletedBy');
    expect(userDelegateMatch![0]).toContain('actorId');
  });

  it('audited + soft-deletable model has actorId on write methods', () => {
    const schema = createAuditSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // create, update, upsert should have actorId
    expect(output).toMatch(/SafeUserDelegate[\s\S]*create.*actorId/);
    expect(output).toMatch(/SafeUserDelegate[\s\S]*update.*actorId/);
  });

  it('audit-only model (no soft-delete) has actorId on mutations including delete', () => {
    const schema = createAuditSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // Product is audit-only (no deleted_at)
    expect(output).toMatch(/SafeProductDelegate[\s\S]*create.*actorId/);
    expect(output).toMatch(/SafeProductDelegate[\s\S]*delete.*actorId/);
  });

  it('non-audited soft-deletable model retains deletedBy', () => {
    const schema = createAuditSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // Post is not audited: should still have deletedBy
    expect(output).toMatch(/SafePostDelegate[\s\S]*deletedBy\?/);
  });

  it('emits WrapOptions type when auditable models exist', () => {
    const schema = createAuditSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export interface WrapOptions');
    expect(output).toContain('auditContext');
  });

  it('does not emit WrapOptions when no auditable models', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).not.toContain('WrapOptions');
  });
});

describe('emitRuntime - audit', () => {
  it('emits audit helper functions when audit table exists', () => {
    const schema = createAuditSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const auditTable = resolveAuditTableConfig(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, {
      uniqueStrategy: 'mangle',
      cascadeGraph,
      auditTable,
    });

    expect(output).toContain('AUDITABLE_MODELS');
    expect(output).toContain('writeAuditEvent');
    expect(output).toContain('isAuditable');
    expect(output).toContain('getEntityId');
    expect(output).toContain('AUDIT_TABLE_NAME');
    // Shared audit operation helpers should be emitted
    expect(output).toContain('async function _auditedCreate');
    expect(output).toContain('async function _auditedUpdate');
    expect(output).toContain('async function _auditedUpdateMany');
    expect(output).toContain('async function _auditedUpdateManyAndReturn');
    expect(output).toContain('async function _auditedUpsert');
    expect(output).toContain('async function _auditedDelete');
    expect(output).toContain('async function _auditedDeleteMany');
  });

  it('does not emit audit helpers when no audit table', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, {
      uniqueStrategy: 'mangle',
      cascadeGraph,
    });

    expect(output).not.toContain('AUDITABLE_MODELS');
    expect(output).not.toContain('writeAuditEvent');
  });

  it('audited + soft-deletable model uses actorId in softDelete', () => {
    const schema = createAuditSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const auditTable = resolveAuditTableConfig(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, {
      uniqueStrategy: 'mangle',
      cascadeGraph,
      auditTable,
    });

    // User delegate should reference actorId, not deletedBy
    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    const userCode = userDelegate![0];
    expect(userCode).toContain('actorId');
    // softDelete should destructure actorId
    expect(userCode).toContain('const { actorId,');
  });

  it('audited + soft-deletable model has audited write methods', () => {
    const schema = createAuditSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const auditTable = resolveAuditTableConfig(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, {
      uniqueStrategy: 'mangle',
      cascadeGraph,
      auditTable,
    });

    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    const userCode = userDelegate![0];
    // Write methods should call shared _audited* helpers
    expect(userCode).toContain('_auditedCreate');
    expect(userCode).toContain('_auditedUpdate');
    expect(userCode).toContain('_auditedUpsert');
    // Upsert still checks isAuditable at runtime (action determined at runtime)
    expect(output).toContain('isAuditable');
  });

  it('audit-only model (no soft-delete) has full audited delegate', () => {
    const schema = createAuditSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const auditTable = resolveAuditTableConfig(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, {
      uniqueStrategy: 'mangle',
      cascadeGraph,
      auditTable,
    });

    // Product is audit-only (has create and delete actions)
    const productDelegate = /function createProductDelegate[\s\S]*?^}/m.exec(output);
    expect(productDelegate).not.toBeNull();
    const productCode = productDelegate![0];
    // Should use shared _audited* helpers
    expect(productCode).toContain('_auditedCreate');
    expect(productCode).toContain('actorId');
    // Product has @audit(create, delete) - delete should use _auditedDelete
    expect(productCode).toContain('_auditedDelete');
    // Product does NOT have 'update' action, so update should be a passthrough
    expect(productCode).not.toContain('_auditedUpdate');
  });

  it('non-audited model is unchanged', () => {
    const schema = createAuditSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const auditTable = resolveAuditTableConfig(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, {
      uniqueStrategy: 'mangle',
      cascadeGraph,
      auditTable,
    });

    // Post is not audited - should not have writeAuditEvent
    const postDelegate = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegate).not.toBeNull();
    const postCode = postDelegate![0];
    expect(postCode).not.toContain('writeAuditEvent');
    expect(postCode).not.toContain('actorId');
  });

  it('wrapPrismaClient accepts WrapOptions when audit is enabled', () => {
    const schema = createAuditSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const auditTable = resolveAuditTableConfig(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, {
      uniqueStrategy: 'mangle',
      cascadeGraph,
      auditTable,
    });

    expect(output).toContain('wrapOptions?: WrapOptions');
  });

  it('transaction wrapper handles audit-only models', () => {
    const schema = createAuditSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const auditTable = resolveAuditTableConfig(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, {
      uniqueStrategy: 'mangle',
      cascadeGraph,
      auditTable,
    });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];

    // Product (audit-only) should use shared _audited* helpers in tx wrapper
    expect(txContent).toContain('_auditedCreate');
    expect(txContent).toContain('_auditedDelete');
    // Product should still have actorId extraction
    expect(txContent).toContain('actorId');
  });

  it('transaction wrapper has audited write methods for audited+soft-deletable models', () => {
    const schema = createAuditSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const auditTable = resolveAuditTableConfig(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, {
      uniqueStrategy: 'mangle',
      cascadeGraph,
      auditTable,
    });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];

    // User (audited + soft-deletable) in tx should use shared _audited* helpers
    expect(txContent).toContain('_auditedCreate');
    expect(txContent).toContain('_auditedUpdate');
    // Should use actorId in softDelete
    const userSection = /user: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(userSection).not.toBeNull();
    expect(userSection![0]).toContain('actorId');
  });
});

describe('emitIndex - audit', () => {
  it('exports WrapOptions when auditable models exist', () => {
    const schema = createAuditSchema();
    const output = emitIndex(schema);

    expect(output).toContain('WrapOptions');
  });

  it('does not export WrapOptions when no auditable models', () => {
    const schema = createTestSchema();
    const output = emitIndex(schema);

    expect(output).not.toContain('WrapOptions');
  });
});
