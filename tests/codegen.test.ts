import { describe, it, expect } from 'vitest';
import { parseDMMF } from '../src/dmmf-parser.js';
import { buildCascadeGraph } from '../src/cascade-graph.js';
import {
  emitTypes,
  emitRuntime,
  emitCascadeGraph,
  emitIndex,
} from '../src/codegen/index.js';
import { createMockField, createMockModel, createMockDMMF } from './helpers/mock-dmmf.js';

function createTestSchema() {
  const models = [
    createMockModel({
      name: 'User',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String', isUnique: true }),
        createMockField({
          name: 'posts',
          type: 'Post',
          kind: 'object',
          isList: true,
          relationName: 'UserPosts',
        }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
      ],
    }),
    createMockModel({
      name: 'Post',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'title', type: 'String' }),
        createMockField({ name: 'authorId', type: 'String' }),
        createMockField({
          name: 'author',
          type: 'User',
          kind: 'object',
          relationName: 'UserPosts',
          relationFromFields: ['authorId'],
          relationToFields: ['id'],
          relationOnDelete: 'Cascade',
        }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
      ],
    }),
    createMockModel({
      name: 'AuditLog',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'action', type: 'String' }),
      ],
    }),
  ];

  return parseDMMF(createMockDMMF(models));
}

// Default client import path for tests
const TEST_CLIENT_PATH = '../client';

function createSchemaWithDeletedBy() {
  const models = [
    createMockModel({
      name: 'Customer',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String', isUnique: true }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
        createMockField({
          name: 'deleted_by',
          type: 'String',
          isRequired: false,
        }),
      ],
    }),
    createMockModel({
      name: 'User',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String', isUnique: true }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
        // No deleted_by field
      ],
    }),
  ];

  return parseDMMF(createMockDMMF(models));
}

describe('emitTypes', () => {
  it('generates type definitions with correct header', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('// Auto-generated by prisma-safe-delete');
    expect(output).toContain(`import type { PrismaClient, Prisma } from '${TEST_CLIENT_PATH}'`);
  });

  it('generates CascadeResult type', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export type CascadeResult = Record<string, number>;');
  });

  it('generates SafeUserDelegate with soft-delete methods', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export type SafeUserDelegate = Omit<');
    expect(output).toContain("'delete' | 'deleteMany'");
    expect(output).toContain('softDelete:');
    expect(output).toContain('softDeleteMany:');
    expect(output).toContain('restore:');
    expect(output).toContain('restoreMany:');
    expect(output).toContain('restoreCascade:');
    expect(output).toContain('__dangerousHardDelete:');
    expect(output).toContain('__dangerousHardDeleteMany:');
    expect(output).toContain('includingDeleted:');
  });

  it('generates softDelete with cascaded return type', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('softDelete: (args: Prisma.UserDeleteArgs');
    expect(output).toContain('Promise<{ record: Prisma.UserGetPayload<{}> | null; cascaded: CascadeResult }>');
    expect(output).toContain('softDeleteMany: (args: Prisma.UserDeleteManyArgs');
    expect(output).toContain('Promise<{ count: number; cascaded: CascadeResult }>');
    expect(output).toContain('restoreCascade: (args: Prisma.UserDeleteArgs)');
    expect(output).toContain('Promise<{ record: Prisma.UserGetPayload<{}> | null; cascaded: CascadeResult }>');
  });

  it('generates required deletedBy for models with deleted_by field', () => {
    const schema = createSchemaWithDeletedBy();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // Customer has deleted_by field - deletedBy should be required (no ?)
    expect(output).toMatch(/SafeCustomerDelegate[\s\S]*softDelete:[\s\S]*\{ deletedBy: string \}/);
    expect(output).toMatch(/SafeCustomerDelegate[\s\S]*softDeleteMany:[\s\S]*\{ deletedBy: string \}/);
  });

  it('generates optional deletedBy for models without deleted_by field', () => {
    const schema = createSchemaWithDeletedBy();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // User has no deleted_by field - deletedBy should be optional (?)
    expect(output).toMatch(/SafeUserDelegate[\s\S]*softDelete:[\s\S]*\{ deletedBy\?: string \}/);
    expect(output).toMatch(/SafeUserDelegate[\s\S]*softDeleteMany:[\s\S]*\{ deletedBy\?: string \}/);
  });

  it('generates softDeletePreview type for soft-deletable models', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('softDeletePreview: (args: Prisma.UserDeleteManyArgs) => Promise<{ wouldDelete: CascadeResult }>');
    expect(output).toContain('softDeletePreview: (args: Prisma.PostDeleteManyArgs) => Promise<{ wouldDelete: CascadeResult }>');
  });

  it('generates standard delegate for non-soft-deletable models', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain("export type SafeAuditLogDelegate = PrismaClient['auditLog']");
  });

  it('generates SafePrismaClient interface', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export interface SafePrismaClient {');
    expect(output).toContain('user: SafeUserDelegate');
    expect(output).toContain('post: SafePostDelegate');
    expect(output).toContain('auditLog: SafeAuditLogDelegate');
    expect(output).toContain('$prisma: PrismaClient');
    expect(output).toContain('$includingDeleted: IncludingDeletedClient');
    expect(output).toContain('$onlyDeleted: OnlyDeletedClient');
  });

  it('generates IncludingDeletedClient interface', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export interface IncludingDeletedClient {');
  });

  it('generates OnlyDeletedClient interface', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export interface OnlyDeletedClient {');
  });
});

describe('emitCascadeGraph', () => {
  it('generates cascade graph constant', () => {
    const schema = createTestSchema();
    const graph = buildCascadeGraph(schema);
    const output = emitCascadeGraph(graph);

    expect(output).toContain('export const CASCADE_GRAPH: CascadeGraph');
    expect(output).toContain('"User"');
    expect(output).toContain('"Post"');
  });

  it('generates CascadeChild interface', () => {
    const schema = createTestSchema();
    const graph = buildCascadeGraph(schema);
    const output = emitCascadeGraph(graph);

    expect(output).toContain('export interface CascadeChild');
    expect(output).toContain('model: string');
    expect(output).toContain('foreignKey: string[]');
    expect(output).toContain('parentKey: string[]');
  });

  it('generates MODEL_NAMES constant', () => {
    const schema = createTestSchema();
    const graph = buildCascadeGraph(schema);
    const output = emitCascadeGraph(graph);

    expect(output).toContain('export const MODEL_NAMES');
    expect(output).toContain('export type ModelName');
  });
});

describe('emitRuntime', () => {
  it('generates runtime with correct imports', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain(`import type { PrismaClient, Prisma } from '${TEST_CLIENT_PATH}'`);
    expect(output).toContain("import { CASCADE_GRAPH");
    expect(output).toContain("import type { SafePrismaClient");
  });

  it('defaults to mangle uniqueStrategy', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain("const UNIQUE_STRATEGY: 'mangle' | 'none' = 'mangle'");
  });

  it('respects uniqueStrategy: none option', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    expect(output).toContain("const UNIQUE_STRATEGY: 'mangle' | 'none' = 'none'");
    // mangleUniqueFields should still exist but will return {} at runtime
    expect(output).toContain("if (UNIQUE_STRATEGY === 'none') return {}");
  });

  it('respects uniqueStrategy: mangle option', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).toContain("const UNIQUE_STRATEGY: 'mangle' | 'none' = 'mangle'");
  });

  it('generates SOFT_DELETABLE_MODELS map', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('const SOFT_DELETABLE_MODELS');
    expect(output).toContain('User: { deletedAtField:');
    expect(output).toContain('Post: { deletedAtField:');
    expect(output).not.toContain('AuditLog: {');
  });

  it('generates PRIMARY_KEYS map', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('const PRIMARY_KEYS');
  });

  it('generates injectFilters function', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('function injectFilters');
  });

  it('generates softDeleteWithCascade function', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function softDeleteWithCascade');
    expect(output).toContain('prisma.$transaction');
  });

  it('generates restore functions', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function restoreRecord');
    expect(output).toContain('async function restoreRecordInTx');
    expect(output).toContain('async function restoreManyRecords');
    expect(output).toContain('async function restoreManyInTx');
    expect(output).toContain('function unmangleUniqueFields');
  });

  it('generates cascade restore functions', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function restoreWithCascade');
    expect(output).toContain('async function restoreWithCascadeInTx');
    expect(output).toContain('async function restoreCascadeChildren');
    // Check that restoreCascade is added to model delegates
    expect(output).toContain('restoreCascade:');
  });

  it('generates model delegate creators', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('function createUserDelegate');
    expect(output).toContain('function createPostDelegate');
    expect(output).toContain('function createAuditLogDelegate');
  });

  it('generates wrapPrismaClient export', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export function wrapPrismaClient');
  });

  it('simple model (leaf, no unique strings) emits updateMany-based softDeleteMany', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Post is a leaf model with no unique string fields - should use fast path
    // Look for updateMany in the Post delegate's softDeleteMany
    expect(output).toMatch(/createPostDelegate[\s\S]*?original\.updateMany\(/);
    // Post delegate should NOT call softDeleteWithCascade
    const postDelegateMatch = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegateMatch).not.toBeNull();
    expect(postDelegateMatch![0]).not.toContain('softDeleteWithCascade');
  });

  it('complex model (has cascade children) emits softDeleteWithCascade', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // User has cascade child Post - should use complex path
    const userDelegateMatch = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegateMatch).not.toBeNull();
    expect(userDelegateMatch![0]).toContain('softDeleteWithCascade');
  });

  it('applies injectFilters to update and updateMany', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Both User and Post delegates should inject filters on update/updateMany
    expect(output).toContain("update: ((args: any) => original.update(injectFilters(args, 'User'))) as PrismaClient['user']['update']");
    expect(output).toContain("updateMany: ((args: any) => original.updateMany(injectFilters(args, 'User'))) as PrismaClient['user']['updateMany']");
  });

  it('model with unique string fields but no children uses complex path with mangle strategy', () => {
    // Create a leaf model that has unique string fields
    const models = [
      createMockModel({
        name: 'Customer',
        fields: [
          createMockField({ name: 'id', type: 'String', isId: true }),
          createMockField({ name: 'email', type: 'String', isUnique: true }),
          createMockField({ name: 'deleted_at', type: 'DateTime', isRequired: false }),
        ],
      }),
    ];
    const schema = parseDMMF(createMockDMMF(models));
    const cascadeGraph = buildCascadeGraph(schema); // Customer has no children

    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Should use complex path because it has unique string fields that need mangling
    const customerDelegate = /function createCustomerDelegate[\s\S]*?^}/m.exec(output);
    expect(customerDelegate).not.toBeNull();
    expect(customerDelegate![0]).toContain('softDeleteWithCascade');
    expect(customerDelegate![0]).not.toContain('fast path');
  });

  it('model with unique string fields but no children uses fast path with none strategy', () => {
    // Same leaf model with unique string fields, but uniqueStrategy is 'none'
    const models = [
      createMockModel({
        name: 'Customer',
        fields: [
          createMockField({ name: 'id', type: 'String', isId: true }),
          createMockField({ name: 'email', type: 'String', isUnique: true }),
          createMockField({ name: 'deleted_at', type: 'DateTime', isRequired: false }),
        ],
      }),
    ];
    const schema = parseDMMF(createMockDMMF(models));
    const cascadeGraph = buildCascadeGraph(schema);

    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    // Should use fast path because uniqueStrategy='none' means no mangling regardless
    const customerDelegate = /function createCustomerDelegate[\s\S]*?^}/m.exec(output);
    expect(customerDelegate).not.toBeNull();
    expect(customerDelegate![0]).not.toContain('softDeleteWithCascade');
    expect(customerDelegate![0]).toContain('original.updateMany');
  });

  it('model with children always uses complex path regardless of uniqueStrategy', () => {
    const schema = createTestSchema(); // User has Post children
    const cascadeGraph = buildCascadeGraph(schema);

    // Even with uniqueStrategy='none', User should use complex path because it has children
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('softDeleteWithCascade');
  });

  it('fast-path softDelete returns { record, cascaded: {} }', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Post is a fast-path model. Check its softDelete returns { record, cascaded: {} }
    const postDelegate = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegate).not.toBeNull();
    expect(postDelegate![0]).toContain('return { record, cascaded: {} }');
  });

  it('fast-path softDeleteMany returns { count: result.count, cascaded: {} }', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const postDelegate = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegate).not.toBeNull();
    expect(postDelegate![0]).toContain('return { count: result.count, cascaded: {} }');
  });

  it('complex-path softDelete returns { record, cascaded }', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // User is a complex-path model
    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('return { record, cascaded }');
  });

  it('complex-path softDeleteMany returns { count, cascaded }', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('return { count, cascaded }');
  });

  it('transaction wrapper uses fast path for simple models', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Find the wrapTransactionClient function
    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];

    // Post (simple) should use tx.post.updateMany in softDelete, not softDeleteWithCascadeInTx
    const postSection = /post: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(postSection).not.toBeNull();
    expect(postSection![0]).toContain('tx.post.updateMany');
    expect(postSection![0]).not.toContain('softDeleteWithCascadeInTx');

    // User (complex) should use softDeleteWithCascadeInTx in transaction
    const userSection = /user: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(userSection).not.toBeNull();
    expect(userSection![0]).toContain('softDeleteWithCascadeInTx');
  });

  it('fast-path includes deleted_by support when model has deleted_by field', () => {
    const schema = createSchemaWithDeletedBy();
    // Customer has deleted_by but no children → if unique fields exist it depends on strategy
    // User has no deleted_by and no children
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    // Customer has unique string fields but uniqueStrategy='none' → fast path
    const customerDelegate = /function createCustomerDelegate[\s\S]*?^}/m.exec(output);
    expect(customerDelegate).not.toBeNull();
    const customerCode = customerDelegate![0];
    // Should reference deleted_by field in fast path
    expect(customerCode).toContain('deletedByField');
    expect(customerCode).toContain('deleted_by');
  });

  it('generates previewSoftDelete and previewCascadeChildren functions', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function previewSoftDelete');
    expect(output).toContain('async function previewSoftDeleteInTx');
    expect(output).toContain('async function previewCascadeChildren');
  });

  it('simple model delegate emits softDeletePreview with count', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Post is a simple model (leaf, no unique strings)
    const postDelegate = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegate).not.toBeNull();
    expect(postDelegate![0]).toContain('softDeletePreview');
    expect(postDelegate![0]).toContain('original.count');
    expect(postDelegate![0]).toContain('wouldDelete');
  });

  it('complex model delegate emits softDeletePreview with cascade preview', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // User is a complex model (has cascade children)
    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('softDeletePreview');
    expect(userDelegate![0]).toContain('previewSoftDelete');
  });

  it('transaction wrapper includes softDeletePreview for simple models', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];

    // Post (simple) should have softDeletePreview with tx.post.count
    const postSection = /post: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(postSection).not.toBeNull();
    expect(postSection![0]).toContain('softDeletePreview');
    expect(postSection![0]).toContain('tx.post.count');
  });

  it('transaction wrapper includes softDeletePreview for complex models', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];

    // User (complex) should have softDeletePreview with previewSoftDeleteInTx
    const userSection = /user: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(userSection).not.toBeNull();
    expect(userSection![0]).toContain('softDeletePreview');
    expect(userSection![0]).toContain('previewSoftDeleteInTx');
  });
});

describe('emitIndex', () => {
  it('generates index with all exports', () => {
    const schema = createTestSchema();
    const output = emitIndex(schema);

    expect(output).toContain("export type { SafePrismaClient");
    expect(output).toContain("CascadeResult");
    expect(output).toContain("export type { SafeUserDelegate }");
    expect(output).toContain("export type { SafePostDelegate }");
    expect(output).toContain("export { CASCADE_GRAPH, MODEL_NAMES }");
    expect(output).toContain("export { wrapPrismaClient }");
  });
});
