import { describe, it, expect } from 'vitest';
import { parseDMMF } from '../src/dmmf-parser.js';
import { buildCascadeGraph } from '../src/cascade-graph.js';
import {
  emitTypes,
  emitRuntime,
  emitCascadeGraph,
  emitIndex,
} from '../src/codegen/index.js';
import { createMockField, createMockModel, createMockDMMF } from './helpers/mock-dmmf.js';

function createTestSchema() {
  const models = [
    createMockModel({
      name: 'User',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String', isUnique: true }),
        createMockField({
          name: 'posts',
          type: 'Post',
          kind: 'object',
          isList: true,
          relationName: 'UserPosts',
        }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
      ],
    }),
    createMockModel({
      name: 'Post',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'title', type: 'String' }),
        createMockField({ name: 'authorId', type: 'String' }),
        createMockField({
          name: 'author',
          type: 'User',
          kind: 'object',
          relationName: 'UserPosts',
          relationFromFields: ['authorId'],
          relationToFields: ['id'],
          relationOnDelete: 'Cascade',
        }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
      ],
    }),
    createMockModel({
      name: 'AuditLog',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'action', type: 'String' }),
      ],
    }),
  ];

  return parseDMMF(createMockDMMF(models));
}

// Default client import path for tests
const TEST_CLIENT_PATH = '../client';

function createSchemaWithDeletedBy() {
  const models = [
    createMockModel({
      name: 'Customer',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String', isUnique: true }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
        createMockField({
          name: 'deleted_by',
          type: 'String',
          isRequired: false,
        }),
      ],
    }),
    createMockModel({
      name: 'User',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String', isUnique: true }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
        // No deleted_by field
      ],
    }),
  ];

  return parseDMMF(createMockDMMF(models));
}

describe('emitTypes', () => {
  it('generates type definitions with correct header', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('// Auto-generated by prisma-safe-delete');
    expect(output).toContain(`import type { PrismaClient, Prisma } from '${TEST_CLIENT_PATH}'`);
  });

  it('generates SafeUserDelegate with soft-delete methods', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export type SafeUserDelegate = Omit<');
    expect(output).toContain("'delete' | 'deleteMany'");
    expect(output).toContain('softDelete:');
    expect(output).toContain('softDeleteMany:');
    expect(output).toContain('restore:');
    expect(output).toContain('restoreMany:');
    expect(output).toContain('restoreCascade:');
    expect(output).toContain('__dangerousHardDelete:');
    expect(output).toContain('__dangerousHardDeleteMany:');
    expect(output).toContain('includingDeleted:');
  });

  it('generates required deletedBy for models with deleted_by field', () => {
    const schema = createSchemaWithDeletedBy();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // Customer has deleted_by field - deletedBy should be required (no ?)
    expect(output).toMatch(/SafeCustomerDelegate[\s\S]*softDelete:[\s\S]*\{ deletedBy: string \}/);
    expect(output).toMatch(/SafeCustomerDelegate[\s\S]*softDeleteMany:[\s\S]*\{ deletedBy: string \}/);
  });

  it('generates optional deletedBy for models without deleted_by field', () => {
    const schema = createSchemaWithDeletedBy();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // User has no deleted_by field - deletedBy should be optional (?)
    expect(output).toMatch(/SafeUserDelegate[\s\S]*softDelete:[\s\S]*\{ deletedBy\?: string \}/);
    expect(output).toMatch(/SafeUserDelegate[\s\S]*softDeleteMany:[\s\S]*\{ deletedBy\?: string \}/);
  });

  it('generates standard delegate for non-soft-deletable models', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain("export type SafeAuditLogDelegate = PrismaClient['auditLog']");
  });

  it('generates SafePrismaClient interface', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export interface SafePrismaClient {');
    expect(output).toContain('user: SafeUserDelegate');
    expect(output).toContain('post: SafePostDelegate');
    expect(output).toContain('auditLog: SafeAuditLogDelegate');
    expect(output).toContain('$prisma: PrismaClient');
    expect(output).toContain('$includingDeleted: IncludingDeletedClient');
    expect(output).toContain('$onlyDeleted: OnlyDeletedClient');
  });

  it('generates IncludingDeletedClient interface', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export interface IncludingDeletedClient {');
  });

  it('generates OnlyDeletedClient interface', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export interface OnlyDeletedClient {');
  });
});

describe('emitCascadeGraph', () => {
  it('generates cascade graph constant', () => {
    const schema = createTestSchema();
    const graph = buildCascadeGraph(schema);
    const output = emitCascadeGraph(graph);

    expect(output).toContain('export const CASCADE_GRAPH: CascadeGraph');
    expect(output).toContain('"User"');
    expect(output).toContain('"Post"');
  });

  it('generates CascadeChild interface', () => {
    const schema = createTestSchema();
    const graph = buildCascadeGraph(schema);
    const output = emitCascadeGraph(graph);

    expect(output).toContain('export interface CascadeChild');
    expect(output).toContain('model: string');
    expect(output).toContain('foreignKey: string[]');
    expect(output).toContain('parentKey: string[]');
  });

  it('generates MODEL_NAMES constant', () => {
    const schema = createTestSchema();
    const graph = buildCascadeGraph(schema);
    const output = emitCascadeGraph(graph);

    expect(output).toContain('export const MODEL_NAMES');
    expect(output).toContain('export type ModelName');
  });
});

describe('emitRuntime', () => {
  it('generates runtime with correct imports', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain(`import type { PrismaClient, Prisma } from '${TEST_CLIENT_PATH}'`);
    expect(output).toContain("import { CASCADE_GRAPH");
    expect(output).toContain("import type { SafePrismaClient");
  });

  it('defaults to mangle uniqueStrategy', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain("const UNIQUE_STRATEGY: 'mangle' | 'none' = 'mangle'");
  });

  it('respects uniqueStrategy: none option', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none' });

    expect(output).toContain("const UNIQUE_STRATEGY: 'mangle' | 'none' = 'none'");
    // mangleUniqueFields should still exist but will return {} at runtime
    expect(output).toContain("if (UNIQUE_STRATEGY === 'none') return {}");
  });

  it('respects uniqueStrategy: mangle option', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle' });

    expect(output).toContain("const UNIQUE_STRATEGY: 'mangle' | 'none' = 'mangle'");
  });

  it('generates SOFT_DELETABLE_MODELS map', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('const SOFT_DELETABLE_MODELS');
    expect(output).toContain('User: { deletedAtField:');
    expect(output).toContain('Post: { deletedAtField:');
    expect(output).not.toContain('AuditLog: {');
  });

  it('generates PRIMARY_KEYS map', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('const PRIMARY_KEYS');
  });

  it('generates injectFilters function', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('function injectFilters');
  });

  it('generates softDeleteWithCascade function', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function softDeleteWithCascade');
    expect(output).toContain('prisma.$transaction');
  });

  it('generates restore functions', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function restoreRecord');
    expect(output).toContain('async function restoreRecordInTx');
    expect(output).toContain('async function restoreManyRecords');
    expect(output).toContain('async function restoreManyInTx');
    expect(output).toContain('function unmangleUniqueFields');
  });

  it('generates cascade restore functions', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function restoreWithCascade');
    expect(output).toContain('async function restoreWithCascadeInTx');
    expect(output).toContain('async function restoreCascadeChildren');
    // Check that restoreCascade is added to model delegates
    expect(output).toContain('restoreCascade:');
  });

  it('generates model delegate creators', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('function createUserDelegate');
    expect(output).toContain('function createPostDelegate');
    expect(output).toContain('function createAuditLogDelegate');
  });

  it('generates wrapPrismaClient export', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export function wrapPrismaClient');
  });
});

describe('emitIndex', () => {
  it('generates index with all exports', () => {
    const schema = createTestSchema();
    const output = emitIndex(schema);

    expect(output).toContain("export type { SafePrismaClient");
    expect(output).toContain("export type { SafeUserDelegate }");
    expect(output).toContain("export type { SafePostDelegate }");
    expect(output).toContain("export { CASCADE_GRAPH, MODEL_NAMES }");
    expect(output).toContain("export { wrapPrismaClient }");
  });
});
