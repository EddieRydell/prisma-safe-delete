import { describe, it, expect } from 'vitest';
import { parseDMMF } from '../src/dmmf-parser.js';
import { buildCascadeGraph } from '../src/cascade-graph.js';
import {
  emitTypes,
  emitRuntime,
  emitCascadeGraph,
  emitIndex,
} from '../src/codegen/index.js';
import { createMockField, createMockModel, createMockDMMF } from './helpers/mock-dmmf.js';

function createTestSchema() {
  const models = [
    createMockModel({
      name: 'User',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String', isUnique: true }),
        createMockField({
          name: 'posts',
          type: 'Post',
          kind: 'object',
          isList: true,
          relationName: 'UserPosts',
        }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
      ],
    }),
    createMockModel({
      name: 'Post',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'title', type: 'String' }),
        createMockField({ name: 'authorId', type: 'String' }),
        createMockField({
          name: 'author',
          type: 'User',
          kind: 'object',
          relationName: 'UserPosts',
          relationFromFields: ['authorId'],
          relationToFields: ['id'],
          relationOnDelete: 'Cascade',
        }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
      ],
    }),
    createMockModel({
      name: 'AuditLog',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'action', type: 'String' }),
      ],
    }),
  ];

  return parseDMMF(createMockDMMF(models));
}

// Default client import path for tests
const TEST_CLIENT_PATH = '../client';

function createSchemaWithDeletedBy() {
  const models = [
    createMockModel({
      name: 'Customer',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String', isUnique: true }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
        createMockField({
          name: 'deleted_by',
          type: 'String',
          isRequired: false,
        }),
      ],
    }),
    createMockModel({
      name: 'User',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String', isUnique: true }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: false,
        }),
        // No deleted_by field
      ],
    }),
  ];

  return parseDMMF(createMockDMMF(models));
}

describe('emitTypes', () => {
  it('generates type definitions with correct header', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('// Auto-generated by prisma-safe-delete');
    expect(output).toContain('// @ts-nocheck');
    expect(output).toContain(`import type { PrismaClient, Prisma } from '${TEST_CLIENT_PATH}'`);
  });

  it('generates CascadeResult type', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export type CascadeResult = Record<string, number>;');
  });

  it('generates SafeUserDelegate with soft-delete methods', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export type SafeUserDelegate = Omit<');
    expect(output).toContain("'delete' | 'deleteMany'");
    expect(output).toContain('softDelete:');
    expect(output).toContain('softDeleteMany:');
    expect(output).toContain('restore:');
    expect(output).toContain('restoreMany:');
    expect(output).toContain('restoreCascade:');
    expect(output).toContain('__dangerousHardDelete:');
    expect(output).toContain('__dangerousHardDeleteMany:');
    expect(output).toContain('includingDeleted:');
  });

  it('generates softDelete with cascaded return type', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('softDelete: (args: Prisma.UserDeleteArgs');
    expect(output).toContain('Promise<{ record: Prisma.UserGetPayload<{}> | null; cascaded: CascadeResult }>');
    expect(output).toContain('softDeleteMany: (args: Prisma.UserDeleteManyArgs');
    expect(output).toContain('Promise<{ count: number; cascaded: CascadeResult }>');
    expect(output).toContain('restoreCascade: (args: Prisma.UserDeleteArgs)');
    expect(output).toContain('Promise<{ record: Prisma.UserGetPayload<{}> | null; cascaded: CascadeResult }>');
  });

  it('generates required deletedBy for models with deleted_by field', () => {
    const schema = createSchemaWithDeletedBy();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // Customer has deleted_by field - deletedBy should be required (no ?)
    expect(output).toMatch(/SafeCustomerDelegate[\s\S]*softDelete:[\s\S]*\{ deletedBy: string \}/);
    expect(output).toMatch(/SafeCustomerDelegate[\s\S]*softDeleteMany:[\s\S]*\{ deletedBy: string \}/);
  });

  it('generates optional deletedBy for models without deleted_by field', () => {
    const schema = createSchemaWithDeletedBy();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // User has no deleted_by field - deletedBy should be optional (?)
    expect(output).toMatch(/SafeUserDelegate[\s\S]*softDelete:[\s\S]*\{ deletedBy\?: string \}/);
    expect(output).toMatch(/SafeUserDelegate[\s\S]*softDeleteMany:[\s\S]*\{ deletedBy\?: string \}/);
  });

  it('generates softDeletePreview type for soft-deletable models', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('softDeletePreview: (args: Prisma.UserDeleteManyArgs) => Promise<{ wouldDelete: CascadeResult }>');
    expect(output).toContain('softDeletePreview: (args: Prisma.PostDeleteManyArgs) => Promise<{ wouldDelete: CascadeResult }>');
  });

  it('generates standard delegate for non-soft-deletable models', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain("export type SafeAuditLogDelegate = PrismaClient['auditLog']");
  });

  it('generates SafePrismaClient interface', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export interface SafePrismaClient {');
    expect(output).toContain('user: SafeUserDelegate');
    expect(output).toContain('post: SafePostDelegate');
    expect(output).toContain('auditLog: SafeAuditLogDelegate');
    expect(output).toContain('$prisma: PrismaClient');
    expect(output).toContain('$includingDeleted: IncludingDeletedClient');
    expect(output).toContain('$onlyDeleted: OnlyDeletedClient');
  });

  it('generates IncludingDeletedClient interface', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export interface IncludingDeletedClient {');
  });

  it('generates OnlyDeletedClient interface', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export interface OnlyDeletedClient {');
  });
});

describe('emitCascadeGraph', () => {
  it('generates cascade graph constant', () => {
    const schema = createTestSchema();
    const graph = buildCascadeGraph(schema);
    const output = emitCascadeGraph(graph);

    expect(output).toContain('export const CASCADE_GRAPH: CascadeGraph');
    expect(output).toContain('"User"');
    expect(output).toContain('"Post"');
  });

  it('generates CascadeChild interface', () => {
    const schema = createTestSchema();
    const graph = buildCascadeGraph(schema);
    const output = emitCascadeGraph(graph);

    expect(output).toContain('export interface CascadeChild');
    expect(output).toContain('model: string');
    expect(output).toContain('foreignKey: string[]');
    expect(output).toContain('parentKey: string[]');
  });

  it('generates MODEL_NAMES constant', () => {
    const schema = createTestSchema();
    const graph = buildCascadeGraph(schema);
    const output = emitCascadeGraph(graph);

    expect(output).toContain('export const MODEL_NAMES');
    expect(output).toContain('export type ModelName');
  });
});

describe('emitRuntime', () => {
  it('generates runtime with correct imports', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('// @ts-nocheck');
    expect(output).toContain(`import type { PrismaClient, Prisma } from '${TEST_CLIENT_PATH}'`);
    expect(output).toContain("import { CASCADE_GRAPH");
    expect(output).toContain("import type { SafePrismaClient");
  });

  it('defaults to mangle uniqueStrategy', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain("const UNIQUE_STRATEGY: 'mangle' | 'none' | 'sentinel' = 'mangle'");
  });

  it('respects uniqueStrategy: none option', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    expect(output).toContain("const UNIQUE_STRATEGY: 'mangle' | 'none' | 'sentinel' = 'none'");
    // mangleUniqueFields should still exist but will return {} at runtime
    expect(output).toContain("if (UNIQUE_STRATEGY === 'none' || UNIQUE_STRATEGY === 'sentinel') return {}");
  });

  it('respects uniqueStrategy: mangle option', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).toContain("const UNIQUE_STRATEGY: 'mangle' | 'none' | 'sentinel' = 'mangle'");
  });

  it('generates SOFT_DELETABLE_MODELS map', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('const SOFT_DELETABLE_MODELS');
    expect(output).toContain('User: { deletedAtField:');
    expect(output).toContain('Post: { deletedAtField:');
    expect(output).not.toContain('AuditLog: {');
  });

  it('generates PRIMARY_KEYS map', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('const PRIMARY_KEYS');
  });

  it('generates injectFilters function', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('function injectFilters');
  });

  it('generates softDeleteWithCascade function', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function softDeleteWithCascade');
    expect(output).toContain('prisma.$transaction');
  });

  it('generates restore functions', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function restoreRecord');
    expect(output).toContain('async function restoreRecordInTx');
    expect(output).toContain('async function restoreManyRecords');
    expect(output).toContain('async function restoreManyInTx');
    expect(output).toContain('function unmangleUniqueFields');
  });

  it('generates cascade restore functions', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function restoreWithCascade');
    expect(output).toContain('async function restoreWithCascadeInTx');
    expect(output).toContain('async function restoreCascadeChildren');
    // Check that restoreCascade is added to model delegates
    expect(output).toContain('restoreCascade:');
  });

  it('generates model delegate creators', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('function createUserDelegate');
    expect(output).toContain('function createPostDelegate');
    expect(output).toContain('function createAuditLogDelegate');
  });

  it('generates wrapPrismaClient export', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('export function wrapPrismaClient');
  });

  it('simple model (leaf, no unique strings) emits updateMany-based softDeleteMany', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Post is a leaf model with no unique string fields - should use fast path
    // Look for updateMany in the Post delegate's softDeleteMany
    expect(output).toMatch(/createPostDelegate[\s\S]*?original\.updateMany\(/);
    // Post delegate should NOT call softDeleteWithCascade
    const postDelegateMatch = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegateMatch).not.toBeNull();
    expect(postDelegateMatch![0]).not.toContain('softDeleteWithCascade');
  });

  it('complex model (has cascade children) emits softDeleteWithCascade', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // User has cascade child Post - should use complex path
    const userDelegateMatch = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegateMatch).not.toBeNull();
    expect(userDelegateMatch![0]).toContain('softDeleteWithCascade');
  });

  it('applies injectFilters to update and updateMany', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Both User and Post delegates should inject filters on update/updateMany
    expect(output).toContain("update: ((args: any) => original.update(injectFilters(args, 'User'))) as PrismaClient['user']['update']");
    expect(output).toContain("updateMany: ((args: any) => original.updateMany(injectFilters(args, 'User'))) as PrismaClient['user']['updateMany']");
  });

  it('model with unique string fields but no children uses complex path with mangle strategy', () => {
    // Create a leaf model that has unique string fields
    const models = [
      createMockModel({
        name: 'Customer',
        fields: [
          createMockField({ name: 'id', type: 'String', isId: true }),
          createMockField({ name: 'email', type: 'String', isUnique: true }),
          createMockField({ name: 'deleted_at', type: 'DateTime', isRequired: false }),
        ],
      }),
    ];
    const schema = parseDMMF(createMockDMMF(models));
    const cascadeGraph = buildCascadeGraph(schema); // Customer has no children

    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Should use complex path because it has unique string fields that need mangling
    const customerDelegate = /function createCustomerDelegate[\s\S]*?^}/m.exec(output);
    expect(customerDelegate).not.toBeNull();
    expect(customerDelegate![0]).toContain('softDeleteWithCascade');
    expect(customerDelegate![0]).not.toContain('fast path');
  });

  it('model with unique string fields but no children uses fast path with none strategy', () => {
    // Same leaf model with unique string fields, but uniqueStrategy is 'none'
    const models = [
      createMockModel({
        name: 'Customer',
        fields: [
          createMockField({ name: 'id', type: 'String', isId: true }),
          createMockField({ name: 'email', type: 'String', isUnique: true }),
          createMockField({ name: 'deleted_at', type: 'DateTime', isRequired: false }),
        ],
      }),
    ];
    const schema = parseDMMF(createMockDMMF(models));
    const cascadeGraph = buildCascadeGraph(schema);

    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    // Should use fast path because uniqueStrategy='none' means no mangling regardless
    const customerDelegate = /function createCustomerDelegate[\s\S]*?^}/m.exec(output);
    expect(customerDelegate).not.toBeNull();
    expect(customerDelegate![0]).not.toContain('softDeleteWithCascade');
    expect(customerDelegate![0]).toContain('original.updateMany');
  });

  it('model with children always uses complex path regardless of uniqueStrategy', () => {
    const schema = createTestSchema(); // User has Post children
    const cascadeGraph = buildCascadeGraph(schema);

    // Even with uniqueStrategy='none', User should use complex path because it has children
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('softDeleteWithCascade');
  });

  it('fast-path softDelete returns { record, cascaded: {} }', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Post is a fast-path model. Check its softDelete returns { record, cascaded: {} }
    const postDelegate = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegate).not.toBeNull();
    expect(postDelegate![0]).toContain('return { record, cascaded: {} }');
  });

  it('fast-path softDeleteMany returns { count: result.count, cascaded: {} }', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const postDelegate = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegate).not.toBeNull();
    expect(postDelegate![0]).toContain('return { count: result.count, cascaded: {} }');
  });

  it('complex-path softDelete returns { record, cascaded }', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // User is a complex-path model
    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('return { record, cascaded }');
  });

  it('complex-path softDeleteMany returns { count, cascaded }', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('return { count, cascaded }');
  });

  it('transaction wrapper uses fast path for simple models', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Find the wrapTransactionClient function
    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];

    // Post (simple) should use tx.post.updateMany in softDelete, not softDeleteWithCascadeInTx
    const postSection = /post: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(postSection).not.toBeNull();
    expect(postSection![0]).toContain('tx.post.updateMany');
    expect(postSection![0]).not.toContain('softDeleteWithCascadeInTx');

    // User (complex) should use softDeleteWithCascadeInTx in transaction
    const userSection = /user: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(userSection).not.toBeNull();
    expect(userSection![0]).toContain('softDeleteWithCascadeInTx');
  });

  it('fast-path includes deleted_by support when model has deleted_by field', () => {
    const schema = createSchemaWithDeletedBy();
    // Customer has deleted_by but no children → if unique fields exist it depends on strategy
    // User has no deleted_by and no children
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    // Customer has unique string fields but uniqueStrategy='none' → fast path
    const customerDelegate = /function createCustomerDelegate[\s\S]*?^}/m.exec(output);
    expect(customerDelegate).not.toBeNull();
    const customerCode = customerDelegate![0];
    // Should reference deleted_by field in fast path
    expect(customerCode).toContain('deletedByField');
    expect(customerCode).toContain('deleted_by');
  });

  it('generates previewSoftDelete and previewCascadeChildren functions', () => {
    const schema = createTestSchema();
    const output = emitRuntime(schema, TEST_CLIENT_PATH);

    expect(output).toContain('async function previewSoftDelete');
    expect(output).toContain('async function previewSoftDeleteInTx');
    expect(output).toContain('async function previewCascadeChildren');
  });

  it('simple model delegate emits softDeletePreview with count', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Post is a simple model (leaf, no unique strings)
    const postDelegate = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegate).not.toBeNull();
    expect(postDelegate![0]).toContain('softDeletePreview');
    expect(postDelegate![0]).toContain('original.count');
    expect(postDelegate![0]).toContain('wouldDelete');
  });

  it('complex model delegate emits softDeletePreview with cascade preview', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // User is a complex model (has cascade children)
    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('softDeletePreview');
    expect(userDelegate![0]).toContain('previewSoftDelete');
  });

  it('transaction wrapper includes softDeletePreview for simple models', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];

    // Post (simple) should have softDeletePreview with tx.post.count
    const postSection = /post: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(postSection).not.toBeNull();
    expect(postSection![0]).toContain('softDeletePreview');
    expect(postSection![0]).toContain('tx.post.count');
  });

  it('transaction wrapper includes softDeletePreview for complex models', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];

    // User (complex) should have softDeletePreview with previewSoftDeleteInTx
    const userSection = /user: \{[\s\S]*?\},\n\s{4}\w/.exec(txContent);
    expect(userSection).not.toBeNull();
    expect(userSection![0]).toContain('softDeletePreview');
    expect(userSection![0]).toContain('previewSoftDeleteInTx');
  });
});

function createSentinelSchema() {
  // Sentinel strategy: deleted_at is non-nullable DateTime with default
  const models = [
    createMockModel({
      name: 'User',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'email', type: 'String' }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: true,
          hasDefaultValue: true,
        }),
      ],
      uniqueFields: [['email', 'deleted_at']],
      uniqueIndexes: [{ name: 'email_deleted_at', fields: ['email', 'deleted_at'] }],
    }),
    createMockModel({
      name: 'Post',
      fields: [
        createMockField({ name: 'id', type: 'String', isId: true }),
        createMockField({ name: 'title', type: 'String' }),
        createMockField({ name: 'authorId', type: 'String' }),
        createMockField({
          name: 'author',
          type: 'User',
          kind: 'object',
          relationName: 'UserPosts',
          relationFromFields: ['authorId'],
          relationToFields: ['id'],
          relationOnDelete: 'Cascade',
        }),
        createMockField({
          name: 'deleted_at',
          type: 'DateTime',
          isRequired: true,
          hasDefaultValue: true,
        }),
      ],
    }),
  ];

  return parseDMMF(createMockDMMF(models));
}

describe('emitRuntime - sentinel strategy', () => {
  it('emits ACTIVE_DELETED_AT_VALUE as Date for sentinel', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    expect(output).toContain("const ACTIVE_DELETED_AT_VALUE: Date = new Date('9999-12-31T00:00:00.000Z')");
  });

  it('emits ACTIVE_DELETED_AT_VALUE as null for mangle', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).toContain('const ACTIVE_DELETED_AT_VALUE: null = null');
  });

  it('emits ACTIVE_DELETED_AT_VALUE as null for none', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    expect(output).toContain('const ACTIVE_DELETED_AT_VALUE: null = null');
  });

  it('emits SENTINEL_COMPOUND_UNIQUES metadata for sentinel', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    expect(output).toContain('const SENTINEL_COMPOUND_UNIQUES');
    expect(output).toContain('User: [{ keyName: "email_deleted_at"');
  });

  it('does not emit SENTINEL_COMPOUND_UNIQUES for mangle', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).not.toContain('SENTINEL_COMPOUND_UNIQUES');
  });

  it('emits transformSentinelFindUniqueWhere for sentinel', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    expect(output).toContain('function transformSentinelFindUniqueWhere');
  });

  it('does not emit transformSentinelFindUniqueWhere for mangle', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).not.toContain('transformSentinelFindUniqueWhere');
  });

  it('sentinel uses fast path for leaf models (like none)', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // Post is a leaf model (no children) - should use fast path with sentinel
    const postDelegate = /function createPostDelegate[\s\S]*?^}/m.exec(output);
    expect(postDelegate).not.toBeNull();
    expect(postDelegate![0]).not.toContain('softDeleteWithCascade');
    expect(postDelegate![0]).toContain('original.updateMany');
  });

  it('sentinel uses complex path for models with children', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // User has cascade child Post - should use complex path
    const userDelegate = /function createUserDelegate[\s\S]*?^}/m.exec(output);
    expect(userDelegate).not.toBeNull();
    expect(userDelegate![0]).toContain('softDeleteWithCascade');
  });

  it('sentinel create methods inject ACTIVE_DELETED_AT_VALUE', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // Model delegate should inject sentinel into create
    expect(output).toContain("ACTIVE_DELETED_AT_VALUE } })) as PrismaClient['user']['create']");
    expect(output).toContain("ACTIVE_DELETED_AT_VALUE }))");
  });

  it('non-sentinel create methods are pass-through', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Create should be pass-through for mangle
    expect(output).toContain("create: ((args: any) => original.create(args))");
  });

  it('sentinel findUnique calls transformSentinelFindUniqueWhere', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    expect(output).toContain('transformSentinelFindUniqueWhere');
  });

  it('uses ACTIVE_DELETED_AT_VALUE in getModeFilter', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    expect(output).toContain('[deletedAtField]: ACTIVE_DELETED_AT_VALUE');
    expect(output).toContain('[deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE }');
  });

  it('uses ACTIVE_DELETED_AT_VALUE in soft delete where clauses', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // Simple-path softDelete should use ACTIVE_DELETED_AT_VALUE
    expect(output).toContain("['deleted_at']: ACTIVE_DELETED_AT_VALUE }");
  });

  it('mangle/unmangle return empty for sentinel', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    expect(output).toContain("if (UNIQUE_STRATEGY === 'none' || UNIQUE_STRATEGY === 'sentinel') return {}");
  });

  it('sentinel upsert injects ACTIVE_DELETED_AT_VALUE on create branch and applies transformSentinelFindUniqueWhere', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // Model delegate upsert should inject sentinel into create data, call injectFilters, and transform where
    expect(output).toContain("ACTIVE_DELETED_AT_VALUE");
    expect(output).toContain("filtered.where = transformSentinelFindUniqueWhere(filtered.where");
    expect(output).toContain("return original.upsert(filtered)");
  });

  it('non-sentinel upsert applies injectFilters', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Upsert should call injectFilters for mangle strategy
    expect(output).toContain("upsert: ((args: any) => original.upsert(injectFilters(args,");
  });
});

describe('emitTypes - $onlyDeleted parity', () => {
  it('OnlyDeletedClient includes all 8 read operations', () => {
    const schema = createTestSchema();
    const output = emitTypes(schema, TEST_CLIENT_PATH);

    // OnlyDeletedClient should have parity with IncludingDeletedClient
    const onlyDeletedMatch = /export interface OnlyDeletedClient \{[\s\S]*?\}/.exec(output);
    expect(onlyDeletedMatch).not.toBeNull();
    const onlyDeletedBlock = onlyDeletedMatch![0];
    expect(onlyDeletedBlock).toContain("'findMany'");
    expect(onlyDeletedBlock).toContain("'findFirst'");
    expect(onlyDeletedBlock).toContain("'findFirstOrThrow'");
    expect(onlyDeletedBlock).toContain("'findUnique'");
    expect(onlyDeletedBlock).toContain("'findUniqueOrThrow'");
    expect(onlyDeletedBlock).toContain("'count'");
    expect(onlyDeletedBlock).toContain("'aggregate'");
    expect(onlyDeletedBlock).toContain("'groupBy'");
  });
});

describe('emitRuntime - $onlyDeleted parity', () => {
  it('$onlyDeleted client includes all 8 read operations', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // The createOnlyDeletedClient function should emit all 8 ops
    const onlyDeletedFunc = /function createOnlyDeletedClient[\s\S]*?^}/m.exec(output);
    expect(onlyDeletedFunc).not.toBeNull();
    const funcBody = onlyDeletedFunc![0];
    expect(funcBody).toContain('findMany');
    expect(funcBody).toContain('findFirst');
    expect(funcBody).toContain('findFirstOrThrow');
    expect(funcBody).toContain('findUnique');
    expect(funcBody).toContain('findUniqueOrThrow');
    expect(funcBody).toContain('count');
    expect(funcBody).toContain('aggregate');
    expect(funcBody).toContain('groupBy');
  });

  it('transaction $onlyDeleted includes all 8 read operations', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];
    // Find the $onlyDeleted section within the tx wrapper
    const onlyDeletedSection = /\$onlyDeleted: \{[\s\S]*?\},\n\n/.exec(txContent);
    expect(onlyDeletedSection).not.toBeNull();
    const section = onlyDeletedSection![0];
    expect(section).toContain("'only-deleted'");
    expect(section).toContain('findFirstOrThrow');
    expect(section).toContain('findUniqueOrThrow');
    expect(section).toContain('aggregate');
    expect(section).toContain('groupBy');
  });
});

describe('emitRuntime - sentinel transformSentinelFindUniqueWhere multi-compound', () => {
  it('transforms multiple compound uniques containing deleted_at', () => {
    // Create a model with two compound uniques both including deleted_at
    const models = [
      createMockModel({
        name: 'Member',
        fields: [
          createMockField({ name: 'id', type: 'String', isId: true }),
          createMockField({ name: 'email', type: 'String' }),
          createMockField({ name: 'orgId', type: 'String' }),
          createMockField({
            name: 'deleted_at',
            type: 'DateTime',
            isRequired: true,
            hasDefaultValue: true,
          }),
        ],
        uniqueFields: [['email', 'deleted_at'], ['orgId', 'deleted_at']],
        uniqueIndexes: [
          { name: 'email_deleted_at', fields: ['email', 'deleted_at'] },
          { name: 'orgId_deleted_at', fields: ['orgId', 'deleted_at'] },
        ],
      }),
    ];

    const schema = parseDMMF(createMockDMMF(models));
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // Should have both compound uniques in metadata
    expect(output).toContain('email_deleted_at');
    expect(output).toContain('orgId_deleted_at');
    // The transform function should not return early on first match
    expect(output).toContain('const consumedFields = new Set');
  });

  it('transform filters out deleted_at from field presence check', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    // The function should filter deleted_at out of the fields check so that
    // a simple { email: 'foo' } where clause triggers the compound transform.
    // This is critical: without this, users must always pass the compound key form.
    expect(output).toContain('const nonDeletedAtFields = fields.filter');
    expect(output).toContain('f !== deletedAtField');
    expect(output).toContain('nonDeletedAtFields.every');
  });
});

describe('emitRuntime - cascade N+1 optimization', () => {
  it('emits bulk updateMany optimization in cascadeToChildren', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    // Should contain the bulk optimization path
    expect(output).toContain("const childNeedsMangling = UNIQUE_STRATEGY === 'mangle'");
    expect(output).toContain('childDelegate.updateMany');
  });

  it('emits bulk updateMany optimization in softDeleteWithCascadeInTx', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).toContain("const needsMangling = UNIQUE_STRATEGY === 'mangle'");
  });

  it('emits bulk updateMany optimization in restoreCascadeChildren', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).toContain("const childNeedsUnmangling = UNIQUE_STRATEGY === 'mangle'");
  });
});

describe('emitRuntime - upsert filter injection', () => {
  it('mangle upsert calls injectFilters', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    expect(output).toContain("upsert: ((args: any) => original.upsert(injectFilters(args, 'User')))");
  });

  it('none upsert calls injectFilters', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'none', cascadeGraph });

    expect(output).toContain("upsert: ((args: any) => original.upsert(injectFilters(args, 'User')))");
  });

  it('transaction wrapper upsert calls injectFilters for mangle', () => {
    const schema = createTestSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'mangle', cascadeGraph });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    expect(txWrapper![0]).toContain("upsert: ((args: any) => tx.user.upsert(injectFilters(args, 'User')))");
  });

  it('transaction wrapper sentinel upsert applies transformSentinelFindUniqueWhere', () => {
    const schema = createSentinelSchema();
    const cascadeGraph = buildCascadeGraph(schema);
    const output = emitRuntime(schema, TEST_CLIENT_PATH, { uniqueStrategy: 'sentinel', cascadeGraph });

    const txWrapper = /function wrapTransactionClient[\s\S]*?^}/m.exec(output);
    expect(txWrapper).not.toBeNull();
    const txContent = txWrapper![0];
    // Sentinel tx upsert should call injectFilters, inject sentinel value, and transform where
    expect(txContent).toContain('ACTIVE_DELETED_AT_VALUE');
    expect(txContent).toContain('transformSentinelFindUniqueWhere(filtered.where');
    expect(txContent).toContain('return tx.user.upsert(filtered)');
  });
});

describe('emitIndex', () => {
  it('generates index with all exports', () => {
    const schema = createTestSchema();
    const output = emitIndex(schema);

    expect(output).toContain("export type { SafePrismaClient");
    expect(output).toContain("CascadeResult");
    expect(output).toContain("export type { SafeUserDelegate }");
    expect(output).toContain("export type { SafePostDelegate }");
    expect(output).toContain("export { CASCADE_GRAPH, MODEL_NAMES }");
    expect(output).toContain("export { wrapPrismaClient }");
    expect(output).toContain("export { onlyDeleted, excludeDeleted, includingDeleted }");
  });
});
