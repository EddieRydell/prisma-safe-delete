generator client {
  provider = "prisma-client"
  output   = "./generated/client"
}

generator softCascade {
  provider = "node ../../dist/bin.js"
  output   = "./generated/soft-cascade"
}

datasource db {
  provider = "postgresql"
}

model User {
  id         String    @id @default(cuid())
  email      String    @unique
  name       String?
  deleted_at DateTime?
  posts      Post[]
  profile    Profile?
  createdAt  DateTime  @default(now())
}

model Profile {
  id         String    @id @default(cuid())
  bio        String?
  userId     String    @unique
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  deleted_at DateTime?
}

model Post {
  id         String    @id @default(cuid())
  title      String
  content    String?
  authorId   String
  author     User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments   Comment[]
  deleted_at DateTime?
  createdAt  DateTime  @default(now())
}

model Comment {
  id         String    @id @default(cuid())
  content    String
  postId     String
  post       Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  deleted_at DateTime?
  createdAt  DateTime  @default(now())
}

// Model without soft-delete for testing non-soft-deletable behavior
model AuditLog {
  id        String   @id @default(cuid())
  action    String
  entityId  String
  createdAt DateTime @default(now())
}

// Compound key models for testing compound PK/FK support
model TenantUser {
  tenantId   String
  userId     String
  email      String
  deleted_at DateTime?
  documents  TenantDocument[]

  @@id([tenantId, userId])
}

model TenantDocument {
  id         String     @id @default(cuid())
  tenantId   String
  userId     String
  title      String
  deleted_at DateTime?
  owner      TenantUser @relation(fields: [tenantId, userId], references: [tenantId, userId], onDelete: Cascade)
}

// camelCase deletedAt models for testing alternative field naming
model Article {
  id        String       @id @default(cuid())
  title     String
  deletedAt DateTime?
  tags      ArticleTag[]
}

model ArticleTag {
  id        String   @id @default(cuid())
  name      String
  articleId String
  article   Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  deletedAt DateTime?
}

// Self-referential model for testing recursive structures
model Category {
  id         String     @id @default(cuid())
  name       String
  parentId   String?
  parent     Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children   Category[] @relation("CategoryHierarchy")
  products   Product[]
  deleted_at DateTime?
}

// For testing deep cascade (Category -> Product -> ProductVariant -> VariantOption)
model Product {
  id         String           @id @default(cuid())
  name       String
  categoryId String
  category   Category         @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  variants   ProductVariant[]
  deleted_at DateTime?
}

model ProductVariant {
  id         String          @id @default(cuid())
  sku        String
  productId  String
  product    Product         @relation(fields: [productId], references: [id], onDelete: Cascade)
  options    VariantOption[]
  deleted_at DateTime?
}

model VariantOption {
  id        String         @id @default(cuid())
  name      String
  value     String
  variantId String
  variant   ProductVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)
  deleted_at DateTime?
}

// For testing wide cascade (Organization has many different child types)
model Organization {
  id         String       @id @default(cuid())
  name       String
  teams      Team[]
  projects   Project[]
  assets     Asset[]
  deleted_at DateTime?
}

model Team {
  id             String       @id @default(cuid())
  name           String
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  deleted_at     DateTime?
}

model Project {
  id             String       @id @default(cuid())
  name           String
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  deleted_at     DateTime?
}

// Non-soft-deletable child in cascade path
model Asset {
  id             String         @id @default(cuid())
  url            String
  organizationId String
  organization   Organization   @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  comments       AssetComment[]
  // Note: No deleted_at - this is intentionally not soft-deletable
}

// Soft-deletable grandchild through non-soft-deletable intermediary (Asset)
// Creates chain: Organization(soft) -> Asset(non-soft) -> AssetComment(soft)
model AssetComment {
  id         String    @id @default(cuid())
  content    String
  assetId    String
  asset      Asset     @relation(fields: [assetId], references: [id], onDelete: Cascade)
  deleted_at DateTime?
}

// Model with unique string constraint for testing mangling
model Customer {
  id         String    @id @default(cuid())
  email      String    @unique
  username   String    @unique
  name       String?
  orders     Order[]
  deleted_at DateTime?
  deleted_by String?
}

model Order {
  id          String    @id @default(cuid())
  orderNumber String    @unique
  customerId  String
  customer    Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  deleted_at  DateTime?
  deleted_by  String?
}

// Model with compound unique constraint
model Workspace {
  id         String    @id @default(cuid())
  orgSlug    String
  slug       String
  name       String
  deleted_at DateTime?

  @@unique([orgSlug, slug])
}
