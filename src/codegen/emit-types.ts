import type { ParsedModel, ParsedSchema } from '../dmmf-parser.js';

/**
 * Generates the SafePrismaClient type definitions
 * @param schema - The parsed Prisma schema
 * @param clientImportPath - The relative import path to the generated Prisma client (e.g., '../client')
 */
export function emitTypes(schema: ParsedSchema, clientImportPath: string): string {
  const lines: string[] = [];

  lines.push('/* eslint-disable */');
  lines.push('// @ts-nocheck');
  lines.push('// Auto-generated by prisma-safe-delete');
  lines.push('// Do not edit this file manually');
  lines.push('');
  lines.push(`import type { PrismaClient, Prisma } from '${clientImportPath}';`);
  lines.push('');

  // Emit CascadeResult type
  lines.push('/** Result of cascade operations: maps model names to the number of affected records */');
  lines.push('export type CascadeResult = Record<string, number>;');
  lines.push('');

  // Generate model-specific types
  for (const model of schema.models) {
    lines.push(...emitModelTypes(model));
    lines.push('');
  }

  // Generate the main SafePrismaClient type
  lines.push(...emitSafePrismaClientType(schema));

  return lines.join('\n');
}

/** Type for read-only operations on a delegate (for includingDeleted) */
function emitIncludingDeletedDelegateType(name: string, lowerName: string): string[] {
  return [
    `/** Read-only delegate for ${name} that includes soft-deleted records */`,
    `export type IncludingDeleted${name}Delegate = Pick<`,
    `  PrismaClient['${lowerName}'],`,
    `  'findMany' | 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'count' | 'aggregate' | 'groupBy'`,
    `>;`,
  ];
}

function emitModelTypes(model: ParsedModel): string[] {
  const lines: string[] = [];
  const name = model.name;
  const lowerName = toLowerFirst(name);

  if (model.isSoftDeletable) {
    // deletedBy is required if model has deleted_by field, optional otherwise.
    // NOTE: This is COMPILE-TIME enforcement only via TypeScript. No runtime validation.
    // Plain JavaScript callers must ensure they pass deletedBy appropriately.
    const deletedByType = model.deletedByField !== null ? '{ deletedBy: string }' : '{ deletedBy?: string }';

    // Emit includingDeleted delegate type first
    lines.push(...emitIncludingDeletedDelegateType(name, lowerName));
    lines.push('');

    // Soft-deletable model gets modified delegate type
    lines.push(`/** Soft-delete enabled delegate for ${name} */`);
    lines.push(`export type Safe${name}Delegate = Omit<`);
    lines.push(`  PrismaClient['${lowerName}'],`);
    lines.push(`  'delete' | 'deleteMany'`);
    lines.push(`> & {`);
    lines.push(`  /** Soft delete a single ${name} record with cascade */`);
    lines.push(`  softDelete: (args: Prisma.${name}DeleteArgs & ${deletedByType}) => Promise<{ record: Prisma.${name}GetPayload<{}>; cascaded: CascadeResult }>;`);
    lines.push(`  /** Soft delete multiple ${name} records with cascade */`);
    lines.push(`  softDeleteMany: (args: Prisma.${name}DeleteManyArgs & ${deletedByType}) => Promise<{ count: number; cascaded: CascadeResult }>;`);
    lines.push(`  /** Restore a soft-deleted ${name} record (unmangles unique fields) */`);
    lines.push(`  restore: (args: Prisma.${name}DeleteArgs) => Promise<Prisma.${name}GetPayload<{}> | null>;`);
    lines.push(`  /** Restore multiple soft-deleted ${name} records */`);
    lines.push(`  restoreMany: (args: Prisma.${name}DeleteManyArgs) => Promise<Prisma.BatchPayload>;`);
    lines.push(`  /** Restore a soft-deleted ${name} record AND all cascade-deleted children (matched by deleted_at timestamp) */`);
    lines.push(`  restoreCascade: (args: Prisma.${name}DeleteArgs) => Promise<{ record: Prisma.${name}GetPayload<{}> | null; cascaded: CascadeResult }>;`);
    lines.push(`  /** Hard delete a single ${name} record (PERMANENT - bypasses soft delete) */`);
    lines.push(`  __dangerousHardDelete: (args: Prisma.${name}DeleteArgs) => Promise<Prisma.${name}GetPayload<{}>>;`);
    lines.push(`  /** Hard delete multiple ${name} records (PERMANENT - bypasses soft delete) */`);
    lines.push(`  __dangerousHardDeleteMany: (args: Prisma.${name}DeleteManyArgs) => Promise<Prisma.BatchPayload>;`);
    lines.push(`  /** Query including soft-deleted records */`);
    lines.push(`  includingDeleted: IncludingDeleted${name}Delegate;`);
    lines.push(`};`);
  } else {
    // Non-soft-deletable model keeps original type
    lines.push(`/** Standard delegate for ${name} (no soft-delete) */`);
    lines.push(`export type Safe${name}Delegate = PrismaClient['${lowerName}'];`);
  }

  return lines;
}

function emitSafePrismaClientType(schema: ParsedSchema): string[] {
  const lines: string[] = [];

  // First emit the SafeTransactionClient type for typed transactions
  lines.push('/** Type-safe transaction client with soft-delete support */');
  lines.push('export interface SafeTransactionClient {');
  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    if (model.isSoftDeletable) {
      lines.push(`  ${lowerName}: Safe${model.name}Delegate;`);
    } else {
      lines.push(`  ${lowerName}: PrismaClient['${lowerName}'];`);
    }
  }
  lines.push('}');
  lines.push('');

  lines.push('/** Type-safe Prisma client with soft-delete support */');
  lines.push('export interface SafePrismaClient {');

  // Add model delegates
  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    lines.push(`  ${lowerName}: Safe${model.name}Delegate;`);
  }

  lines.push('');
  lines.push('  // Prisma client methods');
  lines.push("  $connect: PrismaClient['$connect'];");
  lines.push("  $disconnect: PrismaClient['$disconnect'];");
  lines.push("  $on: PrismaClient['$on'];");
  // Typed $transaction with SafeTransactionClient
  lines.push('  /** Execute operations in a transaction with full soft-delete support */');
  lines.push('  $transaction: {');
  lines.push('    <R>(fn: (tx: SafeTransactionClient) => Promise<R>, options?: { maxWait?: number; timeout?: number; isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>;');
  lines.push('    <P extends Prisma.PrismaPromise<unknown>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<Prisma.runtime.Types.Utils.UnwrapTuple<P>>;');
  lines.push('  };');
  lines.push("  $use: PrismaClient['$use'];");
  lines.push("  $extends: PrismaClient['$extends'];");
  lines.push("  $queryRaw: PrismaClient['$queryRaw'];");
  lines.push("  $executeRaw: PrismaClient['$executeRaw'];");
  lines.push("  $queryRawUnsafe: PrismaClient['$queryRawUnsafe'];");
  lines.push("  $executeRawUnsafe: PrismaClient['$executeRawUnsafe'];");
  lines.push('');
  lines.push('  /** Access to underlying Prisma client for escape hatches */');
  lines.push('  $prisma: PrismaClient;');
  lines.push('');
  lines.push('  /** @deprecated Use model.includingDeleted instead (e.g., safePrisma.user.includingDeleted.findMany()) */');
  lines.push('  $includingDeleted: IncludingDeletedClient;');
  lines.push('');
  lines.push('  /** Query only soft-deleted records */');
  lines.push('  $onlyDeleted: OnlyDeletedClient;');
  lines.push('}');
  lines.push('');

  // Generate IncludingDeletedClient type (kept for backward compatibility)
  lines.push('/** @deprecated Use model.includingDeleted instead */');
  lines.push('export interface IncludingDeletedClient {');
  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    lines.push(`  ${lowerName}: PrismaClient['${lowerName}'];`);
  }
  lines.push('}');
  lines.push('');

  // Generate OnlyDeletedClient type
  lines.push('/** Client that queries only soft-deleted records */');
  lines.push('export interface OnlyDeletedClient {');
  for (const model of schema.models) {
    if (model.isSoftDeletable) {
      const lowerName = toLowerFirst(model.name);
      lines.push(`  ${lowerName}: Pick<PrismaClient['${lowerName}'], 'findMany' | 'findFirst' | 'findUnique' | 'count'>;`);
    }
  }
  lines.push('}');

  return lines;
}

function toLowerFirst(str: string): string {
  const first = str.charAt(0);
  return first.toLowerCase() + str.slice(1);
}
