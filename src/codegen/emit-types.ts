import type { ParsedModel, ParsedSchema } from '../dmmf-parser.js';
import { resolveAuditTableConfig, prismaTypeToTsType } from './emit-audit.js';

/**
 * Generates the SafePrismaClient type definitions
 * @param schema - The parsed Prisma schema
 * @param clientImportPath - The relative import path to the generated Prisma client (e.g., '../client')
 */
export function emitTypes(schema: ParsedSchema, clientImportPath: string): string {
  const lines: string[] = [];

  lines.push('/* eslint-disable */');
  lines.push('// @ts-nocheck');
  lines.push('// Auto-generated by prisma-safe-delete');
  lines.push('// Do not edit this file manually');
  lines.push('');
  lines.push(`import type { PrismaClient, Prisma } from '${clientImportPath}';`);
  lines.push('');

  // Emit CascadeResult type
  lines.push('/** Result of cascade operations: maps model names to the number of affected records */');
  lines.push('export type CascadeResult = Record<string, number>;');
  lines.push('');

  // Emit AuditContext type if there are auditable models
  const hasAuditableModels = schema.models.some((m) => m.isAuditable);
  if (hasAuditableModels) {
    const auditConfig = resolveAuditTableConfig(schema);
    if (auditConfig !== null && auditConfig.extraColumns.length > 0) {
      lines.push('/** Typed context for audit events, derived from extra columns on the audit table */');
      lines.push('export interface AuditContext {');
      for (const col of auditConfig.extraColumns) {
        const tsType = prismaTypeToTsType(col.prismaType);
        // All fields are optional in AuditContext (even required columns) since the global callback can provide defaults
        lines.push(`  ${col.name}?: ${tsType} | null;`);
      }
      lines.push('}');
    } else {
      lines.push('/** Context for audit events */');
      lines.push('export type AuditContext = Record<string, unknown>;');
    }
    lines.push('');
  }

  // Generate model-specific types
  for (const model of schema.models) {
    lines.push(...emitModelTypes(model));
    lines.push('');
  }

  // Generate the main SafePrismaClient type
  lines.push(...emitSafePrismaClientType(schema));

  return lines.join('\n');
}

/** Type for read-only operations on a delegate (for includingDeleted) */
function emitIncludingDeletedDelegateType(name: string, lowerName: string): string[] {
  return [
    `/** Read-only delegate for ${name} that includes soft-deleted records */`,
    `export type IncludingDeleted${name}Delegate = Pick<`,
    `  PrismaClient['${lowerName}'],`,
    `  'findMany' | 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'count' | 'aggregate' | 'groupBy'`,
    `>;`,
  ];
}

function emitModelTypes(model: ParsedModel): string[] {
  const lines: string[] = [];
  const name = model.name;
  const lowerName = toLowerFirst(name);

  if (model.isSoftDeletable) {
    // For audited models, actorId replaces deletedBy
    // For non-audited models, deletedBy stays as-is
    let softDeleteIdentityType: string;
    if (model.isAuditable) {
      softDeleteIdentityType = '{ actorId?: string | null; auditContext?: AuditContext }';
    } else {
      softDeleteIdentityType = model.deletedByField !== null ? '{ deletedBy: string }' : '{ deletedBy?: string }';
    }

    // Emit includingDeleted delegate type first
    lines.push(...emitIncludingDeletedDelegateType(name, lowerName));
    lines.push('');

    // Determine which write methods to omit from the base Prisma type for re-typing
    const omittedMethods = ['delete', 'deleteMany'];
    if (model.isAuditable) {
      omittedMethods.push('create', 'createMany', 'createManyAndReturn', 'update', 'updateMany', 'updateManyAndReturn', 'upsert');
    }
    const omitStr = omittedMethods.map((m) => `'${m}'`).join(' | ');

    // Soft-deletable model gets modified delegate type
    lines.push(`/** Soft-delete enabled delegate for ${name} */`);
    lines.push(`export type Safe${name}Delegate = Omit<`);
    lines.push(`  PrismaClient['${lowerName}'],`);
    lines.push(`  ${omitStr}`);
    lines.push(`> & {`);

    // If audited, re-type write methods with actorId + auditContext
    if (model.isAuditable) {
      emitAuditedMutationTypes(lines, name, '{ actorId?: string | null; auditContext?: AuditContext }');
    }

    lines.push(`  /** Soft delete a single ${name} record with cascade */`);
    lines.push(`  softDelete: <T extends Prisma.${name}DeleteArgs>(args: T & ${softDeleteIdentityType}) => Promise<{ record: Prisma.${name}GetPayload<T>; cascaded: CascadeResult }>;`);
    lines.push(`  /** Soft delete multiple ${name} records with cascade */`);
    lines.push(`  softDeleteMany: (args: Prisma.${name}DeleteManyArgs & ${softDeleteIdentityType}) => Promise<{ count: number; cascaded: CascadeResult }>;`);
    lines.push(`  /** Preview what would be soft deleted (read-only, no writes) */`);
    lines.push(`  softDeletePreview: (args: Prisma.${name}DeleteManyArgs) => Promise<{ wouldDelete: CascadeResult }>;`);
    lines.push(`  /** Restore a soft-deleted ${name} record (unmangles unique fields) */`);
    if (model.isAuditable) {
      lines.push(`  restore: <T extends Prisma.${name}DeleteArgs>(args: T & { actorId?: string | null; auditContext?: AuditContext }) => Promise<Prisma.${name}GetPayload<T> | null>;`);
    } else {
      lines.push(`  restore: <T extends Prisma.${name}DeleteArgs>(args: T) => Promise<Prisma.${name}GetPayload<T> | null>;`);
    }
    lines.push(`  /** Restore multiple soft-deleted ${name} records */`);
    if (model.isAuditable) {
      lines.push(`  restoreMany: (args: Prisma.${name}DeleteManyArgs & { actorId?: string | null; auditContext?: AuditContext }) => Promise<Prisma.BatchPayload>;`);
    } else {
      lines.push(`  restoreMany: (args: Prisma.${name}DeleteManyArgs) => Promise<Prisma.BatchPayload>;`);
    }
    lines.push(`  /** Restore a soft-deleted ${name} record AND all cascade-deleted children (matched by deleted_at timestamp) */`);
    if (model.isAuditable) {
      lines.push(`  restoreCascade: <T extends Prisma.${name}DeleteArgs>(args: T & { actorId?: string | null; auditContext?: AuditContext }) => Promise<{ record: Prisma.${name}GetPayload<T> | null; cascaded: CascadeResult }>;`);
    } else {
      lines.push(`  restoreCascade: <T extends Prisma.${name}DeleteArgs>(args: T) => Promise<{ record: Prisma.${name}GetPayload<T> | null; cascaded: CascadeResult }>;`);
    }
    lines.push(`  /** Hard delete a single ${name} record (PERMANENT - bypasses soft delete) */`);
    if (model.isAuditable) {
      lines.push(`  __dangerousHardDelete: <T extends Prisma.${name}DeleteArgs>(args: T & { actorId?: string | null; auditContext?: AuditContext }) => Promise<Prisma.${name}GetPayload<T>>;`);
      lines.push(`  /** Hard delete multiple ${name} records (PERMANENT - bypasses soft delete) */`);
      lines.push(`  __dangerousHardDeleteMany: (args: Prisma.${name}DeleteManyArgs & { actorId?: string | null; auditContext?: AuditContext }) => Promise<Prisma.BatchPayload>;`);
    } else {
      lines.push(`  __dangerousHardDelete: PrismaClient['${lowerName}']['delete'];`);
      lines.push(`  /** Hard delete multiple ${name} records (PERMANENT - bypasses soft delete) */`);
      lines.push(`  __dangerousHardDeleteMany: (args: Prisma.${name}DeleteManyArgs) => Promise<Prisma.BatchPayload>;`);
    }
    lines.push(`  /** Query including soft-deleted records */`);
    lines.push(`  includingDeleted: IncludingDeleted${name}Delegate;`);
    lines.push(`};`);
  } else if (model.isAuditable) {
    // Audited but NOT soft-deletable: intercept delete/deleteMany + add actorId to mutations
    const actorIdParam = '{ actorId?: string | null; auditContext?: AuditContext }';
    const omittedMethods = ['create', 'createMany', 'createManyAndReturn', 'update', 'updateMany', 'updateManyAndReturn', 'upsert', 'delete', 'deleteMany'];
    const omitStr = omittedMethods.map((m) => `'${m}'`).join(' | ');

    lines.push(`/** Audit-enabled delegate for ${name} */`);
    lines.push(`export type Safe${name}Delegate = Omit<`);
    lines.push(`  PrismaClient['${lowerName}'],`);
    lines.push(`  ${omitStr}`);
    lines.push(`> & {`);
    emitAuditedMutationTypes(lines, name, actorIdParam);
    lines.push(`  /** Delete a single ${name} record (audited) */`);
    lines.push(`  delete: <T extends Prisma.${name}DeleteArgs>(args: T & ${actorIdParam}) => Promise<Prisma.${name}GetPayload<T>>;`);
    lines.push(`  /** Delete multiple ${name} records (audited) */`);
    lines.push(`  deleteMany: (args: Prisma.${name}DeleteManyArgs & ${actorIdParam}) => Promise<Prisma.BatchPayload>;`);
    lines.push(`};`);
  } else {
    // Non-soft-deletable, non-auditable model keeps original type
    lines.push(`/** Standard delegate for ${name} (no soft-delete) */`);
    lines.push(`export type Safe${name}Delegate = PrismaClient['${lowerName}'];`);
  }

  return lines;
}

/** Emits the 7 audited mutation type signatures shared by soft-deletable+audited and audit-only models. */
function emitAuditedMutationTypes(lines: string[], name: string, actorIdParam: string): void {
  lines.push(`  /** Create a ${name} record (audited) */`);
  lines.push(`  create: <T extends Prisma.${name}CreateArgs>(args: T & ${actorIdParam}) => Promise<Prisma.${name}GetPayload<T>>;`);
  lines.push(`  /** Create multiple ${name} records (audited) */`);
  lines.push(`  createMany: (args: Prisma.${name}CreateManyArgs & ${actorIdParam}) => Promise<Prisma.BatchPayload>;`);
  lines.push(`  /** Create multiple ${name} records and return them (audited) */`);
  lines.push(`  createManyAndReturn: <T extends Prisma.${name}CreateManyAndReturnArgs>(args: T & ${actorIdParam}) => Promise<Prisma.${name}GetPayload<T>[]>;`);
  lines.push(`  /** Update a ${name} record (audited) */`);
  lines.push(`  update: <T extends Prisma.${name}UpdateArgs>(args: T & ${actorIdParam}) => Promise<Prisma.${name}GetPayload<T>>;`);
  lines.push(`  /** Update multiple ${name} records (audited) */`);
  lines.push(`  updateMany: (args: Prisma.${name}UpdateManyArgs & ${actorIdParam}) => Promise<Prisma.BatchPayload>;`);
  lines.push(`  /** Update multiple ${name} records and return them (audited) */`);
  lines.push(`  updateManyAndReturn: <T extends Prisma.${name}UpdateManyAndReturnArgs>(args: T & ${actorIdParam}) => Promise<Prisma.${name}GetPayload<T>[]>;`);
  lines.push(`  /** Upsert a ${name} record (audited - determines create vs update at runtime) */`);
  lines.push(`  upsert: <T extends Prisma.${name}UpsertArgs>(args: T & ${actorIdParam}) => Promise<Prisma.${name}GetPayload<T>>;`);
}

function emitSafePrismaClientType(schema: ParsedSchema): string[] {
  const lines: string[] = [];

  // Emit WrapOptions type if there are auditable models
  const hasAuditableModelsForWrap = schema.models.some((m) => m.isAuditable);
  if (hasAuditableModelsForWrap) {
    lines.push('/** Options for configuring the wrapped Prisma client */');
    lines.push('export interface WrapOptions {');
    lines.push('  /** Provide additional context fields for audit events (global, per-call overrides take precedence) */');
    lines.push('  auditContext?: () => AuditContext | Promise<AuditContext>;');
    lines.push('}');
    lines.push('');
  }

  // First emit the SafeTransactionClient type for typed transactions
  lines.push('/** Type-safe transaction client with soft-delete support */');
  lines.push('export interface SafeTransactionClient {');
  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    if (model.isSoftDeletable || model.isAuditable) {
      lines.push(`  ${lowerName}: Safe${model.name}Delegate;`);
    } else {
      lines.push(`  ${lowerName}: PrismaClient['${lowerName}'];`);
    }
  }
  lines.push('');
  lines.push('  /** Query only soft-deleted records with filter propagation */');
  lines.push('  $onlyDeleted: OnlyDeletedClient;');
  lines.push('');
  lines.push('  /** Query including soft-deleted records with filter propagation */');
  lines.push('  $includingDeleted: IncludingDeletedClient;');
  lines.push('');
  lines.push('  // Raw query methods');
  lines.push("  $queryRaw: PrismaClient['$queryRaw'];");
  lines.push("  $executeRaw: PrismaClient['$executeRaw'];");
  lines.push("  $queryRawUnsafe: PrismaClient['$queryRawUnsafe'];");
  lines.push("  $executeRawUnsafe: PrismaClient['$executeRawUnsafe'];");
  lines.push('}');
  lines.push('');

  lines.push('/** Type-safe Prisma client with soft-delete support */');
  lines.push('export interface SafePrismaClient {');

  // Add model delegates
  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    lines.push(`  ${lowerName}: Safe${model.name}Delegate;`);
  }

  lines.push('');
  lines.push('  // Prisma client methods');
  lines.push("  $connect: PrismaClient['$connect'];");
  lines.push("  $disconnect: PrismaClient['$disconnect'];");
  lines.push("  $on: PrismaClient['$on'];");
  // Typed $transaction with SafeTransactionClient
  lines.push('  /** Execute operations in a transaction with full soft-delete support */');
  lines.push('  $transaction: {');
  lines.push('    <R>(fn: (tx: SafeTransactionClient) => Promise<R>, options?: { maxWait?: number; timeout?: number; isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>;');
  lines.push('    <P extends Prisma.PrismaPromise<unknown>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<{ -readonly [K in keyof P]: Awaited<P[K]> }>;');
  lines.push('  };');
  lines.push("  $extends: PrismaClient['$extends'];");
  lines.push("  $queryRaw: PrismaClient['$queryRaw'];");
  lines.push("  $executeRaw: PrismaClient['$executeRaw'];");
  lines.push("  $queryRawUnsafe: PrismaClient['$queryRawUnsafe'];");
  lines.push("  $executeRawUnsafe: PrismaClient['$executeRawUnsafe'];");
  lines.push('');
  lines.push('  /** Access to underlying Prisma client for escape hatches */');
  lines.push('  $prisma: PrismaClient;');
  lines.push('');
  lines.push('  /** @deprecated Use model.includingDeleted instead (e.g., safePrisma.user.includingDeleted.findMany()) */');
  lines.push('  $includingDeleted: IncludingDeletedClient;');
  lines.push('');
  lines.push('  /** Query only soft-deleted records */');
  lines.push('  $onlyDeleted: OnlyDeletedClient;');
  lines.push('}');
  lines.push('');

  // Generate IncludingDeletedClient type
  lines.push('/** Client that includes soft-deleted records with filter propagation */');
  lines.push('export interface IncludingDeletedClient {');
  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    if (model.isSoftDeletable) {
      lines.push(`  ${lowerName}: Pick<PrismaClient['${lowerName}'], 'findMany' | 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'count' | 'aggregate' | 'groupBy'>;`);
    } else {
      lines.push(`  ${lowerName}: PrismaClient['${lowerName}'];`);
    }
  }
  lines.push('}');
  lines.push('');

  // Generate OnlyDeletedClient type
  lines.push('/** Client that queries only soft-deleted records */');
  lines.push('export interface OnlyDeletedClient {');
  for (const model of schema.models) {
    if (model.isSoftDeletable) {
      const lowerName = toLowerFirst(model.name);
      lines.push(`  ${lowerName}: Pick<PrismaClient['${lowerName}'], 'findMany' | 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'count' | 'aggregate' | 'groupBy'>;`);
    }
  }
  lines.push('}');
  lines.push('');

  // Export helper function types
  lines.push('/**');
  lines.push(' * Helper to filter for only soft-deleted records in where clauses.');
  lines.push(' * Useful for nested relation filters where $onlyDeleted cannot be used.');
  lines.push(' */');
  lines.push('export declare function onlyDeleted<T extends Record<string, unknown>>(');
  lines.push('  modelName: string,');
  lines.push('  where?: T');
  lines.push('): T & Record<string, unknown>;');
  lines.push('');
  lines.push('/**');
  lines.push(' * Helper to filter for only non-deleted (active) records in where clauses.');
  lines.push(' * This is the default behavior, but useful for explicit overrides.');
  lines.push(' */');
  lines.push('export declare function excludeDeleted<T extends Record<string, unknown>>(');
  lines.push('  modelName: string,');
  lines.push('  where?: T');
  lines.push('): T & Record<string, unknown>;');
  lines.push('');
  lines.push('/**');
  lines.push(' * Helper to include all records (deleted + active) in where clauses.');
  lines.push(' * This is a no-op function for clarity/documentation purposes.');
  lines.push(' */');
  lines.push('export declare function includingDeleted<T extends Record<string, unknown>>(');
  lines.push('  where?: T');
  lines.push('): T;');

  return lines;
}

function toLowerFirst(str: string): string {
  const first = str.charAt(0);
  return first.toLowerCase() + str.slice(1);
}
