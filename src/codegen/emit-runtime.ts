import type { ParsedModel, ParsedSchema } from '../dmmf-parser.js';

/**
 * Generates the runtime wrapper functions
 */
export function emitRuntime(schema: ParsedSchema): string {
  const lines: string[] = [];

  lines.push('/* eslint-disable */');
  lines.push('// @ts-nocheck');
  lines.push('// Auto-generated by prisma-safe-delete');
  lines.push('// Do not edit this file manually');
  lines.push('');
  lines.push("import type { PrismaClient, Prisma } from '@prisma/client';");
  lines.push("import { CASCADE_GRAPH, type CascadeChild } from './cascade-graph.js';");
  lines.push("import type { SafePrismaClient, IncludingDeletedClient, OnlyDeletedClient } from './types.js';");
  lines.push('');

  // Emit model metadata
  lines.push('/** Metadata about soft-deletable models */');
  lines.push('const SOFT_DELETABLE_MODELS: Record<string, { deletedAtField: string }> = {');
  for (const model of schema.models) {
    if (model.isSoftDeletable && model.deletedAtField !== null) {
      lines.push(`  ${model.name}: { deletedAtField: ${JSON.stringify(model.deletedAtField)} },`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit primary key metadata
  lines.push('/** Primary key configuration per model */');
  lines.push('const PRIMARY_KEYS: Record<string, string | string[]> = {');
  for (const model of schema.models) {
    const pkValue = Array.isArray(model.primaryKey)
      ? JSON.stringify(model.primaryKey)
      : JSON.stringify(model.primaryKey);
    lines.push(`  ${model.name}: ${pkValue},`);
  }
  lines.push('};');
  lines.push('');

  // Emit relation models mapping (for proper relation target lookup)
  lines.push('/** Maps model.field to target model name */');
  lines.push('const RELATION_MODELS: Record<string, string> = {');
  for (const model of schema.models) {
    for (const relation of model.relations) {
      lines.push(`  '${model.name}.${relation.name}': '${relation.type}',`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit relation list metadata (for knowing if a relation supports where clause)
  lines.push('/** Maps model.field to whether it is a list relation */');
  lines.push('const RELATION_IS_LIST: Record<string, boolean> = {');
  for (const model of schema.models) {
    for (const relation of model.relations) {
      lines.push(`  '${model.name}.${relation.name}': ${String(relation.isList)},`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit unique string fields metadata (for mangling on soft delete)
  lines.push('/**');
  lines.push(' * String fields with unique constraints that need mangling on soft delete.');
  lines.push(' * On soft delete, these fields get "__deleted_{pk}" appended to free up the unique value.');
  lines.push(' * For compound PKs, the suffix is "__deleted_{pk1}_{pk2}" (fields joined with underscore, sorted alphabetically).');
  lines.push(' */');
  lines.push('const UNIQUE_STRING_FIELDS: Record<string, string[]> = {');
  for (const model of schema.models) {
    if (model.uniqueStringFields.length > 0) {
      lines.push(`  ${model.name}: ${JSON.stringify(model.uniqueStringFields)},`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit helper functions
  lines.push(emitHelperFunctions());
  lines.push('');

  // Emit injectFilters function
  lines.push(emitInjectFiltersFunction());
  lines.push('');

  // Emit soft delete cascade function
  lines.push(emitSoftDeleteCascadeFunction());
  lines.push('');

  // Emit model delegate wrappers
  for (const model of schema.models) {
    lines.push(emitModelDelegate(model));
    lines.push('');
  }

  // Emit includingDeleted and onlyDeleted clients
  lines.push(emitIncludingDeletedClient(schema));
  lines.push('');
  lines.push(emitOnlyDeletedClient(schema));
  lines.push('');

  // Emit transaction wrapper
  lines.push(emitTransactionWrapper(schema));
  lines.push('');

  // Emit main wrapper function
  lines.push(emitWrapperFunction(schema));

  return lines.join('\n');
}

function emitHelperFunctions(): string {
  return `
/**
 * Checks if a model is soft-deletable
 */
function isSoftDeletable(modelName: string): boolean {
  return modelName in SOFT_DELETABLE_MODELS;
}

/**
 * Gets the deleted_at field name for a model
 */
function getDeletedAtField(modelName: string): string | null {
  return SOFT_DELETABLE_MODELS[modelName]?.deletedAtField ?? null;
}

/**
 * Extracts primary key values from a record
 */
function extractPrimaryKey(modelName: string, record: Record<string, unknown>): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return {};

  const keys = Array.isArray(pk) ? pk : [pk];
  const result: Record<string, unknown> = {};

  for (const key of keys) {
    result[key] = record[key];
  }

  return result;
}

/**
 * Creates a where clause for primary key lookup
 */
function createPkWhere(modelName: string, pkValues: Record<string, unknown>): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return pkValues;

  if (Array.isArray(pk)) {
    // Compound key - use underscore-joined name
    const compoundName = pk.join('_');
    return { [compoundName]: pkValues };
  }

  return pkValues;
}

/**
 * Creates a where clause for updating a record by its primary key values.
 * For simple PKs: { id: 'value' }
 * For compound PKs: { pk1_pk2: { pk1: 'v1', pk2: 'v2' } }
 */
function createPkWhereFromValues(modelName: string, pkValues: Record<string, unknown>): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return pkValues;

  if (Array.isArray(pk)) {
    // Compound key - Prisma expects { pk1_pk2: { pk1: v1, pk2: v2 } }
    const compoundName = pk.join('_');
    return { [compoundName]: pkValues };
  }

  // Simple key - just return the values as-is
  return pkValues;
}

/**
 * Gets the target model name for a relation field
 */
function getRelationModel(parentModel: string, fieldName: string): string | null {
  return RELATION_MODELS[\`\${parentModel}.\${fieldName}\`] ?? null;
}

/**
 * Checks if a relation is a list (to-many) relation
 */
function isListRelation(parentModel: string, fieldName: string): boolean {
  return RELATION_IS_LIST[\`\${parentModel}.\${fieldName}\`] ?? false;
}

/**
 * Decomposes a compound key where clause into individual fields.
 * Converts { tenantId_userId: { tenantId: 'x', userId: 'y' } } into { tenantId: 'x', userId: 'y' }
 */
function decomposeCompoundKeyWhere(
  modelName: string,
  where: Record<string, unknown>
): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk || !Array.isArray(pk)) {
    return where;
  }

  // Check if where contains the compound key name
  const compoundKeyName = pk.join('_');
  const compoundValue = where[compoundKeyName];

  if (compoundValue && typeof compoundValue === 'object') {
    // Decompose the compound key
    const { [compoundKeyName]: _removed, ...rest } = where;
    return {
      ...rest,
      ...(compoundValue as Record<string, unknown>),
    };
  }

  return where;
}

/**
 * Builds a deterministic PK suffix for mangling unique fields.
 * For simple PKs: "__deleted_{pkValue}"
 * For compound PKs: "__deleted_{pk1Value}_{pk2Value}" (fields sorted alphabetically)
 */
function buildPkSuffix(modelName: string, record: Record<string, unknown>): string {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return '__deleted_unknown';

  const pkFields = Array.isArray(pk) ? [...pk].sort() : [pk];
  const pkValues = pkFields.map(field => String(record[field] ?? 'null'));
  return \`__deleted_\${pkValues.join('_')}\`;
}

/**
 * Gets the unique string fields for a model that need mangling on soft delete.
 */
function getUniqueStringFields(modelName: string): string[] {
  return UNIQUE_STRING_FIELDS[modelName] ?? [];
}

/**
 * Default max length for string fields (conservative estimate).
 * Most databases use 255 for varchar without explicit length.
 */
const DEFAULT_MAX_STRING_LENGTH = 255;

/**
 * Mangles unique string fields by appending the PK suffix.
 * Returns the update data object with mangled values, or throws if mangling would exceed max length.
 */
function mangleUniqueFields(
  modelName: string,
  record: Record<string, unknown>,
  maxLength: number = DEFAULT_MAX_STRING_LENGTH
): Record<string, unknown> {
  const uniqueFields = getUniqueStringFields(modelName);
  if (uniqueFields.length === 0) return {};

  const suffix = buildPkSuffix(modelName, record);
  const updates: Record<string, unknown> = {};

  for (const field of uniqueFields) {
    const currentValue = record[field];

    // Skip null/undefined values - they don't conflict with unique constraints
    if (currentValue === null || currentValue === undefined) {
      continue;
    }

    const strValue = String(currentValue);

    // Skip if already mangled (idempotent)
    if (strValue.endsWith(suffix)) {
      continue;
    }

    const mangledValue = strValue + suffix;

    // Check max length
    if (mangledValue.length > maxLength) {
      throw new Error(
        \`Cannot soft delete \${modelName}: mangling unique field "\${field}" would exceed max length \` +
        \`(\${mangledValue.length} > \${maxLength}). Original value: "\${strValue.substring(0, 50)}\${strValue.length > 50 ? '...' : ''}". \` +
        \`Consider using a partial unique index instead, or hard delete the record.\`
      );
    }

    updates[field] = mangledValue;
  }

  return updates;
}`.trim();
}

function emitInjectFiltersFunction(): string {
  return `
/**
 * Recursively injects deleted_at: null filters into query args
 */
function injectFilters<T extends Record<string, unknown>>(
  args: T | undefined,
  modelName: string
): T {
  if (!args) {
    const deletedAtField = getDeletedAtField(modelName);
    if (deletedAtField) {
      return { where: { [deletedAtField]: null } } as T;
    }
    return {} as T;
  }

  const result = { ...args };
  const deletedAtField = getDeletedAtField(modelName);

  // Inject into top-level where and process relation filters
  if (deletedAtField) {
    result.where = injectIntoWhere(
      {
        ...((result.where as Record<string, unknown>) ?? {}),
        [deletedAtField]: null,
      },
      modelName
    );
  } else if (result.where) {
    result.where = injectIntoWhere(
      result.where as Record<string, unknown>,
      modelName
    );
  }

  // Process include
  if (result.include && typeof result.include === 'object') {
    result.include = injectIntoRelations(
      result.include as Record<string, unknown>,
      modelName
    );
  }

  // Process select
  if (result.select && typeof result.select === 'object') {
    result.select = injectIntoRelations(
      result.select as Record<string, unknown>,
      modelName
    );
  }

  return result;
}

/**
 * Injects soft delete filters into where clauses, including relation filters
 */
function injectIntoWhere(
  where: Record<string, unknown>,
  parentModel: string
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(where)) {
    // Check if this is a relation filter (some, every, none, is, isNot)
    const relationModel = getRelationModel(parentModel, key);

    if (relationModel && value && typeof value === 'object') {
      const relationFilter = value as Record<string, unknown>;
      const deletedAtField = getDeletedAtField(relationModel);
      const processedFilter: Record<string, unknown> = {};

      for (const [filterKey, filterValue] of Object.entries(relationFilter)) {
        if (['some', 'every', 'none'].includes(filterKey) && filterValue && typeof filterValue === 'object') {
          // Inject deleted_at filter into the relation condition
          const innerWhere = filterValue as Record<string, unknown>;
          if (deletedAtField) {
            processedFilter[filterKey] = injectIntoWhere(
              { ...innerWhere, [deletedAtField]: null },
              relationModel
            );
          } else {
            processedFilter[filterKey] = injectIntoWhere(innerWhere, relationModel);
          }
        } else if (['is', 'isNot'].includes(filterKey) && filterValue && typeof filterValue === 'object') {
          // Handle is/isNot for single relations
          const innerWhere = filterValue as Record<string, unknown>;
          if (deletedAtField) {
            processedFilter[filterKey] = injectIntoWhere(
              { ...innerWhere, [deletedAtField]: null },
              relationModel
            );
          } else {
            processedFilter[filterKey] = injectIntoWhere(innerWhere, relationModel);
          }
        } else {
          processedFilter[filterKey] = filterValue;
        }
      }

      result[key] = processedFilter;
    } else if (key === 'AND' && Array.isArray(value)) {
      result[key] = value.map(v =>
        typeof v === 'object' && v !== null
          ? injectIntoWhere(v as Record<string, unknown>, parentModel)
          : v
      );
    } else if (key === 'OR' && Array.isArray(value)) {
      result[key] = value.map(v =>
        typeof v === 'object' && v !== null
          ? injectIntoWhere(v as Record<string, unknown>, parentModel)
          : v
      );
    } else if (key === 'NOT' && value && typeof value === 'object') {
      result[key] = Array.isArray(value)
        ? value.map(v => typeof v === 'object' && v !== null
            ? injectIntoWhere(v as Record<string, unknown>, parentModel)
            : v)
        : injectIntoWhere(value as Record<string, unknown>, parentModel);
    } else {
      result[key] = value;
    }
  }

  return result;
}

/**
 * Injects filters into relation includes/selects
 */
function injectIntoRelations(
  relations: Record<string, unknown>,
  parentModel: string
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(relations)) {
    // Handle _count specially
    if (key === '_count') {
      if (value === true) {
        // Simple _count: true - we need to add filters for all countable relations
        // This is complex because we don't know which relations are being counted
        // For now, pass through (Prisma will count all)
        result[key] = value;
      } else if (value && typeof value === 'object') {
        const countObj = value as Record<string, unknown>;
        if (countObj.select && typeof countObj.select === 'object') {
          // _count: { select: { posts: true, comments: true } }
          const countSelect = countObj.select as Record<string, unknown>;
          const filteredCountSelect: Record<string, unknown> = {};

          for (const [relName, relValue] of Object.entries(countSelect)) {
            const relationModel = getRelationModel(parentModel, relName);
            if (relationModel) {
              const deletedAtField = getDeletedAtField(relationModel);
              if (deletedAtField && relValue === true) {
                // Add where filter to count only non-deleted
                filteredCountSelect[relName] = {
                  where: { [deletedAtField]: null },
                };
              } else if (deletedAtField && relValue && typeof relValue === 'object') {
                // Merge with existing where
                const existing = relValue as Record<string, unknown>;
                filteredCountSelect[relName] = {
                  ...existing,
                  where: {
                    ...((existing.where as Record<string, unknown>) ?? {}),
                    [deletedAtField]: null,
                  },
                };
              } else {
                filteredCountSelect[relName] = relValue;
              }
            } else {
              filteredCountSelect[relName] = relValue;
            }
          }

          result[key] = { ...countObj, select: filteredCountSelect };
        } else {
          result[key] = value;
        }
      } else {
        result[key] = value;
      }
      continue;
    }

    // Look up the actual target model for this relation field
    const relationModel = getRelationModel(parentModel, key);
    const isList = isListRelation(parentModel, key);

    if (value === true) {
      // Simple include - inject filter if relation target is soft-deletable
      // Only add where clause for list relations (non-list relations don't support where in include)
      if (relationModel && isList) {
        const deletedAtField = getDeletedAtField(relationModel);
        if (deletedAtField) {
          result[key] = {
            where: { [deletedAtField]: null },
          };
        } else {
          result[key] = value;
        }
      } else {
        result[key] = value;
      }
    } else if (value && typeof value === 'object') {
      // Nested include with options
      const nested = { ...(value as Record<string, unknown>) };

      if (relationModel) {
        // Only add where clause for list relations
        if (isList) {
          const deletedAtField = getDeletedAtField(relationModel);
          if (deletedAtField) {
            nested.where = {
              ...((nested.where as Record<string, unknown>) ?? {}),
              [deletedAtField]: null,
            };
          }
        }

        // Recursively process nested includes
        if (nested.include && typeof nested.include === 'object') {
          nested.include = injectIntoRelations(
            nested.include as Record<string, unknown>,
            relationModel
          );
        }

        // Recursively process nested selects
        if (nested.select && typeof nested.select === 'object') {
          nested.select = injectIntoRelations(
            nested.select as Record<string, unknown>,
            relationModel
          );
        }
      }

      result[key] = nested;
    } else {
      result[key] = value;
    }
  }

  return result;
}`.trim();
}

function emitSoftDeleteCascadeFunction(): string {
  return `
/**
 * Performs a soft delete with cascade
 */
async function softDeleteWithCascade(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>,
  deletedBy?: string
): Promise<void> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  const now = new Date();
  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);

  await prisma.$transaction(async (tx) => {
    // Find all records to delete
    const delegate = tx[lowerModelName as keyof typeof tx] as any;
    // Decompose compound key where clause if needed
    const decomposedWhere = decomposeCompoundKeyWhere(modelName, where);
    const records = await delegate.findMany({
      where: {
        ...decomposedWhere,
        [deletedAtField]: null, // Only non-deleted records
      },
    });

    if (records.length === 0) return;

    // Get primary keys of records to delete
    const pkValues = records.map((r: Record<string, unknown>) =>
      extractPrimaryKey(modelName, r)
    );

    // Cascade to children (depth-first)
    await cascadeToChildren(tx, modelName, pkValues, now, deletedBy);

    // Update parent records - mangle unique fields first, then set deleted_at
    const pk = PRIMARY_KEYS[modelName];
    const pkField = Array.isArray(pk) ? pk.join('_') : pk;

    // For each record, we need to mangle unique fields individually
    // because each record has its own PK suffix
    for (const record of records) {
      const pkVal = extractPrimaryKey(modelName, record);
      const mangledFields = mangleUniqueFields(modelName, record);

      const updateData: Record<string, unknown> = {
        ...mangledFields,
        [deletedAtField]: now,
      };

      const deletedByField = getDeletedByField(modelName);
      if (deletedByField && deletedBy) {
        updateData[deletedByField] = deletedBy;
      }

      await delegate.update({
        where: createPkWhereFromValues(modelName, pkVal),
        data: updateData,
      });
    }
  });
}

/**
 * Gets the deleted_by field name for a model
 */
function getDeletedByField(modelName: string): string | null {
  // This would be populated from schema metadata in a full implementation
  return null;
}

/**
 * Recursively cascades soft delete to children
 */
async function cascadeToChildren(
  tx: any,
  parentModel: string,
  parentPkValues: Record<string, unknown>[],
  deletedAt: Date,
  deletedBy?: string
): Promise<void> {
  const children = CASCADE_GRAPH[parentModel] ?? [];

  for (const child of children) {
    const lowerChildModel = child.model.charAt(0).toLowerCase() + child.model.slice(1);
    const childDelegate = tx[lowerChildModel as keyof typeof tx] as any;

    // Build where clause to find children - handle compound keys
    if (child.foreignKey.length === 0 || child.parentKey.length === 0) continue;

    // Build OR conditions for each parent record (supports compound keys)
    const childWhereConditions = parentPkValues.map((pkVal) => {
      const condition: Record<string, unknown> = {};
      for (let i = 0; i < child.foreignKey.length; i++) {
        const fkField = child.foreignKey[i];
        const pkField = child.parentKey[i];
        if (fkField && pkField) {
          condition[fkField] = pkVal[pkField];
        }
      }
      return condition;
    });

    // Find child records
    const childRecords = await childDelegate.findMany({
      where: {
        OR: childWhereConditions,
        ...(child.deletedAtField ? { [child.deletedAtField]: null } : {}),
      },
    });

    if (childRecords.length === 0) continue;

    // Get child PKs for recursive cascade
    const childPkValues = childRecords.map((r: Record<string, unknown>) =>
      extractPrimaryKey(child.model, r)
    );

    // Recurse to grandchildren first (depth-first)
    await cascadeToChildren(tx, child.model, childPkValues, deletedAt, deletedBy);

    // Soft delete children (if soft-deletable)
    if (child.isSoftDeletable && child.deletedAtField) {
      // Mangle unique fields for each child individually
      for (const childRecord of childRecords) {
        const childPkVal = extractPrimaryKey(child.model, childRecord);
        const mangledFields = mangleUniqueFields(child.model, childRecord);

        await childDelegate.update({
          where: createPkWhereFromValues(child.model, childPkVal),
          data: {
            ...mangledFields,
            [child.deletedAtField]: deletedAt,
          },
        });
      }
    }
  }
}`.trim();
}

function emitModelDelegate(model: ParsedModel): string {
  const name = model.name;
  const lowerName = toLowerFirst(name);

  if (model.isSoftDeletable) {
    return `
/**
 * Creates a safe delegate for ${name} with soft-delete support
 */
function create${name}Delegate(prisma: PrismaClient): any {
  const original = prisma.${lowerName};

  return {
    // Wrapped methods with filter injection
    findMany: (args?: any) => original.findMany(injectFilters(args, '${name}')),
    findFirst: (args?: any) => original.findFirst(injectFilters(args, '${name}')),
    findFirstOrThrow: (args?: any) => original.findFirstOrThrow(injectFilters(args, '${name}')),
    findUnique: (args?: any) => original.findUnique(injectFilters(args, '${name}')),
    findUniqueOrThrow: (args?: any) => original.findUniqueOrThrow(injectFilters(args, '${name}')),
    count: (args?: any) => original.count(injectFilters(args, '${name}')),
    aggregate: (args?: any) => original.aggregate(injectFilters(args, '${name}')),
    groupBy: (args?: any) => original.groupBy(injectFilters(args, '${name}')),

    // Pass-through methods (no filter needed for writes)
    create: (args: any) => original.create(args),
    createMany: (args: any) => original.createMany(args),
    createManyAndReturn: (args: any) => original.createManyAndReturn(args),
    update: (args: any) => original.update(args),
    updateMany: (args: any) => original.updateMany(args),
    upsert: (args: any) => original.upsert(args),

    // Soft delete methods
    softDelete: async (args: any) => {
      await softDeleteWithCascade(prisma, '${name}', args.where);
      // Decompose compound key for findFirst
      const decomposedWhere = decomposeCompoundKeyWhere('${name}', args.where);
      return original.findFirst({ where: decomposedWhere });
    },
    softDeleteMany: async (args: any) => {
      const deletedAtField = getDeletedAtField('${name}');
      const pk = PRIMARY_KEYS['${name}'];
      const pkFields = Array.isArray(pk) ? pk : [pk];
      const selectClause = Object.fromEntries(pkFields.map(f => [f, true]));

      const records = await original.findMany({
        where: { ...args.where, ...(deletedAtField ? { [deletedAtField]: null } : {}) },
        select: selectClause,
      });
      await softDeleteWithCascade(prisma, '${name}', args.where);
      return { count: records.length };
    },

    // Hard delete (escape hatch)
    hardDelete: (args: any) => original.delete(args),
    hardDeleteMany: (args: any) => original.deleteMany(args),
  };
}`.trim();
  }

  return `
/**
 * Creates a delegate for ${name} (no soft-delete)
 */
function create${name}Delegate(prisma: PrismaClient): any {
  return prisma.${lowerName};
}`.trim();
}

function emitIncludingDeletedClient(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Creates a client that includes soft-deleted records');
  lines.push(' */');
  lines.push('function createIncludingDeletedClient(prisma: PrismaClient): IncludingDeletedClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    lines.push(`    ${lowerName}: prisma.${lowerName},`);
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitOnlyDeletedClient(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Creates a client that queries only soft-deleted records');
  lines.push(' */');
  lines.push('function createOnlyDeletedClient(prisma: PrismaClient): OnlyDeletedClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    if (model.isSoftDeletable && model.deletedAtField !== null) {
      const lowerName = toLowerFirst(model.name);
      lines.push(`    ${lowerName}: {`);
      lines.push(`      findMany: (args?: any) => prisma.${lowerName}.findMany({`);
      lines.push(`        ...args,`);
      lines.push(`        where: { ...args?.where, ${model.deletedAtField}: { not: null } },`);
      lines.push(`      }),`);
      lines.push(`      findFirst: (args?: any) => prisma.${lowerName}.findFirst({`);
      lines.push(`        ...args,`);
      lines.push(`        where: { ...args?.where, ${model.deletedAtField}: { not: null } },`);
      lines.push(`      }),`);
      lines.push(`      findUnique: (args?: any) => prisma.${lowerName}.findUnique({`);
      lines.push(`        ...args,`);
      lines.push(`        where: { ...args?.where, ${model.deletedAtField}: { not: null } },`);
      lines.push(`      }),`);
      lines.push(`      count: (args?: any) => prisma.${lowerName}.count({`);
      lines.push(`        ...args,`);
      lines.push(`        where: { ...args?.where, ${model.deletedAtField}: { not: null } },`);
      lines.push(`      }),`);
      lines.push(`    },`);
    }
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitTransactionWrapper(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Wraps a transaction client with soft-delete filtering');
  lines.push(' */');
  lines.push('function wrapTransactionClient(tx: any): any {');
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    if (model.isSoftDeletable) {
      lines.push(`    ${lowerName}: {`);
      lines.push(`      findMany: (args?: any) => tx.${lowerName}.findMany(injectFilters(args, '${model.name}')),`);
      lines.push(`      findFirst: (args?: any) => tx.${lowerName}.findFirst(injectFilters(args, '${model.name}')),`);
      lines.push(`      findFirstOrThrow: (args?: any) => tx.${lowerName}.findFirstOrThrow(injectFilters(args, '${model.name}')),`);
      lines.push(`      findUnique: (args?: any) => tx.${lowerName}.findUnique(injectFilters(args, '${model.name}')),`);
      lines.push(`      findUniqueOrThrow: (args?: any) => tx.${lowerName}.findUniqueOrThrow(injectFilters(args, '${model.name}')),`);
      lines.push(`      count: (args?: any) => tx.${lowerName}.count(injectFilters(args, '${model.name}')),`);
      lines.push(`      aggregate: (args?: any) => tx.${lowerName}.aggregate(injectFilters(args, '${model.name}')),`);
      lines.push(`      groupBy: (args?: any) => tx.${lowerName}.groupBy(injectFilters(args, '${model.name}')),`);
      lines.push(`      create: (args: any) => tx.${lowerName}.create(args),`);
      lines.push(`      createMany: (args: any) => tx.${lowerName}.createMany(args),`);
      lines.push(`      update: (args: any) => tx.${lowerName}.update(args),`);
      lines.push(`      updateMany: (args: any) => tx.${lowerName}.updateMany(args),`);
      lines.push(`      upsert: (args: any) => tx.${lowerName}.upsert(args),`);
      lines.push(`      delete: (args: any) => tx.${lowerName}.delete(args),`);
      lines.push(`      deleteMany: (args: any) => tx.${lowerName}.deleteMany(args),`);
      lines.push(`    },`);
    } else {
      lines.push(`    ${lowerName}: tx.${lowerName},`);
    }
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitWrapperFunction(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Wraps a PrismaClient with soft-delete functionality');
  lines.push(' */');
  lines.push('export function wrapPrismaClient(prisma: PrismaClient): SafePrismaClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    lines.push(`    ${lowerName}: create${model.name}Delegate(prisma),`);
  }

  lines.push('');
  lines.push('    $connect: () => prisma.$connect(),');
  lines.push('    $disconnect: () => prisma.$disconnect(),');
  lines.push('    $on: (...args: any[]) => (prisma.$on as any)(...args),');
  lines.push('    $transaction: (arg: any, options?: any) => {');
  lines.push('      // Handle both sequential and interactive transactions');
  lines.push('      if (typeof arg === "function") {');
  lines.push('        // Interactive transaction - wrap the callback to provide safe delegates');
  lines.push('        return prisma.$transaction((tx: any) => {');
  lines.push('          const wrappedTx = wrapTransactionClient(tx);');
  lines.push('          return arg(wrappedTx);');
  lines.push('        }, options);');
  lines.push('      }');
  lines.push('      // Sequential transaction (array of promises)');
  lines.push('      return (prisma.$transaction as any)(arg, options);');
  lines.push('    },');
  lines.push('    $use: (...args: any[]) => (prisma.$use as any)(...args),');
  lines.push('    $extends: (...args: any[]) => (prisma.$extends as any)(...args),');
  lines.push('    $queryRaw: (...args: any[]) => (prisma.$queryRaw as any)(...args),');
  lines.push('    $executeRaw: (...args: any[]) => (prisma.$executeRaw as any)(...args),');
  lines.push('    $queryRawUnsafe: (...args: any[]) => (prisma.$queryRawUnsafe as any)(...args),');
  lines.push('    $executeRawUnsafe: (...args: any[]) => (prisma.$executeRawUnsafe as any)(...args),');
  lines.push('    $prisma: prisma,');
  lines.push('    $includingDeleted: createIncludingDeletedClient(prisma),');
  lines.push('    $onlyDeleted: createOnlyDeletedClient(prisma),');
  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function toLowerFirst(str: string): string {
  const first = str.charAt(0);
  return first.toLowerCase() + str.slice(1);
}
