import type { ParsedModel, ParsedSchema } from '../dmmf-parser.js';
import type { CascadeGraph } from '../cascade-graph.js';

/**
 * Strategy for handling unique constraints on soft delete.
 */
type UniqueStrategy = 'mangle' | 'none';

interface EmitRuntimeOptions {
  uniqueStrategy: UniqueStrategy;
  cascadeGraph: CascadeGraph;
}

/**
 * Determines if a model can use the fast path (single updateMany) for soft deletes.
 * Qualifying criteria: no cascade children AND (uniqueStrategy='none' OR no unique string fields).
 */
function isSimpleModel(model: ParsedModel, options: EmitRuntimeOptions): boolean {
  const children = options.cascadeGraph[model.name] ?? [];
  if (children.length > 0) return false;
  if (options.uniqueStrategy === 'none') return true;
  return model.uniqueStringFields.length === 0;
}

/**
 * Generates the runtime wrapper functions
 * @param schema - The parsed Prisma schema
 * @param clientImportPath - The relative import path to the generated Prisma client (e.g., '../client')
 * @param options - Configuration options
 */
export function emitRuntime(
  schema: ParsedSchema,
  clientImportPath: string,
  options: EmitRuntimeOptions = { uniqueStrategy: 'mangle', cascadeGraph: {} },
): string {
  const lines: string[] = [];

  lines.push('/* eslint-disable */');
  lines.push('// @ts-nocheck');
  lines.push('// Auto-generated by prisma-safe-delete');
  lines.push('// Do not edit this file manually');
  lines.push('');
  lines.push(`import type { PrismaClient, Prisma } from '${clientImportPath}';`);
  lines.push("import { CASCADE_GRAPH, type CascadeChild } from './cascade-graph.js';");
  lines.push("import type { SafePrismaClient, IncludingDeletedClient, OnlyDeletedClient } from './types.js';");
  lines.push('');

  // Emit model metadata
  lines.push('/** Metadata about soft-deletable models */');
  lines.push('const SOFT_DELETABLE_MODELS: Record<string, { deletedAtField: string }> = {');
  for (const model of schema.models) {
    if (model.isSoftDeletable && model.deletedAtField !== null) {
      lines.push(`  ${model.name}: { deletedAtField: ${JSON.stringify(model.deletedAtField)} },`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit deleted_by metadata
  lines.push('/** Metadata about models with deleted_by fields */');
  lines.push('const DELETED_BY_MODELS: Record<string, { deletedByField: string }> = {');
  for (const model of schema.models) {
    if (model.deletedByField !== null) {
      lines.push(`  ${model.name}: { deletedByField: ${JSON.stringify(model.deletedByField)} },`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit primary key metadata
  lines.push('/** Primary key configuration per model */');
  lines.push('const PRIMARY_KEYS: Record<string, string | string[]> = {');
  for (const model of schema.models) {
    const pkValue = Array.isArray(model.primaryKey)
      ? JSON.stringify(model.primaryKey)
      : JSON.stringify(model.primaryKey);
    lines.push(`  ${model.name}: ${pkValue},`);
  }
  lines.push('};');
  lines.push('');

  // Emit relation models mapping (for proper relation target lookup)
  lines.push('/** Maps model.field to target model name */');
  lines.push('const RELATION_MODELS: Record<string, string> = {');
  for (const model of schema.models) {
    for (const relation of model.relations) {
      lines.push(`  '${model.name}.${relation.name}': '${relation.type}',`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit relation list metadata (for knowing if a relation supports where clause)
  lines.push('/** Maps model.field to whether it is a list relation */');
  lines.push('const RELATION_IS_LIST: Record<string, boolean> = {');
  for (const model of schema.models) {
    for (const relation of model.relations) {
      lines.push(`  '${model.name}.${relation.name}': ${String(relation.isList)},`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit unique string fields metadata (for mangling on soft delete)
  lines.push('/**');
  lines.push(' * String fields with unique constraints that need mangling on soft delete.');
  lines.push(' * On soft delete, these fields get "__deleted_{pk}" appended to free up the unique value.');
  lines.push(' * For compound PKs, the suffix is "__deleted_{pk1}_{pk2}" (fields joined with underscore, sorted alphabetically).');
  lines.push(' */');
  lines.push('const UNIQUE_STRING_FIELDS: Record<string, string[]> = {');
  for (const model of schema.models) {
    if (model.uniqueStringFields.length > 0) {
      lines.push(`  ${model.name}: ${JSON.stringify(model.uniqueStringFields)},`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit unique strategy constant
  lines.push('/**');
  lines.push(' * Strategy for handling unique constraints on soft delete.');
  lines.push(" * - 'mangle': Append \"__deleted_{pk}\" suffix to unique string fields");
  lines.push(" * - 'none': Skip mangling (user handles uniqueness via partial indexes)");
  lines.push(' */');
  lines.push(`const UNIQUE_STRATEGY: 'mangle' | 'none' = '${options.uniqueStrategy}';`);
  lines.push('');

  // Emit helper functions
  lines.push(emitHelperFunctions());
  lines.push('');

  // Emit injectFilters function
  lines.push(emitInjectFiltersFunction());
  lines.push('');

  // Emit soft delete cascade function
  lines.push(emitSoftDeleteCascadeFunction());
  lines.push('');

  // Emit model delegate wrappers
  for (const model of schema.models) {
    lines.push(emitModelDelegate(model, options));
    lines.push('');
  }

  // Emit includingDeleted and onlyDeleted clients
  lines.push(emitIncludingDeletedClient(schema));
  lines.push('');
  lines.push(emitOnlyDeletedClient(schema));
  lines.push('');

  // Emit transaction wrapper
  lines.push(emitTransactionWrapper(schema, options));
  lines.push('');

  // Emit main wrapper function
  lines.push(emitWrapperFunction(schema));

  return lines.join('\n');
}

function emitHelperFunctions(): string {
  return `
/**
 * Checks if a model is soft-deletable
 */
function isSoftDeletable(modelName: string): boolean {
  return modelName in SOFT_DELETABLE_MODELS;
}

/**
 * Gets the deleted_at field name for a model
 */
function getDeletedAtField(modelName: string): string | null {
  return SOFT_DELETABLE_MODELS[modelName]?.deletedAtField ?? null;
}

/**
 * Extracts primary key values from a record
 */
function extractPrimaryKey(modelName: string, record: Record<string, unknown>): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return {};

  const keys = Array.isArray(pk) ? pk : [pk];
  const result: Record<string, unknown> = {};

  for (const key of keys) {
    result[key] = record[key];
  }

  return result;
}

/**
 * Creates a where clause for primary key lookup
 */
function createPkWhere(modelName: string, pkValues: Record<string, unknown>): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return pkValues;

  if (Array.isArray(pk)) {
    // Compound key - use underscore-joined name
    const compoundName = pk.join('_');
    return { [compoundName]: pkValues };
  }

  return pkValues;
}

/**
 * Creates a where clause for updating a record by its primary key values.
 * For simple PKs: { id: 'value' }
 * For compound PKs: { pk1_pk2: { pk1: 'v1', pk2: 'v2' } }
 */
function createPkWhereFromValues(modelName: string, pkValues: Record<string, unknown>): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return pkValues;

  if (Array.isArray(pk)) {
    // Compound key - Prisma expects { pk1_pk2: { pk1: v1, pk2: v2 } }
    const compoundName = pk.join('_');
    return { [compoundName]: pkValues };
  }

  // Simple key - just return the values as-is
  return pkValues;
}

/**
 * Gets the target model name for a relation field
 */
function getRelationModel(parentModel: string, fieldName: string): string | null {
  return RELATION_MODELS[\`\${parentModel}.\${fieldName}\`] ?? null;
}

/**
 * Checks if a relation is a list (to-many) relation
 */
function isListRelation(parentModel: string, fieldName: string): boolean {
  return RELATION_IS_LIST[\`\${parentModel}.\${fieldName}\`] ?? false;
}

/**
 * Decomposes a compound key where clause into individual fields.
 * Converts { tenantId_userId: { tenantId: 'x', userId: 'y' } } into { tenantId: 'x', userId: 'y' }
 */
function decomposeCompoundKeyWhere(
  modelName: string,
  where: Record<string, unknown>
): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk || !Array.isArray(pk)) {
    return where;
  }

  // Check if where contains the compound key name
  const compoundKeyName = pk.join('_');
  const compoundValue = where[compoundKeyName];

  if (compoundValue && typeof compoundValue === 'object') {
    // Decompose the compound key
    const { [compoundKeyName]: _removed, ...rest } = where;
    return {
      ...rest,
      ...(compoundValue as Record<string, unknown>),
    };
  }

  return where;
}

/**
 * Builds a deterministic PK suffix for mangling unique fields.
 * For simple PKs: "__deleted_{pkValue}"
 * For compound PKs: "__deleted_{pk1Value}_{pk2Value}" (fields sorted alphabetically)
 */
function buildPkSuffix(modelName: string, record: Record<string, unknown>): string {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return '__deleted_unknown';

  const pkFields = Array.isArray(pk) ? [...pk].sort() : [pk];
  const pkValues = pkFields.map(field => String(record[field] ?? 'null'));
  return \`__deleted_\${pkValues.join('_')}\`;
}

/**
 * Gets the unique string fields for a model that need mangling on soft delete.
 */
function getUniqueStringFields(modelName: string): string[] {
  return UNIQUE_STRING_FIELDS[modelName] ?? [];
}

/**
 * Default max length for string fields (conservative estimate).
 * Most databases use 255 for varchar without explicit length.
 */
const DEFAULT_MAX_STRING_LENGTH = 255;

/**
 * Mangles unique string fields by appending the PK suffix.
 * Returns the update data object with mangled values, or throws if mangling would exceed max length.
 * Returns empty object if UNIQUE_STRATEGY is 'none'.
 */
function mangleUniqueFields(
  modelName: string,
  record: Record<string, unknown>,
  maxLength: number = DEFAULT_MAX_STRING_LENGTH
): Record<string, unknown> {
  // Skip mangling if strategy is 'none'
  if (UNIQUE_STRATEGY === 'none') return {};

  const uniqueFields = getUniqueStringFields(modelName);
  if (uniqueFields.length === 0) return {};

  const suffix = buildPkSuffix(modelName, record);
  const updates: Record<string, unknown> = {};

  for (const field of uniqueFields) {
    const currentValue = record[field];

    // Skip null/undefined values - they don't conflict with unique constraints
    if (currentValue === null || currentValue === undefined) {
      continue;
    }

    const strValue = String(currentValue);

    // Skip if already mangled (idempotent)
    if (strValue.endsWith(suffix)) {
      continue;
    }

    const mangledValue = strValue + suffix;

    // Check max length
    if (mangledValue.length > maxLength) {
      throw new Error(
        \`Cannot soft delete \${modelName}: mangling unique field "\${field}" would exceed max length \` +
        \`(\${mangledValue.length} > \${maxLength}). Original value: "\${strValue.substring(0, 50)}\${strValue.length > 50 ? '...' : ''}". \` +
        \`Consider using a partial unique index instead, or hard delete the record.\`
      );
    }

    updates[field] = mangledValue;
  }

  return updates;
}

/**
 * Unmangles unique string fields by removing the PK suffix.
 * Returns the update data object with unmangled values.
 * Returns empty object if UNIQUE_STRATEGY is 'none'.
 */
function unmangleUniqueFields(
  modelName: string,
  record: Record<string, unknown>
): Record<string, unknown> {
  // Skip unmangling if strategy is 'none' (nothing was mangled)
  if (UNIQUE_STRATEGY === 'none') return {};

  const uniqueFields = getUniqueStringFields(modelName);
  if (uniqueFields.length === 0) return {};

  const suffix = buildPkSuffix(modelName, record);
  const updates: Record<string, unknown> = {};

  for (const field of uniqueFields) {
    const currentValue = record[field];

    // Skip null/undefined values
    if (currentValue === null || currentValue === undefined) {
      continue;
    }

    const strValue = String(currentValue);

    // Only unmangle if it has the suffix
    if (strValue.endsWith(suffix)) {
      updates[field] = strValue.slice(0, -suffix.length);
    }
  }

  return updates;
}`.trim();
}

function emitInjectFiltersFunction(): string {
  return `
/**
 * Recursively injects deleted_at: null filters into query args
 */
function injectFilters<T extends Record<string, unknown>>(
  args: T | undefined,
  modelName: string
): T {
  if (!args) {
    const deletedAtField = getDeletedAtField(modelName);
    if (deletedAtField) {
      return { where: { [deletedAtField]: null } } as T;
    }
    return {} as T;
  }

  const result = { ...args };
  const deletedAtField = getDeletedAtField(modelName);

  // Inject into top-level where and process relation filters
  if (deletedAtField) {
    result.where = injectIntoWhere(
      {
        ...((result.where as Record<string, unknown>) ?? {}),
        [deletedAtField]: null,
      },
      modelName
    );
  } else if (result.where) {
    result.where = injectIntoWhere(
      result.where as Record<string, unknown>,
      modelName
    );
  }

  // Process include
  if (result.include && typeof result.include === 'object') {
    result.include = injectIntoRelations(
      result.include as Record<string, unknown>,
      modelName
    );
  }

  // Process select
  if (result.select && typeof result.select === 'object') {
    result.select = injectIntoRelations(
      result.select as Record<string, unknown>,
      modelName
    );
  }

  return result;
}

/**
 * Injects soft delete filters into where clauses, including relation filters
 */
function injectIntoWhere(
  where: Record<string, unknown>,
  parentModel: string
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(where)) {
    // Check if this is a relation filter (some, every, none, is, isNot)
    const relationModel = getRelationModel(parentModel, key);

    if (relationModel && value && typeof value === 'object') {
      const relationFilter = value as Record<string, unknown>;
      const deletedAtField = getDeletedAtField(relationModel);
      const processedFilter: Record<string, unknown> = {};

      for (const [filterKey, filterValue] of Object.entries(relationFilter)) {
        if (['some', 'every', 'none'].includes(filterKey) && filterValue && typeof filterValue === 'object') {
          // Inject deleted_at filter into the relation condition
          const innerWhere = filterValue as Record<string, unknown>;
          if (deletedAtField) {
            processedFilter[filterKey] = injectIntoWhere(
              { ...innerWhere, [deletedAtField]: null },
              relationModel
            );
          } else {
            processedFilter[filterKey] = injectIntoWhere(innerWhere, relationModel);
          }
        } else if (['is', 'isNot'].includes(filterKey) && filterValue && typeof filterValue === 'object') {
          // Handle is/isNot for single relations
          const innerWhere = filterValue as Record<string, unknown>;
          if (deletedAtField) {
            processedFilter[filterKey] = injectIntoWhere(
              { ...innerWhere, [deletedAtField]: null },
              relationModel
            );
          } else {
            processedFilter[filterKey] = injectIntoWhere(innerWhere, relationModel);
          }
        } else {
          processedFilter[filterKey] = filterValue;
        }
      }

      result[key] = processedFilter;
    } else if (key === 'AND' && Array.isArray(value)) {
      result[key] = value.map(v =>
        typeof v === 'object' && v !== null
          ? injectIntoWhere(v as Record<string, unknown>, parentModel)
          : v
      );
    } else if (key === 'OR' && Array.isArray(value)) {
      result[key] = value.map(v =>
        typeof v === 'object' && v !== null
          ? injectIntoWhere(v as Record<string, unknown>, parentModel)
          : v
      );
    } else if (key === 'NOT' && value && typeof value === 'object') {
      result[key] = Array.isArray(value)
        ? value.map(v => typeof v === 'object' && v !== null
            ? injectIntoWhere(v as Record<string, unknown>, parentModel)
            : v)
        : injectIntoWhere(value as Record<string, unknown>, parentModel);
    } else {
      result[key] = value;
    }
  }

  return result;
}

/**
 * Injects filters into relation includes/selects
 */
function injectIntoRelations(
  relations: Record<string, unknown>,
  parentModel: string
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(relations)) {
    // Handle _count specially
    if (key === '_count') {
      if (value === true) {
        // Simple _count: true - we need to add filters for all countable relations
        // This is complex because we don't know which relations are being counted
        // For now, pass through (Prisma will count all)
        result[key] = value;
      } else if (value && typeof value === 'object') {
        const countObj = value as Record<string, unknown>;
        if (countObj.select && typeof countObj.select === 'object') {
          // _count: { select: { posts: true, comments: true } }
          const countSelect = countObj.select as Record<string, unknown>;
          const filteredCountSelect: Record<string, unknown> = {};

          for (const [relName, relValue] of Object.entries(countSelect)) {
            const relationModel = getRelationModel(parentModel, relName);
            if (relationModel) {
              const deletedAtField = getDeletedAtField(relationModel);
              if (deletedAtField && relValue === true) {
                // Add where filter to count only non-deleted
                filteredCountSelect[relName] = {
                  where: { [deletedAtField]: null },
                };
              } else if (deletedAtField && relValue && typeof relValue === 'object') {
                // Merge with existing where
                const existing = relValue as Record<string, unknown>;
                filteredCountSelect[relName] = {
                  ...existing,
                  where: {
                    ...((existing.where as Record<string, unknown>) ?? {}),
                    [deletedAtField]: null,
                  },
                };
              } else {
                filteredCountSelect[relName] = relValue;
              }
            } else {
              filteredCountSelect[relName] = relValue;
            }
          }

          result[key] = { ...countObj, select: filteredCountSelect };
        } else {
          result[key] = value;
        }
      } else {
        result[key] = value;
      }
      continue;
    }

    // Look up the actual target model for this relation field
    const relationModel = getRelationModel(parentModel, key);
    const isList = isListRelation(parentModel, key);

    if (value === true) {
      // Simple include - inject filter if relation target is soft-deletable
      // Only add where clause for list relations (non-list relations don't support where in include)
      if (relationModel && isList) {
        const deletedAtField = getDeletedAtField(relationModel);
        if (deletedAtField) {
          result[key] = {
            where: { [deletedAtField]: null },
          };
        } else {
          result[key] = value;
        }
      } else {
        result[key] = value;
      }
    } else if (value && typeof value === 'object') {
      // Nested include with options
      const nested = { ...(value as Record<string, unknown>) };

      if (relationModel) {
        // Only add where clause for list relations
        if (isList) {
          const deletedAtField = getDeletedAtField(relationModel);
          if (deletedAtField) {
            nested.where = {
              ...((nested.where as Record<string, unknown>) ?? {}),
              [deletedAtField]: null,
            };
          }
        }

        // Recursively process nested includes
        if (nested.include && typeof nested.include === 'object') {
          nested.include = injectIntoRelations(
            nested.include as Record<string, unknown>,
            relationModel
          );
        }

        // Recursively process nested selects
        if (nested.select && typeof nested.select === 'object') {
          nested.select = injectIntoRelations(
            nested.select as Record<string, unknown>,
            relationModel
          );
        }
      }

      result[key] = nested;
    } else {
      result[key] = value;
    }
  }

  return result;
}`.trim();
}

function emitSoftDeleteCascadeFunction(): string {
  return `
/**
 * Performs a soft delete with cascade (with its own transaction)
 */
async function softDeleteWithCascade(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>,
  deletedBy?: string
): Promise<{ count: number; cascaded: Record<string, number> }> {
  return prisma.$transaction(async (tx) => {
    return softDeleteWithCascadeInTx(tx, modelName, where, deletedBy);
  });
}

/**
 * Performs a soft delete with cascade within an existing transaction
 */
async function softDeleteWithCascadeInTx(
  tx: any,
  modelName: string,
  where: Record<string, unknown>,
  deletedBy?: string
): Promise<{ count: number; cascaded: Record<string, number> }> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  const now = new Date();
  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);

  // Find all records to delete
  const delegate = tx[lowerModelName as keyof typeof tx] as any;
  // Decompose compound key where clause if needed
  const decomposedWhere = decomposeCompoundKeyWhere(modelName, where);
  const records = await delegate.findMany({
    where: {
      ...decomposedWhere,
      [deletedAtField]: null, // Only non-deleted records
    },
  });

  if (records.length === 0) return { count: 0, cascaded: {} };

  // Get primary keys of records to delete
  const pkValues = records.map((r: Record<string, unknown>) =>
    extractPrimaryKey(modelName, r)
  );

  // Cascade to children (depth-first)
  const cascaded = await cascadeToChildren(tx, modelName, pkValues, now, deletedBy);

  // Update parent records - mangle unique fields first, then set deleted_at
  const pk = PRIMARY_KEYS[modelName];
  const pkField = Array.isArray(pk) ? pk.join('_') : pk;

  // For each record, we need to mangle unique fields individually
  // because each record has its own PK suffix
  for (const record of records) {
    const pkVal = extractPrimaryKey(modelName, record);
    const mangledFields = mangleUniqueFields(modelName, record);

    const updateData: Record<string, unknown> = {
      ...mangledFields,
      [deletedAtField]: now,
    };

    const deletedByField = getDeletedByField(modelName);
    if (deletedByField && deletedBy) {
      updateData[deletedByField] = deletedBy;
    }

    await delegate.update({
      where: createPkWhereFromValues(modelName, pkVal),
      data: updateData,
    });
  }

  return { count: records.length, cascaded };
}

/**
 * Gets the deleted_by field name for a model
 */
function getDeletedByField(modelName: string): string | null {
  return DELETED_BY_MODELS[modelName]?.deletedByField ?? null;
}

/**
 * Recursively cascades soft delete to children
 */
async function cascadeToChildren(
  tx: any,
  parentModel: string,
  parentPkValues: Record<string, unknown>[],
  deletedAt: Date,
  deletedBy?: string
): Promise<Record<string, number>> {
  const children = CASCADE_GRAPH[parentModel] ?? [];
  const cascaded: Record<string, number> = {};

  for (const child of children) {
    const lowerChildModel = child.model.charAt(0).toLowerCase() + child.model.slice(1);
    const childDelegate = tx[lowerChildModel as keyof typeof tx] as any;

    // Build where clause to find children - handle compound keys
    if (child.foreignKey.length === 0 || child.parentKey.length === 0) continue;

    // Build OR conditions for each parent record (supports compound keys)
    const childWhereConditions = parentPkValues.map((pkVal) => {
      const condition: Record<string, unknown> = {};
      for (let i = 0; i < child.foreignKey.length; i++) {
        const fkField = child.foreignKey[i];
        const pkField = child.parentKey[i];
        if (fkField && pkField) {
          condition[fkField] = pkVal[pkField];
        }
      }
      return condition;
    });

    // Find child records
    const childRecords = await childDelegate.findMany({
      where: {
        OR: childWhereConditions,
        ...(child.deletedAtField ? { [child.deletedAtField]: null } : {}),
      },
    });

    if (childRecords.length === 0) continue;

    // Get child PKs for recursive cascade
    const childPkValues = childRecords.map((r: Record<string, unknown>) =>
      extractPrimaryKey(child.model, r)
    );

    // Recurse to grandchildren first (depth-first)
    const grandchildCascaded = await cascadeToChildren(tx, child.model, childPkValues, deletedAt, deletedBy);

    // Merge grandchild results
    for (const [model, count] of Object.entries(grandchildCascaded)) {
      cascaded[model] = (cascaded[model] ?? 0) + count;
    }

    // Soft delete children (if soft-deletable)
    if (child.isSoftDeletable && child.deletedAtField) {
      // Mangle unique fields for each child individually
      for (const childRecord of childRecords) {
        const childPkVal = extractPrimaryKey(child.model, childRecord);
        const mangledFields = mangleUniqueFields(child.model, childRecord);

        const updateData: Record<string, unknown> = {
          ...mangledFields,
          [child.deletedAtField]: deletedAt,
        };

        // Set deleted_by if the child model has the field and a value was provided
        if (child.deletedByField && deletedBy) {
          updateData[child.deletedByField] = deletedBy;
        }

        await childDelegate.update({
          where: createPkWhereFromValues(child.model, childPkVal),
          data: updateData,
        });
      }

      // Track the count for this child model
      cascaded[child.model] = (cascaded[child.model] ?? 0) + childRecords.length;
    }
  }

  return cascaded;
}

/**
 * Restores a soft-deleted record by setting deleted_at to null and unmangling unique fields.
 * Wrapped in a transaction for safety.
 * Throws if unmangled unique values would conflict with existing records.
 */
async function restoreRecord(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<Record<string, unknown> | null> {
  return prisma.$transaction(async (tx) => {
    return restoreRecordInTx(tx, modelName, where);
  });
}

/**
 * Restores a soft-deleted record within a transaction.
 */
async function restoreRecordInTx(
  tx: any,
  modelName: string,
  where: Record<string, unknown>
): Promise<Record<string, unknown> | null> {
  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);
  const delegate = tx[lowerModelName as keyof typeof tx] as any;
  return restoreRecordWithDelegate(delegate, modelName, where);
}

/**
 * Core restore logic used by both restoreRecord and restoreRecordInTx.
 */
async function restoreRecordWithDelegate(
  delegate: any,
  modelName: string,
  where: Record<string, unknown>
): Promise<Record<string, unknown> | null> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  // Decompose compound key where clause if needed
  const decomposedWhere = decomposeCompoundKeyWhere(modelName, where);

  // Find the soft-deleted record
  const record = await delegate.findFirst({
    where: {
      ...decomposedWhere,
      [deletedAtField]: { not: null }, // Only deleted records
    },
  });

  if (!record) return null;

  // Get unmangled field values
  const unmangledFields = unmangleUniqueFields(modelName, record);

  // Check for conflicts before restoring
  if (Object.keys(unmangledFields).length > 0) {
    for (const [field, value] of Object.entries(unmangledFields)) {
      const existing = await delegate.findFirst({
        where: {
          [field]: value,
          [deletedAtField]: null, // Only check against non-deleted records
        },
      });

      if (existing) {
        throw new Error(
          \`Cannot restore \${modelName}: unique field "\${field}" with value "\${value}" \` +
          \`already exists in an active record. Delete or modify the conflicting record first.\`
        );
      }
    }
  }

  // Restore the record
  const pkVal = extractPrimaryKey(modelName, record);
  const deletedByField = getDeletedByField(modelName);

  const updateData: Record<string, unknown> = {
    ...unmangledFields,
    [deletedAtField]: null,
  };

  // Clear deleted_by if the model has that field
  if (deletedByField) {
    updateData[deletedByField] = null;
  }

  return delegate.update({
    where: createPkWhereFromValues(modelName, pkVal),
    data: updateData,
  });
}

/**
 * Restores multiple soft-deleted records.
 * Wrapped in a transaction for safety.
 * Throws if any unmangled unique values would conflict.
 */
async function restoreManyRecords(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ count: number }> {
  return prisma.$transaction(async (tx) => {
    return restoreManyInTx(tx, modelName, where);
  });
}

/**
 * Restores multiple soft-deleted records within a transaction.
 */
async function restoreManyInTx(
  tx: any,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ count: number }> {
  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);
  const delegate = tx[lowerModelName as keyof typeof tx] as any;
  return restoreManyWithDelegate(delegate, modelName, where);
}

/**
 * Core restoreMany logic used by both restoreManyRecords and restoreManyInTx.
 */
async function restoreManyWithDelegate(
  delegate: any,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ count: number }> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  // Find all soft-deleted records matching the criteria
  const records = await delegate.findMany({
    where: {
      ...where,
      [deletedAtField]: { not: null },
    },
  });

  if (records.length === 0) return { count: 0 };

  // Check for conflicts and restore each record
  const deletedByField = getDeletedByField(modelName);
  let restoredCount = 0;

  for (const record of records) {
    const unmangledFields = unmangleUniqueFields(modelName, record);

    // Check for conflicts
    if (Object.keys(unmangledFields).length > 0) {
      for (const [field, value] of Object.entries(unmangledFields)) {
        const existing = await delegate.findFirst({
          where: {
            [field]: value,
            [deletedAtField]: null,
          },
        });

        if (existing) {
          throw new Error(
            \`Cannot restore \${modelName}: unique field "\${field}" with value "\${value}" \` +
            \`already exists in an active record. Delete or modify the conflicting record first.\`
          );
        }
      }
    }

    // Restore this record
    const pkVal = extractPrimaryKey(modelName, record);
    const updateData: Record<string, unknown> = {
      ...unmangledFields,
      [deletedAtField]: null,
    };

    if (deletedByField) {
      updateData[deletedByField] = null;
    }

    await delegate.update({
      where: createPkWhereFromValues(modelName, pkVal),
      data: updateData,
    });

    restoredCount++;
  }

  return { count: restoredCount };
}

/**
 * Restores a soft-deleted record AND all its cascade-deleted children.
 * Children are identified by having the same deleted_at timestamp as the parent.
 * Wrapped in a transaction.
 */
async function restoreWithCascade(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ record: Record<string, unknown> | null; cascaded: Record<string, number> }> {
  return prisma.$transaction(async (tx) => {
    return restoreWithCascadeInTx(tx, modelName, where);
  });
}

/**
 * Restores a soft-deleted record AND all its cascade-deleted children within a transaction.
 */
async function restoreWithCascadeInTx(
  tx: any,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ record: Record<string, unknown> | null; cascaded: Record<string, number> }> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);
  const delegate = tx[lowerModelName as keyof typeof tx] as any;

  // Decompose compound key where clause if needed
  const decomposedWhere = decomposeCompoundKeyWhere(modelName, where);

  // Find the soft-deleted record
  const record = await delegate.findFirst({
    where: {
      ...decomposedWhere,
      [deletedAtField]: { not: null },
    },
  });

  if (!record) return { record: null, cascaded: {} };

  const deletedAt = record[deletedAtField];

  // Restore children first (depth-first, reverse of cascade delete)
  const pkVal = extractPrimaryKey(modelName, record);
  const cascaded = await restoreCascadeChildren(tx, modelName, [pkVal], deletedAt);

  // Now restore the parent record
  const unmangledFields = unmangleUniqueFields(modelName, record);

  // Check for conflicts
  if (Object.keys(unmangledFields).length > 0) {
    for (const [field, value] of Object.entries(unmangledFields)) {
      const existing = await delegate.findFirst({
        where: {
          [field]: value,
          [deletedAtField]: null,
        },
      });

      if (existing) {
        throw new Error(
          \`Cannot restore \${modelName}: unique field "\${field}" with value "\${value}" \` +
          \`already exists in an active record. Delete or modify the conflicting record first.\`
        );
      }
    }
  }

  const deletedByField = getDeletedByField(modelName);
  const updateData: Record<string, unknown> = {
    ...unmangledFields,
    [deletedAtField]: null,
  };

  if (deletedByField) {
    updateData[deletedByField] = null;
  }

  const restoredRecord = await delegate.update({
    where: createPkWhereFromValues(modelName, pkVal),
    data: updateData,
  });

  return { record: restoredRecord, cascaded };
}

/**
 * Recursively restores cascade-deleted children.
 * Only restores children with matching deleted_at timestamp.
 */
async function restoreCascadeChildren(
  tx: any,
  parentModel: string,
  parentPkValues: Record<string, unknown>[],
  deletedAt: Date
): Promise<Record<string, number>> {
  const children = CASCADE_GRAPH[parentModel] ?? [];
  const cascaded: Record<string, number> = {};

  for (const child of children) {
    if (!child.isSoftDeletable || !child.deletedAtField) continue;

    const lowerChildModel = child.model.charAt(0).toLowerCase() + child.model.slice(1);
    const childDelegate = tx[lowerChildModel as keyof typeof tx] as any;

    // Build where clause to find children
    if (child.foreignKey.length === 0 || child.parentKey.length === 0) continue;

    const childWhereConditions = parentPkValues.map((pkVal) => {
      const condition: Record<string, unknown> = {};
      for (let i = 0; i < child.foreignKey.length; i++) {
        const fkField = child.foreignKey[i];
        const pkField = child.parentKey[i];
        if (fkField && pkField) {
          condition[fkField] = pkVal[pkField];
        }
      }
      return condition;
    });

    // Find children with matching deleted_at timestamp
    const childRecords = await childDelegate.findMany({
      where: {
        OR: childWhereConditions,
        [child.deletedAtField]: deletedAt, // Must match exact timestamp
      },
    });

    if (childRecords.length === 0) continue;

    // Get child PKs for recursive restore
    const childPkValues = childRecords.map((r: Record<string, unknown>) =>
      extractPrimaryKey(child.model, r)
    );

    // Recurse to grandchildren first
    const grandchildCascaded = await restoreCascadeChildren(tx, child.model, childPkValues, deletedAt);

    // Merge grandchild results
    for (const [model, count] of Object.entries(grandchildCascaded)) {
      cascaded[model] = (cascaded[model] ?? 0) + count;
    }

    // Now restore the children
    for (const childRecord of childRecords) {
      const childPkVal = extractPrimaryKey(child.model, childRecord);
      const unmangledFields = unmangleUniqueFields(child.model, childRecord);

      // Check for conflicts
      if (Object.keys(unmangledFields).length > 0) {
        for (const [field, value] of Object.entries(unmangledFields)) {
          const existing = await childDelegate.findFirst({
            where: {
              [field]: value,
              [child.deletedAtField]: null,
            },
          });

          if (existing) {
            throw new Error(
              \`Cannot restore \${child.model}: unique field "\${field}" with value "\${value}" \` +
              \`already exists in an active record.\`
            );
          }
        }
      }

      const updateData: Record<string, unknown> = {
        ...unmangledFields,
        [child.deletedAtField]: null,
      };

      if (child.deletedByField) {
        updateData[child.deletedByField] = null;
      }

      await childDelegate.update({
        where: createPkWhereFromValues(child.model, childPkVal),
        data: updateData,
      });
    }

    // Track the count for this child model
    cascaded[child.model] = (cascaded[child.model] ?? 0) + childRecords.length;
  }

  return cascaded;
}`.trim();
}

function emitModelDelegate(model: ParsedModel, options: EmitRuntimeOptions): string {
  const name = model.name;
  const lowerName = toLowerFirst(name);

  if (model.isSoftDeletable && model.deletedAtField !== null) {
    const deletedAtField = model.deletedAtField;
    const simple = isSimpleModel(model, options);

    // Common parts shared between simple and complex delegates
    const readMethods = `
    // Wrapped methods with filter injection
    findMany: (args?: any) => original.findMany(injectFilters(args, '${name}')),
    findFirst: (args?: any) => original.findFirst(injectFilters(args, '${name}')),
    findFirstOrThrow: (args?: any) => original.findFirstOrThrow(injectFilters(args, '${name}')),
    findUnique: (args?: any) => original.findUnique(injectFilters(args, '${name}')),
    findUniqueOrThrow: (args?: any) => original.findUniqueOrThrow(injectFilters(args, '${name}')),
    count: (args?: any) => original.count(injectFilters(args, '${name}')),
    aggregate: (args?: any) => original.aggregate(injectFilters(args, '${name}')),
    groupBy: (args?: any) => original.groupBy(injectFilters(args, '${name}')),`;

    const writeMethods = `
    // Pass-through methods (no filter needed for writes)
    create: (args: any) => original.create(args),
    createMany: (args: any) => original.createMany(args),
    createManyAndReturn: (args: any) => original.createManyAndReturn(args),
    update: (args: any) => original.update(injectFilters(args, '${name}')),
    updateMany: (args: any) => original.updateMany(injectFilters(args, '${name}')),
    upsert: (args: any) => original.upsert(args),`;

    const restoreMethods = `
    // Restore methods
    restore: async (args: any) => {
      return restoreRecord(prisma, '${name}', args.where);
    },
    restoreMany: async (args: any) => {
      return restoreManyRecords(prisma, '${name}', args.where);
    },
    restoreCascade: async (args: any) => {
      const { record, cascaded } = await restoreWithCascade(prisma, '${name}', args.where);
      return { record, cascaded };
    },`;

    const hardDeleteMethods = `
    // Hard delete (intentionally ugly name to discourage use)
    __dangerousHardDelete: (args: any) => original.delete(args),
    __dangerousHardDeleteMany: (args: any) => original.deleteMany(args),`;

    const includingDeletedMethods = `
    // Access raw delegate without soft-delete filtering
    includingDeleted: {
      findMany: (args?: any) => original.findMany(args),
      findFirst: (args?: any) => original.findFirst(args),
      findFirstOrThrow: (args?: any) => original.findFirstOrThrow(args),
      findUnique: (args?: any) => original.findUnique(args),
      findUniqueOrThrow: (args?: any) => original.findUniqueOrThrow(args),
      count: (args?: any) => original.count(args),
      aggregate: (args?: any) => original.aggregate(args),
      groupBy: (args?: any) => original.groupBy(args),
    },`;

    let softDeleteMethods: string;

    if (simple) {
      // Fast path: use updateMany directly (no transaction, no per-record updates)
      const deletedByUpdate = model.deletedByField !== null
        ? `\n      const deletedByField = ${JSON.stringify(model.deletedByField)};\n      if (deletedByField && deletedBy) {\n        updateData[deletedByField] = deletedBy;\n      }`
        : '';

      softDeleteMethods = `
    // Soft delete methods (fast path - no cascade children, no unique mangling)
    softDelete: async (args: any) => {
      const { deletedBy, ...rest } = args;
      const decomposedWhere = decomposeCompoundKeyWhere('${name}', rest.where);
      const now = new Date();
      const updateData: Record<string, unknown> = { ['${deletedAtField}']: now };${deletedByUpdate}
      await original.updateMany({
        where: { ...decomposedWhere, ['${deletedAtField}']: null },
        data: updateData,
      });
      const record = await original.findFirst({ where: decomposedWhere });
      return { record, cascaded: {} };
    },
    softDeleteMany: async (args: any) => {
      const { deletedBy, ...rest } = args;
      const updateData: Record<string, unknown> = { ['${deletedAtField}']: new Date() };${deletedByUpdate}
      const result = await original.updateMany({
        where: { ...rest.where, ['${deletedAtField}']: null },
        data: updateData,
      });
      return { count: result.count, cascaded: {} };
    },`;
    } else {
      // Complex path: use softDeleteWithCascade (transaction, per-record updates)
      softDeleteMethods = `
    // Soft delete methods (with cascade support)
    // NOTE: deletedBy requirement is enforced at COMPILE-TIME only via TypeScript types.
    // There is no runtime validation - callers bypassing TypeScript (e.g., plain JS) must
    // ensure they pass deletedBy for models with deleted_by fields.
    softDelete: async (args: any) => {
      const { deletedBy, ...rest } = args;
      const { cascaded } = await softDeleteWithCascade(prisma, '${name}', rest.where, deletedBy);
      // Decompose compound key for findFirst
      const decomposedWhere = decomposeCompoundKeyWhere('${name}', rest.where);
      const record = await original.findFirst({ where: decomposedWhere });
      return { record, cascaded };
    },
    softDeleteMany: async (args: any) => {
      const { deletedBy, ...rest } = args;
      const { count, cascaded } = await softDeleteWithCascade(prisma, '${name}', rest.where, deletedBy);
      return { count, cascaded };
    },`;
    }

    return `
/**
 * Creates a safe delegate for ${name} with soft-delete support
 */
function create${name}Delegate(prisma: PrismaClient): any {
  const original = prisma.${lowerName};

  return {${readMethods}
${writeMethods}
${softDeleteMethods}
${restoreMethods}
${hardDeleteMethods}
${includingDeletedMethods}
  };
}`.trim();
  }

  return `
/**
 * Creates a delegate for ${name} (no soft-delete)
 */
function create${name}Delegate(prisma: PrismaClient): any {
  return prisma.${lowerName};
}`.trim();
}

function emitIncludingDeletedClient(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Creates a client that includes soft-deleted records');
  lines.push(' */');
  lines.push('function createIncludingDeletedClient(prisma: PrismaClient): IncludingDeletedClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    lines.push(`    ${lowerName}: prisma.${lowerName},`);
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitOnlyDeletedClient(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Creates a client that queries only soft-deleted records');
  lines.push(' */');
  lines.push('function createOnlyDeletedClient(prisma: PrismaClient): OnlyDeletedClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    if (model.isSoftDeletable && model.deletedAtField !== null) {
      const lowerName = toLowerFirst(model.name);
      lines.push(`    ${lowerName}: {`);
      lines.push(`      findMany: (args?: any) => prisma.${lowerName}.findMany({`);
      lines.push(`        ...args,`);
      lines.push(`        where: { ...args?.where, ${model.deletedAtField}: { not: null } },`);
      lines.push(`      }),`);
      lines.push(`      findFirst: (args?: any) => prisma.${lowerName}.findFirst({`);
      lines.push(`        ...args,`);
      lines.push(`        where: { ...args?.where, ${model.deletedAtField}: { not: null } },`);
      lines.push(`      }),`);
      lines.push(`      findUnique: (args?: any) => prisma.${lowerName}.findUnique({`);
      lines.push(`        ...args,`);
      lines.push(`        where: { ...args?.where, ${model.deletedAtField}: { not: null } },`);
      lines.push(`      }),`);
      lines.push(`      count: (args?: any) => prisma.${lowerName}.count({`);
      lines.push(`        ...args,`);
      lines.push(`        where: { ...args?.where, ${model.deletedAtField}: { not: null } },`);
      lines.push(`      }),`);
      lines.push(`    },`);
    }
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitTransactionWrapper(schema: ParsedSchema, options: EmitRuntimeOptions): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Wraps a transaction client with soft-delete filtering and full API');
  lines.push(' */');
  lines.push('function wrapTransactionClient(tx: any): any {');
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    if (model.isSoftDeletable && model.deletedAtField !== null) {
      const simple = isSimpleModel(model, options);
      const deletedAtField = model.deletedAtField;

      lines.push(`    ${lowerName}: {`);
      // Read operations with filter injection
      lines.push(`      findMany: (args?: any) => tx.${lowerName}.findMany(injectFilters(args, '${model.name}')),`);
      lines.push(`      findFirst: (args?: any) => tx.${lowerName}.findFirst(injectFilters(args, '${model.name}')),`);
      lines.push(`      findFirstOrThrow: (args?: any) => tx.${lowerName}.findFirstOrThrow(injectFilters(args, '${model.name}')),`);
      lines.push(`      findUnique: (args?: any) => tx.${lowerName}.findUnique(injectFilters(args, '${model.name}')),`);
      lines.push(`      findUniqueOrThrow: (args?: any) => tx.${lowerName}.findUniqueOrThrow(injectFilters(args, '${model.name}')),`);
      lines.push(`      count: (args?: any) => tx.${lowerName}.count(injectFilters(args, '${model.name}')),`);
      lines.push(`      aggregate: (args?: any) => tx.${lowerName}.aggregate(injectFilters(args, '${model.name}')),`);
      lines.push(`      groupBy: (args?: any) => tx.${lowerName}.groupBy(injectFilters(args, '${model.name}')),`);
      // Write operations
      lines.push(`      create: (args: any) => tx.${lowerName}.create(args),`);
      lines.push(`      createMany: (args: any) => tx.${lowerName}.createMany(args),`);
      lines.push(`      update: (args: any) => tx.${lowerName}.update(injectFilters(args, '${model.name}')),`);
      lines.push(`      updateMany: (args: any) => tx.${lowerName}.updateMany(injectFilters(args, '${model.name}')),`);
      lines.push(`      upsert: (args: any) => tx.${lowerName}.upsert(args),`);

      if (simple) {
        // Fast path: use updateMany directly
        lines.push(`      softDelete: async (args: any) => {`);
        lines.push(`        const { deletedBy, ...rest } = args;`);
        lines.push(`        const decomposedWhere = decomposeCompoundKeyWhere('${model.name}', rest.where);`);
        lines.push(`        const now = new Date();`);
        lines.push(`        const updateData: Record<string, unknown> = { ['${deletedAtField}']: now };`);
        if (model.deletedByField !== null) {
          lines.push(`        const deletedByField = ${JSON.stringify(model.deletedByField)};`);
          lines.push(`        if (deletedByField && deletedBy) {`);
          lines.push(`          updateData[deletedByField] = deletedBy;`);
          lines.push(`        }`);
        }
        lines.push(`        await tx.${lowerName}.updateMany({`);
        lines.push(`          where: { ...decomposedWhere, ['${deletedAtField}']: null },`);
        lines.push(`          data: updateData,`);
        lines.push(`        });`);
        lines.push(`        const record = await tx.${lowerName}.findFirst({ where: decomposedWhere });`);
        lines.push(`        return { record, cascaded: {} };`);
        lines.push(`      },`);
        lines.push(`      softDeleteMany: async (args: any) => {`);
        lines.push(`        const { deletedBy, ...rest } = args;`);
        lines.push(`        const updateData: Record<string, unknown> = { ['${deletedAtField}']: new Date() };`);
        if (model.deletedByField !== null) {
          lines.push(`        const deletedByField = ${JSON.stringify(model.deletedByField)};`);
          lines.push(`        if (deletedByField && deletedBy) {`);
          lines.push(`          updateData[deletedByField] = deletedBy;`);
          lines.push(`        }`);
        }
        lines.push(`        const result = await tx.${lowerName}.updateMany({`);
        lines.push(`          where: { ...rest.where, ['${deletedAtField}']: null },`);
        lines.push(`          data: updateData,`);
        lines.push(`        });`);
        lines.push(`        return { count: result.count, cascaded: {} };`);
        lines.push(`      },`);
      } else {
        // Complex path: use softDeleteWithCascadeInTx
        lines.push(`      softDelete: async (args: any) => {`);
        lines.push(`        const { deletedBy, ...rest } = args;`);
        lines.push(`        const { cascaded } = await softDeleteWithCascadeInTx(tx, '${model.name}', rest.where, deletedBy);`);
        lines.push(`        const decomposedWhere = decomposeCompoundKeyWhere('${model.name}', rest.where);`);
        lines.push(`        const record = await tx.${lowerName}.findFirst({ where: decomposedWhere });`);
        lines.push(`        return { record, cascaded };`);
        lines.push(`      },`);
        lines.push(`      softDeleteMany: async (args: any) => {`);
        lines.push(`        const { deletedBy, ...rest } = args;`);
        lines.push(`        const { count, cascaded } = await softDeleteWithCascadeInTx(tx, '${model.name}', rest.where, deletedBy);`);
        lines.push(`        return { count, cascaded };`);
        lines.push(`      },`);
      }

      // Restore methods
      lines.push(`      restore: async (args: any) => {`);
      lines.push(`        return restoreRecordInTx(tx, '${model.name}', args.where);`);
      lines.push(`      },`);
      lines.push(`      restoreMany: async (args: any) => {`);
      lines.push(`        return restoreManyInTx(tx, '${model.name}', args.where);`);
      lines.push(`      },`);
      lines.push(`      restoreCascade: async (args: any) => {`);
      lines.push(`        const { record, cascaded } = await restoreWithCascadeInTx(tx, '${model.name}', args.where);`);
      lines.push(`        return { record, cascaded };`);
      lines.push(`      },`);
      // Hard delete methods (intentionally scary names)
      lines.push(`      __dangerousHardDelete: (args: any) => tx.${lowerName}.delete(args),`);
      lines.push(`      __dangerousHardDeleteMany: (args: any) => tx.${lowerName}.deleteMany(args),`);
      // includingDeleted sub-object for raw access
      lines.push(`      includingDeleted: {`);
      lines.push(`        findMany: (args?: any) => tx.${lowerName}.findMany(args),`);
      lines.push(`        findFirst: (args?: any) => tx.${lowerName}.findFirst(args),`);
      lines.push(`        findFirstOrThrow: (args?: any) => tx.${lowerName}.findFirstOrThrow(args),`);
      lines.push(`        findUnique: (args?: any) => tx.${lowerName}.findUnique(args),`);
      lines.push(`        findUniqueOrThrow: (args?: any) => tx.${lowerName}.findUniqueOrThrow(args),`);
      lines.push(`        count: (args?: any) => tx.${lowerName}.count(args),`);
      lines.push(`        aggregate: (args?: any) => tx.${lowerName}.aggregate(args),`);
      lines.push(`        groupBy: (args?: any) => tx.${lowerName}.groupBy(args),`);
      lines.push(`      },`);
      lines.push(`    },`);
    } else {
      lines.push(`    ${lowerName}: tx.${lowerName},`);
    }
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitWrapperFunction(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Wraps a PrismaClient with soft-delete functionality');
  lines.push(' */');
  lines.push('export function wrapPrismaClient(prisma: PrismaClient): SafePrismaClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    lines.push(`    ${lowerName}: create${model.name}Delegate(prisma),`);
  }

  lines.push('');
  lines.push('    $connect: () => prisma.$connect(),');
  lines.push('    $disconnect: () => prisma.$disconnect(),');
  lines.push('    $on: (...args: any[]) => (prisma.$on as any)(...args),');
  lines.push('    $transaction: (arg: any, options?: any) => {');
  lines.push('      // Handle both sequential and interactive transactions');
  lines.push('      if (typeof arg === "function") {');
  lines.push('        // Interactive transaction - wrap the callback to provide safe delegates');
  lines.push('        return prisma.$transaction((tx: any) => {');
  lines.push('          const wrappedTx = wrapTransactionClient(tx);');
  lines.push('          return arg(wrappedTx);');
  lines.push('        }, options);');
  lines.push('      }');
  lines.push('      // Sequential transaction (array of promises)');
  lines.push('      return (prisma.$transaction as any)(arg, options);');
  lines.push('    },');
  lines.push('    $use: (...args: any[]) => (prisma.$use as any)(...args),');
  lines.push('    $extends: (...args: any[]) => (prisma.$extends as any)(...args),');
  lines.push('    $queryRaw: (...args: any[]) => (prisma.$queryRaw as any)(...args),');
  lines.push('    $executeRaw: (...args: any[]) => (prisma.$executeRaw as any)(...args),');
  lines.push('    $queryRawUnsafe: (...args: any[]) => (prisma.$queryRawUnsafe as any)(...args),');
  lines.push('    $executeRawUnsafe: (...args: any[]) => (prisma.$executeRawUnsafe as any)(...args),');
  lines.push('    $prisma: prisma,');
  lines.push('    $includingDeleted: createIncludingDeletedClient(prisma),');
  lines.push('    $onlyDeleted: createOnlyDeletedClient(prisma),');
  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function toLowerFirst(str: string): string {
  const first = str.charAt(0);
  return first.toLowerCase() + str.slice(1);
}
