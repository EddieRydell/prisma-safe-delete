import type { ParsedModel, ParsedSchema } from '../dmmf-parser.js';
import type { CascadeGraph } from '../cascade-graph.js';

/**
 * Strategy for handling unique constraints on soft delete.
 */
type UniqueStrategy = 'mangle' | 'none' | 'sentinel';

interface EmitRuntimeOptions {
  uniqueStrategy: UniqueStrategy;
  cascadeGraph: CascadeGraph;
}

/**
 * Determines if a model can use the fast path (single updateMany) for soft deletes.
 * Qualifying criteria: no cascade children AND (uniqueStrategy='none' OR no unique string fields).
 */
function isSimpleModel(model: ParsedModel, options: EmitRuntimeOptions): boolean {
  const children = options.cascadeGraph[model.name] ?? [];
  if (children.length > 0) return false;
  if (options.uniqueStrategy === 'none' || options.uniqueStrategy === 'sentinel') return true;
  return model.uniqueStringFields.length === 0;
}

/**
 * Generates the runtime wrapper functions
 * @param schema - The parsed Prisma schema
 * @param clientImportPath - The relative import path to the generated Prisma client (e.g., '../client')
 * @param options - Configuration options
 */
export function emitRuntime(
  schema: ParsedSchema,
  clientImportPath: string,
  options: EmitRuntimeOptions = { uniqueStrategy: 'mangle', cascadeGraph: {} },
): string {
  const lines: string[] = [];

  lines.push('/* eslint-disable */');
  lines.push('// @ts-nocheck');
  lines.push('// Auto-generated by prisma-safe-delete');
  lines.push('// Do not edit this file manually');
  lines.push('');
  lines.push(`import type { PrismaClient, Prisma } from '${clientImportPath}';`);
  lines.push("import { CASCADE_GRAPH } from './cascade-graph.js';");
  const delegateTypeImports = schema.models.map(m => `Safe${m.name}Delegate`).join(', ');
  lines.push(`import type { SafePrismaClient, SafeTransactionClient, IncludingDeletedClient, OnlyDeletedClient, ${delegateTypeImports} } from './types.js';`);
  lines.push('');

  // Emit model metadata
  lines.push('/** Metadata about soft-deletable models */');
  lines.push('const SOFT_DELETABLE_MODELS: Record<string, { deletedAtField: string }> = {');
  for (const model of schema.models) {
    if (model.isSoftDeletable && model.deletedAtField !== null) {
      lines.push(`  ${model.name}: { deletedAtField: ${JSON.stringify(model.deletedAtField)} },`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit deleted_by metadata
  lines.push('/** Metadata about models with deleted_by fields */');
  lines.push('const DELETED_BY_MODELS: Record<string, { deletedByField: string }> = {');
  for (const model of schema.models) {
    if (model.deletedByField !== null) {
      lines.push(`  ${model.name}: { deletedByField: ${JSON.stringify(model.deletedByField)} },`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit primary key metadata
  lines.push('/** Primary key configuration per model */');
  lines.push('const PRIMARY_KEYS: Record<string, string | string[]> = {');
  for (const model of schema.models) {
    const pkValue = Array.isArray(model.primaryKey)
      ? JSON.stringify(model.primaryKey)
      : JSON.stringify(model.primaryKey);
    lines.push(`  ${model.name}: ${pkValue},`);
  }
  lines.push('};');
  lines.push('');

  // Emit relation models mapping (for proper relation target lookup)
  lines.push('/** Maps model.field to target model name */');
  lines.push('const RELATION_MODELS: Record<string, string> = {');
  for (const model of schema.models) {
    for (const relation of model.relations) {
      lines.push(`  '${model.name}.${relation.name}': '${relation.type}',`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit relation list metadata (for knowing if a relation supports where clause)
  lines.push('/** Maps model.field to whether it is a list relation */');
  lines.push('const RELATION_IS_LIST: Record<string, boolean> = {');
  for (const model of schema.models) {
    for (const relation of model.relations) {
      lines.push(`  '${model.name}.${relation.name}': ${String(relation.isList)},`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit unique string fields metadata (for mangling on soft delete)
  lines.push('/**');
  lines.push(' * String fields with unique constraints that need mangling on soft delete.');
  lines.push(' * On soft delete, these fields get "__deleted_{pk}" appended to free up the unique value.');
  lines.push(' * For compound PKs, the suffix is "__deleted_{pk1}_{pk2}" (fields joined with underscore, sorted alphabetically).');
  lines.push(' */');
  lines.push('const UNIQUE_STRING_FIELDS: Record<string, string[]> = {');
  for (const model of schema.models) {
    if (model.uniqueStringFields.length > 0) {
      lines.push(`  ${model.name}: ${JSON.stringify(model.uniqueStringFields)},`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit unique strategy constant
  lines.push('/**');
  lines.push(' * Strategy for handling unique constraints on soft delete.');
  lines.push(" * - 'mangle': Append \"__deleted_{pk}\" suffix to unique string fields");
  lines.push(" * - 'none': Skip mangling (user handles uniqueness via partial indexes)");
  lines.push(" * - 'sentinel': Use a far-future sentinel date instead of NULL for active records");
  lines.push(' */');
  lines.push(`const UNIQUE_STRATEGY: 'mangle' | 'none' | 'sentinel' = '${options.uniqueStrategy}';`);
  lines.push('');

  // Emit ACTIVE_DELETED_AT_VALUE constant
  lines.push('/**');
  lines.push(' * The value used to represent "active" (not deleted) in the deleted_at column.');
  lines.push(" * - For mangle/none strategies: null (deleted_at IS NULL means active)");
  lines.push(" * - For sentinel strategy: far-future date (deleted_at = sentinel means active)");
  lines.push(' */');
  if (options.uniqueStrategy === 'sentinel') {
    lines.push("const ACTIVE_DELETED_AT_VALUE: Date = new Date('9999-12-31T00:00:00.000Z');");
  } else {
    lines.push('const ACTIVE_DELETED_AT_VALUE: null = null;');
  }
  lines.push('');

  // Emit SENTINEL_COMPOUND_UNIQUES metadata (only for sentinel strategy)
  if (options.uniqueStrategy === 'sentinel') {
    lines.push('/**');
    lines.push(' * Compound unique constraints that include deleted_at, per model.');
    lines.push(' * Used to transform findUnique where clauses for sentinel strategy.');
    lines.push(' */');
    lines.push('const SENTINEL_COMPOUND_UNIQUES: Record<string, { keyName: string; fields: string[]; deletedAtField: string }[]> = {');
    for (const model of schema.models) {
      if (!model.isSoftDeletable || model.deletedAtField === null) continue;
      const sentinelUniques = model.uniqueConstraints.filter(c => c.includesDeletedAt && c.compoundKeyName !== undefined);
      if (sentinelUniques.length === 0) continue;
      const entries = sentinelUniques.map(c =>
        `{ keyName: ${JSON.stringify(c.compoundKeyName)}, fields: ${JSON.stringify(c.fields)}, deletedAtField: ${JSON.stringify(model.deletedAtField)} }`
      );
      lines.push(`  ${model.name}: [${entries.join(', ')}],`);
    }
    lines.push('};');
    lines.push('');
  }

  // Emit helper functions
  lines.push(emitHelperFunctions());
  lines.push('');

  // Emit sentinel findUnique transformation helper (only for sentinel strategy)
  if (options.uniqueStrategy === 'sentinel') {
    lines.push(emitSentinelFindUniqueHelper());
    lines.push('');
  }

  // Emit injectFilters function
  lines.push(emitInjectFiltersFunction());
  lines.push('');

  // Emit soft delete cascade function
  lines.push(emitSoftDeleteCascadeFunction());
  lines.push('');

  // Emit model delegate wrappers
  for (const model of schema.models) {
    lines.push(emitModelDelegate(model, options));
    lines.push('');
  }

  // Emit includingDeleted and onlyDeleted clients
  lines.push(emitIncludingDeletedClient(schema));
  lines.push('');
  lines.push(emitOnlyDeletedClient(schema));
  lines.push('');

  // Emit transaction wrapper
  lines.push(emitTransactionWrapper(schema, options));
  lines.push('');

  // Emit main wrapper function
  lines.push(emitWrapperFunction(schema));
  lines.push('');

  // Emit filter helper utilities (exported for user use)
  lines.push(emitFilterHelpers());

  return lines.join('\n');
}

/**
 * Emits user-facing helper utilities for manual filtering
 */
function emitFilterHelpers(): string {
  return `
/**
 * Helper to filter for only soft-deleted records in where clauses.
 * Useful for nested relation filters where $onlyDeleted can't be used.
 *
 * @example
 * safePrisma.users.findMany({
 *   where: {
 *     memberships: {
 *       some: onlyDeleted('Membership', { organization_id: orgId })
 *     }
 *   }
 * });
 */
export function onlyDeleted<T extends Record<string, unknown>>(
  modelName: string,
  where: T = {} as T
): T & Record<string, unknown> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) return where;
  return { ...where, [deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE } } as T & Record<string, unknown>;
}

/**
 * Helper to filter for only non-deleted (active) records in where clauses.
 * This is the default behavior, but can be useful for explicit overrides.
 *
 * @example
 * safePrisma.$onlyDeleted.users.findFirst({
 *   include: {
 *     posts: {
 *       where: excludeDeleted('Post', { published: true })
 *     }
 *   }
 * });
 */
export function excludeDeleted<T extends Record<string, unknown>>(
  modelName: string,
  where: T = {} as T
): T & Record<string, unknown> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) return where;
  return { ...where, [deletedAtField]: ACTIVE_DELETED_AT_VALUE } as T & Record<string, unknown>;
}

/**
 * Helper to include all records (deleted + active) in where clauses.
 * This is a no-op function for clarity/documentation purposes.
 *
 * @example
 * safePrisma.users.findMany({
 *   where: includingDeleted({ status: 'premium' })
 * });
 */
export function includingDeleted<T extends Record<string, unknown>>(
  where: T = {} as T
): T {
  return where;
}`.trim();
}

function emitHelperFunctions(): string {
  return `
/**
 * Gets the deleted_at field name for a model
 */
function getDeletedAtField(modelName: string): string | null {
  return SOFT_DELETABLE_MODELS[modelName]?.deletedAtField ?? null;
}

/**
 * Extracts primary key values from a record
 */
function extractPrimaryKey(modelName: string, record: Record<string, unknown>): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return {};

  const keys = Array.isArray(pk) ? pk : [pk];
  const result: Record<string, unknown> = {};

  for (const key of keys) {
    result[key] = record[key];
  }

  return result;
}

/**
 * Creates a where clause for updating a record by its primary key values.
 * For simple PKs: { id: 'value' }
 * For compound PKs: { pk1_pk2: { pk1: 'v1', pk2: 'v2' } }
 */
function createPkWhereFromValues(modelName: string, pkValues: Record<string, unknown>): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return pkValues;

  if (Array.isArray(pk)) {
    // Compound key - Prisma expects { pk1_pk2: { pk1: v1, pk2: v2 } }
    const compoundName = pk.join('_');
    return { [compoundName]: pkValues };
  }

  // Simple key - just return the values as-is
  return pkValues;
}

/**
 * Gets the target model name for a relation field
 */
function getRelationModel(parentModel: string, fieldName: string): string | null {
  return RELATION_MODELS[\`\${parentModel}.\${fieldName}\`] ?? null;
}

/**
 * Checks if a relation is a list (to-many) relation
 */
function isListRelation(parentModel: string, fieldName: string): boolean {
  return RELATION_IS_LIST[\`\${parentModel}.\${fieldName}\`] ?? false;
}

/**
 * Decomposes a compound key where clause into individual fields.
 * Converts { tenantId_userId: { tenantId: 'x', userId: 'y' } } into { tenantId: 'x', userId: 'y' }
 */
function decomposeCompoundKeyWhere(
  modelName: string,
  where: Record<string, unknown>
): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk || !Array.isArray(pk)) {
    return where;
  }

  // Check if where contains the compound key name
  const compoundKeyName = pk.join('_');
  const compoundValue = where[compoundKeyName];

  if (compoundValue && typeof compoundValue === 'object') {
    // Decompose the compound key
    const { [compoundKeyName]: _removed, ...rest } = where;
    return {
      ...rest,
      ...(compoundValue as Record<string, unknown>),
    };
  }

  return where;
}

/**
 * Builds a deterministic PK suffix for mangling unique fields.
 * For simple PKs: "__deleted_{pkValue}"
 * For compound PKs: "__deleted_{pk1Value}_{pk2Value}" (fields sorted alphabetically)
 */
function buildPkSuffix(modelName: string, record: Record<string, unknown>): string {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return '__deleted_unknown';

  const pkFields = Array.isArray(pk) ? [...pk].sort() : [pk];
  const pkValues = pkFields.map(field => String(record[field] ?? 'null'));
  return \`__deleted_\${pkValues.join('_')}\`;
}

/**
 * Gets the unique string fields for a model that need mangling on soft delete.
 */
function getUniqueStringFields(modelName: string): string[] {
  return UNIQUE_STRING_FIELDS[modelName] ?? [];
}

/**
 * Default max length for string fields (conservative estimate).
 * Most databases use 255 for varchar without explicit length.
 */
const DEFAULT_MAX_STRING_LENGTH = 255;

/**
 * Mangles unique string fields by appending the PK suffix.
 * Returns the update data object with mangled values, or throws if mangling would exceed max length.
 * Returns empty object if UNIQUE_STRATEGY is 'none'.
 */
function mangleUniqueFields(
  modelName: string,
  record: Record<string, unknown>,
  maxLength: number = DEFAULT_MAX_STRING_LENGTH
): Record<string, unknown> {
  // Skip mangling if strategy is 'none' or 'sentinel'
  if (UNIQUE_STRATEGY === 'none' || UNIQUE_STRATEGY === 'sentinel') return {};

  const uniqueFields = getUniqueStringFields(modelName);
  if (uniqueFields.length === 0) return {};

  const suffix = buildPkSuffix(modelName, record);
  const updates: Record<string, unknown> = {};

  for (const field of uniqueFields) {
    const currentValue = record[field];

    // Skip null/undefined values - they don't conflict with unique constraints
    if (currentValue === null || currentValue === undefined) {
      continue;
    }

    const strValue = String(currentValue);

    // Skip if already mangled (idempotent)
    if (strValue.endsWith(suffix)) {
      continue;
    }

    const mangledValue = strValue + suffix;

    // Check max length
    if (mangledValue.length > maxLength) {
      throw new Error(
        \`Cannot soft delete \${modelName}: mangling unique field "\${field}" would exceed max length \` +
        \`(\${mangledValue.length} > \${maxLength}). Original value: "\${strValue.substring(0, 50)}\${strValue.length > 50 ? '...' : ''}". \` +
        \`Consider using a partial unique index instead, or hard delete the record.\`
      );
    }

    updates[field] = mangledValue;
  }

  return updates;
}

/**
 * Unmangles unique string fields by removing the PK suffix.
 * Returns the update data object with unmangled values.
 * Returns empty object if UNIQUE_STRATEGY is 'none'.
 */
function unmangleUniqueFields(
  modelName: string,
  record: Record<string, unknown>
): Record<string, unknown> {
  // Skip unmangling if strategy is 'none' or 'sentinel' (nothing was mangled)
  if (UNIQUE_STRATEGY === 'none' || UNIQUE_STRATEGY === 'sentinel') return {};

  const uniqueFields = getUniqueStringFields(modelName);
  if (uniqueFields.length === 0) return {};

  const suffix = buildPkSuffix(modelName, record);
  const updates: Record<string, unknown> = {};

  for (const field of uniqueFields) {
    const currentValue = record[field];

    // Skip null/undefined values
    if (currentValue === null || currentValue === undefined) {
      continue;
    }

    const strValue = String(currentValue);

    // Only unmangle if it has the suffix
    if (strValue.endsWith(suffix)) {
      updates[field] = strValue.slice(0, -suffix.length);
    }
  }

  return updates;
}`.trim();
}

function emitSentinelFindUniqueHelper(): string {
  return `
/**
 * Transforms a findUnique where clause for sentinel strategy.
 * When using @@unique([email, deleted_at]), Prisma requires { email_deleted_at: { email, deleted_at } }.
 * This helper detects when the user passes { email: "foo" } and rewrites it to the compound form
 * with ACTIVE_DELETED_AT_VALUE injected for deleted_at.
 */
function transformSentinelFindUniqueWhere(
  where: Record<string, unknown>,
  modelName: string
): Record<string, unknown> {
  const compoundUniques = SENTINEL_COMPOUND_UNIQUES[modelName];
  if (!compoundUniques || compoundUniques.length === 0) return where;

  let result: Record<string, unknown> = { ...where };
  const consumedFields = new Set<string>();

  for (const { keyName, fields, deletedAtField } of compoundUniques) {
    // Skip if already in compound form
    if (keyName in result) continue;

    // Check if all non-deleted_at fields are present in result and not yet consumed
    const nonDeletedAtFields = fields.filter((f: string) => f !== deletedAtField);
    const allFieldsPresent = nonDeletedAtFields.every((f: string) => f in result && !consumedFields.has(f));
    if (!allFieldsPresent) continue;

    // Build the compound key value
    const compoundValue: Record<string, unknown> = {};
    for (const f of fields) {
      if (f === deletedAtField) {
        compoundValue[f] = ACTIVE_DELETED_AT_VALUE;
      } else {
        compoundValue[f] = result[f];
      }
    }

    // Track consumed fields and remove them from result
    for (const f of nonDeletedAtFields) {
      consumedFields.add(f);
    }

    const newResult: Record<string, unknown> = {};
    for (const [k, v] of Object.entries(result)) {
      if (!consumedFields.has(k)) {
        newResult[k] = v;
      }
    }
    newResult[keyName] = compoundValue;
    result = newResult;
  }

  return result;
}`.trim();
}

function emitInjectFiltersFunction(): string {
  return `
/**
 * Filter mode for soft-delete behavior
 * - 'exclude-deleted': Only non-deleted records (default)
 * - 'include-deleted': All records (deleted + active)
 * - 'only-deleted': Only deleted records
 */
type FilterMode = 'exclude-deleted' | 'include-deleted' | 'only-deleted';

/**
 * Gets the filter value for a given mode and deleted_at field
 */
function getModeFilter(mode: FilterMode, deletedAtField: string): Record<string, unknown> | null {
  switch (mode) {
    case 'exclude-deleted':
      return { [deletedAtField]: ACTIVE_DELETED_AT_VALUE };
    case 'only-deleted':
      return { [deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE } };
    case 'include-deleted':
      return null; // No filter
  }
}

/**
 * Recursively injects soft-delete filters into query args based on mode
 */
function injectFilters<T extends Record<string, unknown>>(
  args: T | undefined,
  modelName: string,
  mode: FilterMode = 'exclude-deleted'
): T {
  if (!args) {
    const deletedAtField = getDeletedAtField(modelName);
    if (deletedAtField && mode !== 'include-deleted') {
      const filter = getModeFilter(mode, deletedAtField);
      return { where: filter } as unknown as T;
    }
    return {} as T;
  }

  const result: Record<string, unknown> = { ...args };
  const deletedAtField = getDeletedAtField(modelName);

  // Inject into top-level where and process relation filters
  if (deletedAtField && mode !== 'include-deleted') {
    const existingWhere = (result.where as Record<string, unknown>) ?? {};
    const modeFilter = getModeFilter(mode, deletedAtField);

    result.where = injectIntoWhere(
      { ...existingWhere, ...modeFilter },
      modelName,
      mode
    );
  } else if (result.where) {
    result.where = injectIntoWhere(
      result.where as Record<string, unknown>,
      modelName,
      mode
    );
  }

  // Process include
  if (result.include && typeof result.include === 'object') {
    result.include = injectIntoRelations(
      result.include as Record<string, unknown>,
      modelName,
      mode
    );
  }

  // Process select
  if (result.select && typeof result.select === 'object') {
    result.select = injectIntoRelations(
      result.select as Record<string, unknown>,
      modelName,
      mode
    );
  }

  return result as T;
}

/**
 * Injects soft delete filters into where clauses, including relation filters
 */
function injectIntoWhere(
  where: Record<string, unknown>,
  parentModel: string,
  mode: FilterMode = 'exclude-deleted'
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(where)) {
    // Check if this is a relation filter (some, every, none, is, isNot)
    const relationModel = getRelationModel(parentModel, key);

    if (relationModel && value && typeof value === 'object') {
      const relationFilter = value as Record<string, unknown>;
      const deletedAtField = getDeletedAtField(relationModel);
      const processedFilter: Record<string, unknown> = {};

      for (const [filterKey, filterValue] of Object.entries(relationFilter)) {
        if (['some', 'every', 'none'].includes(filterKey) && filterValue && typeof filterValue === 'object') {
          // Inject deleted_at filter into the relation condition
          const innerWhere = filterValue as Record<string, unknown>;
          if (deletedAtField && mode !== 'include-deleted') {
            // Check if user already specified a filter on this field (Phase 4)
            if (!(deletedAtField in innerWhere)) {
              const modeFilter = getModeFilter(mode, deletedAtField);
              processedFilter[filterKey] = injectIntoWhere(
                { ...innerWhere, ...modeFilter },
                relationModel,
                mode
              );
            } else {
              // Respect user's explicit filter
              processedFilter[filterKey] = injectIntoWhere(innerWhere, relationModel, mode);
            }
          } else {
            processedFilter[filterKey] = injectIntoWhere(innerWhere, relationModel, mode);
          }
        } else if (['is', 'isNot'].includes(filterKey) && filterValue && typeof filterValue === 'object') {
          // Handle is/isNot for single relations
          const innerWhere = filterValue as Record<string, unknown>;
          if (deletedAtField && mode !== 'include-deleted') {
            // Check if user already specified a filter on this field (Phase 4)
            if (!(deletedAtField in innerWhere)) {
              const modeFilter = getModeFilter(mode, deletedAtField);
              processedFilter[filterKey] = injectIntoWhere(
                { ...innerWhere, ...modeFilter },
                relationModel,
                mode
              );
            } else {
              // Respect user's explicit filter
              processedFilter[filterKey] = injectIntoWhere(innerWhere, relationModel, mode);
            }
          } else {
            processedFilter[filterKey] = injectIntoWhere(innerWhere, relationModel, mode);
          }
        } else {
          processedFilter[filterKey] = filterValue;
        }
      }

      result[key] = processedFilter;
    } else if (key === 'AND' && Array.isArray(value)) {
      result[key] = value.map(v =>
        typeof v === 'object' && v !== null
          ? injectIntoWhere(v as Record<string, unknown>, parentModel, mode)
          : v
      );
    } else if (key === 'OR' && Array.isArray(value)) {
      result[key] = value.map(v =>
        typeof v === 'object' && v !== null
          ? injectIntoWhere(v as Record<string, unknown>, parentModel, mode)
          : v
      );
    } else if (key === 'NOT' && value && typeof value === 'object') {
      result[key] = Array.isArray(value)
        ? value.map(v => typeof v === 'object' && v !== null
            ? injectIntoWhere(v as Record<string, unknown>, parentModel, mode)
            : v)
        : injectIntoWhere(value as Record<string, unknown>, parentModel, mode);
    } else {
      result[key] = value;
    }
  }

  return result;
}

/**
 * Injects filters into relation includes/selects with mode propagation
 */
function injectIntoRelations(
  relations: Record<string, unknown>,
  parentModel: string,
  mode: FilterMode = 'exclude-deleted'
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(relations)) {
    // Handle _count specially
    if (key === '_count') {
      if (value === true) {
        // Simple _count: true - pass through
        result[key] = value;
      } else if (value && typeof value === 'object') {
        const countObj = value as Record<string, unknown>;
        if (countObj.select && typeof countObj.select === 'object') {
          // _count: { select: { posts: true, comments: true } }
          const countSelect = countObj.select as Record<string, unknown>;
          const filteredCountSelect: Record<string, unknown> = {};

          for (const [relName, relValue] of Object.entries(countSelect)) {
            const relationModel = getRelationModel(parentModel, relName);
            if (relationModel) {
              const deletedAtField = getDeletedAtField(relationModel);
              if (deletedAtField && mode !== 'include-deleted' && relValue === true) {
                // Add where filter based on mode
                const modeFilter = getModeFilter(mode, deletedAtField);
                filteredCountSelect[relName] = {
                  where: modeFilter,
                };
              } else if (deletedAtField && mode !== 'include-deleted' && relValue && typeof relValue === 'object') {
                // Merge with existing where - respect user's explicit filter (Phase 4)
                const existing = relValue as Record<string, unknown>;
                const existingWhere = (existing.where as Record<string, unknown>) ?? {};

                if (!(deletedAtField in existingWhere)) {
                  const modeFilter = getModeFilter(mode, deletedAtField);
                  filteredCountSelect[relName] = {
                    ...existing,
                    where: { ...existingWhere, ...modeFilter },
                  };
                } else {
                  // User specified explicit filter - respect it
                  filteredCountSelect[relName] = relValue;
                }
              } else {
                filteredCountSelect[relName] = relValue;
              }
            } else {
              filteredCountSelect[relName] = relValue;
            }
          }

          result[key] = { ...countObj, select: filteredCountSelect };
        } else {
          result[key] = value;
        }
      } else {
        result[key] = value;
      }
      continue;
    }

    // Look up the actual target model for this relation field
    const relationModel = getRelationModel(parentModel, key);
    const isList = isListRelation(parentModel, key);

    if (value === true) {
      // Simple include - inject filter if relation target is soft-deletable
      // Only add where clause for list relations (non-list relations don't support where in include)
      if (relationModel && isList) {
        const deletedAtField = getDeletedAtField(relationModel);
        if (deletedAtField && mode !== 'include-deleted') {
          const modeFilter = getModeFilter(mode, deletedAtField);
          result[key] = {
            where: modeFilter,
          };
        } else {
          result[key] = value;
        }
      } else {
        result[key] = value;
      }
    } else if (value && typeof value === 'object') {
      // Nested include with options
      const nested = { ...(value as Record<string, unknown>) };

      if (relationModel) {
        // Only add where clause for list relations
        if (isList) {
          const deletedAtField = getDeletedAtField(relationModel);
          if (deletedAtField && mode !== 'include-deleted') {
            const existingWhere = (nested.where as Record<string, unknown>) ?? {};

            // Phase 4: Only inject if user hasn't already specified this field
            if (!(deletedAtField in existingWhere)) {
              const modeFilter = getModeFilter(mode, deletedAtField);
              nested.where = { ...existingWhere, ...modeFilter };
            }
            // else: User's explicit filter takes precedence
          }
        }

        // Recursively process nested includes with mode propagation
        if (nested.include && typeof nested.include === 'object') {
          nested.include = injectIntoRelations(
            nested.include as Record<string, unknown>,
            relationModel,
            mode // Propagate mode down
          );
        }

        // Recursively process nested selects with mode propagation
        if (nested.select && typeof nested.select === 'object') {
          nested.select = injectIntoRelations(
            nested.select as Record<string, unknown>,
            relationModel,
            mode // Propagate mode down
          );
        }
      }

      result[key] = nested;
    } else {
      result[key] = value;
    }
  }

  return result;
}`.trim();
}

function emitSoftDeleteCascadeFunction(): string {
  return `
/**
 * Performs a soft delete with cascade (with its own transaction)
 */
async function softDeleteWithCascade(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>,
  deletedBy?: string
): Promise<{ count: number; cascaded: Record<string, number> }> {
  return prisma.$transaction(async (tx) => {
    return softDeleteWithCascadeInTx(tx, modelName, where, deletedBy);
  });
}

/**
 * Performs a soft delete with cascade within an existing transaction
 */
async function softDeleteWithCascadeInTx(
  tx: Prisma.TransactionClient,
  modelName: string,
  where: Record<string, unknown>,
  deletedBy?: string
): Promise<{ count: number; cascaded: Record<string, number> }> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  const now = new Date();
  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);

  // Find all records to delete
  const delegate = tx[lowerModelName as keyof typeof tx] as any;
  // Decompose compound key where clause if needed
  const decomposedWhere = decomposeCompoundKeyWhere(modelName, where);
  const records = await delegate.findMany({
    where: {
      ...decomposedWhere,
      [deletedAtField]: ACTIVE_DELETED_AT_VALUE, // Only active records
    },
  });

  if (records.length === 0) return { count: 0, cascaded: {} };

  // Get primary keys of records to delete
  const pkValues = records.map((r: Record<string, unknown>) =>
    extractPrimaryKey(modelName, r)
  );

  // Cascade to children (depth-first)
  const cascaded = await cascadeToChildren(tx, modelName, pkValues, now, deletedBy);

  // Update parent records
  const needsMangling = UNIQUE_STRATEGY === 'mangle' && (getUniqueStringFields(modelName).length > 0);

  if (needsMangling) {
    // Per-record update: mangle unique fields individually (each record has its own PK suffix)
    for (const record of records) {
      const pkVal = extractPrimaryKey(modelName, record);
      const mangledFields = mangleUniqueFields(modelName, record);

      const updateData: Record<string, unknown> = {
        ...mangledFields,
        [deletedAtField]: now,
      };

      const deletedByField = getDeletedByField(modelName);
      if (deletedByField && deletedBy) {
        updateData[deletedByField] = deletedBy;
      }

      await delegate.update({
        where: createPkWhereFromValues(modelName, pkVal),
        data: updateData,
      });
    }
  } else {
    // Bulk update: no mangling needed, use updateMany for all records at once
    const bulkUpdateData: Record<string, unknown> = {
      [deletedAtField]: now,
    };

    const deletedByField = getDeletedByField(modelName);
    if (deletedByField && deletedBy) {
      bulkUpdateData[deletedByField] = deletedBy;
    }

    const pkConditions = pkValues;
    await delegate.updateMany({
      where: { OR: pkConditions, [deletedAtField]: ACTIVE_DELETED_AT_VALUE },
      data: bulkUpdateData,
    });
  }

  return { count: records.length, cascaded };
}

/**
 * Gets the deleted_by field name for a model
 */
function getDeletedByField(modelName: string): string | null {
  return DELETED_BY_MODELS[modelName]?.deletedByField ?? null;
}

/**
 * Recursively cascades soft delete to children
 */
async function cascadeToChildren(
  tx: Prisma.TransactionClient,
  parentModel: string,
  parentPkValues: Record<string, unknown>[],
  deletedAt: Date,
  deletedBy?: string
): Promise<Record<string, number>> {
  const children = CASCADE_GRAPH[parentModel] ?? [];
  const cascaded: Record<string, number> = {};

  for (const child of children) {
    const lowerChildModel = child.model.charAt(0).toLowerCase() + child.model.slice(1);
    const childDelegate = tx[lowerChildModel as keyof typeof tx] as any;

    // Build where clause to find children - handle compound keys
    if (child.foreignKey.length === 0 || child.parentKey.length === 0) continue;

    // Build OR conditions for each parent record (supports compound keys)
    const childWhereConditions = parentPkValues.map((pkVal) => {
      const condition: Record<string, unknown> = {};
      for (let i = 0; i < child.foreignKey.length; i++) {
        const fkField = child.foreignKey[i];
        const pkField = child.parentKey[i];
        if (fkField && pkField) {
          condition[fkField] = pkVal[pkField];
        }
      }
      return condition;
    });

    // Find child records
    const childRecords = await childDelegate.findMany({
      where: {
        OR: childWhereConditions,
        ...(child.deletedAtField ? { [child.deletedAtField]: ACTIVE_DELETED_AT_VALUE } : {}),
      },
    });

    if (childRecords.length === 0) continue;

    // Get child PKs for recursive cascade
    const childPkValues = childRecords.map((r: Record<string, unknown>) =>
      extractPrimaryKey(child.model, r)
    );

    // Recurse to grandchildren first (depth-first)
    const grandchildCascaded = await cascadeToChildren(tx, child.model, childPkValues, deletedAt, deletedBy);

    // Merge grandchild results
    for (const [model, count] of Object.entries(grandchildCascaded)) {
      cascaded[model] = (cascaded[model] ?? 0) + count;
    }

    // Soft delete children (if soft-deletable)
    if (child.isSoftDeletable && child.deletedAtField) {
      const childNeedsMangling = UNIQUE_STRATEGY === 'mangle' && (getUniqueStringFields(child.model).length > 0);

      if (childNeedsMangling) {
        // Per-record update: mangle unique fields for each child individually
        for (const childRecord of childRecords) {
          const childPkVal = extractPrimaryKey(child.model, childRecord);
          const mangledFields = mangleUniqueFields(child.model, childRecord);

          const updateData: Record<string, unknown> = {
            ...mangledFields,
            [child.deletedAtField]: deletedAt,
          };

          if (child.deletedByField && deletedBy) {
            updateData[child.deletedByField] = deletedBy;
          }

          await childDelegate.update({
            where: createPkWhereFromValues(child.model, childPkVal),
            data: updateData,
          });
        }
      } else {
        // Bulk update: no mangling needed
        const bulkUpdateData: Record<string, unknown> = {
          [child.deletedAtField]: deletedAt,
        };

        if (child.deletedByField && deletedBy) {
          bulkUpdateData[child.deletedByField] = deletedBy;
        }

        const childPkConditions = childPkValues;
        await childDelegate.updateMany({
          where: { OR: childPkConditions, [child.deletedAtField]: ACTIVE_DELETED_AT_VALUE },
          data: bulkUpdateData,
        });
      }

      // Track the count for this child model
      cascaded[child.model] = (cascaded[child.model] ?? 0) + childRecords.length;
    }
  }

  return cascaded;
}

/**
 * Restores a soft-deleted record by setting deleted_at to null and unmangling unique fields.
 * Wrapped in a transaction for safety.
 * Throws if unmangled unique values would conflict with existing records.
 */
async function restoreRecord(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<Record<string, unknown> | null> {
  return prisma.$transaction(async (tx) => {
    return restoreRecordInTx(tx, modelName, where);
  });
}

/**
 * Restores a soft-deleted record within a transaction.
 */
async function restoreRecordInTx(
  tx: Prisma.TransactionClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<Record<string, unknown> | null> {
  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);
  const delegate = tx[lowerModelName as keyof typeof tx] as any;
  return restoreRecordWithDelegate(delegate, modelName, where);
}

/**
 * Core restore logic used by both restoreRecord and restoreRecordInTx.
 */
async function restoreRecordWithDelegate(
  delegate: any,
  modelName: string,
  where: Record<string, unknown>
): Promise<Record<string, unknown> | null> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  // Decompose compound key where clause if needed
  const decomposedWhere = decomposeCompoundKeyWhere(modelName, where);

  // Find the soft-deleted record
  const record = await delegate.findFirst({
    where: {
      ...decomposedWhere,
      [deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE }, // Only deleted records
    },
  });

  if (!record) return null;

  // Get unmangled field values
  const unmangledFields = unmangleUniqueFields(modelName, record);

  // Check for conflicts before restoring
  if (Object.keys(unmangledFields).length > 0) {
    for (const [field, value] of Object.entries(unmangledFields)) {
      const existing = await delegate.findFirst({
        where: {
          [field]: value,
          [deletedAtField]: ACTIVE_DELETED_AT_VALUE, // Only check against active records
        },
      });

      if (existing) {
        throw new Error(
          \`Cannot restore \${modelName}: unique field "\${field}" with value "\${value}" \` +
          \`already exists in an active record. Delete or modify the conflicting record first.\`
        );
      }
    }
  }

  // Restore the record
  const pkVal = extractPrimaryKey(modelName, record);
  const deletedByField = getDeletedByField(modelName);

  const updateData: Record<string, unknown> = {
    ...unmangledFields,
    [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
  };

  // Clear deleted_by if the model has that field
  if (deletedByField) {
    updateData[deletedByField] = null;
  }

  return delegate.update({
    where: createPkWhereFromValues(modelName, pkVal),
    data: updateData,
  });
}

/**
 * Restores multiple soft-deleted records.
 * Wrapped in a transaction for safety.
 * Throws if any unmangled unique values would conflict.
 */
async function restoreManyRecords(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ count: number }> {
  return prisma.$transaction(async (tx) => {
    return restoreManyInTx(tx, modelName, where);
  });
}

/**
 * Restores multiple soft-deleted records within a transaction.
 */
async function restoreManyInTx(
  tx: Prisma.TransactionClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ count: number }> {
  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);
  const delegate = tx[lowerModelName as keyof typeof tx] as any;
  return restoreManyWithDelegate(delegate, modelName, where);
}

/**
 * Core restoreMany logic used by both restoreManyRecords and restoreManyInTx.
 */
async function restoreManyWithDelegate(
  delegate: any,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ count: number }> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  // Find all soft-deleted records matching the criteria
  const records = await delegate.findMany({
    where: {
      ...where,
      [deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE },
    },
  });

  if (records.length === 0) return { count: 0 };

  const deletedByField = getDeletedByField(modelName);
  const needsUnmangling = UNIQUE_STRATEGY === 'mangle' && (getUniqueStringFields(modelName).length > 0);

  if (needsUnmangling) {
    // Per-record restore: unmangle unique fields individually and check conflicts
    let restoredCount = 0;

    for (const record of records) {
      const unmangledFields = unmangleUniqueFields(modelName, record);

      // Check for conflicts
      if (Object.keys(unmangledFields).length > 0) {
        for (const [field, value] of Object.entries(unmangledFields)) {
          const existing = await delegate.findFirst({
            where: {
              [field]: value,
              [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
            },
          });

          if (existing) {
            throw new Error(
              \`Cannot restore \${modelName}: unique field "\${field}" with value "\${value}" \` +
              \`already exists in an active record. Delete or modify the conflicting record first.\`
            );
          }
        }
      }

      const pkVal = extractPrimaryKey(modelName, record);
      const updateData: Record<string, unknown> = {
        ...unmangledFields,
        [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
      };

      if (deletedByField) {
        updateData[deletedByField] = null;
      }

      await delegate.update({
        where: createPkWhereFromValues(modelName, pkVal),
        data: updateData,
      });

      restoredCount++;
    }

    return { count: restoredCount };
  } else {
    // Bulk restore: no unmangling needed
    const bulkUpdateData: Record<string, unknown> = {
      [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
    };

    if (deletedByField) {
      bulkUpdateData[deletedByField] = null;
    }

    const pkConditions = records.map((r: Record<string, unknown>) =>
      extractPrimaryKey(modelName, r)
    );
    const result = await delegate.updateMany({
      where: { OR: pkConditions, [deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE } },
      data: bulkUpdateData,
    });

    return { count: result.count };
  }
}

/**
 * Restores a soft-deleted record AND all its cascade-deleted children.
 * Children are identified by having the same deleted_at timestamp as the parent.
 * Wrapped in a transaction.
 */
async function restoreWithCascade(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ record: Record<string, unknown> | null; cascaded: Record<string, number> }> {
  return prisma.$transaction(async (tx) => {
    return restoreWithCascadeInTx(tx, modelName, where);
  });
}

/**
 * Restores a soft-deleted record AND all its cascade-deleted children within a transaction.
 */
async function restoreWithCascadeInTx(
  tx: Prisma.TransactionClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ record: Record<string, unknown> | null; cascaded: Record<string, number> }> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);
  const delegate = tx[lowerModelName as keyof typeof tx] as any;

  // Decompose compound key where clause if needed
  const decomposedWhere = decomposeCompoundKeyWhere(modelName, where);

  // Find the soft-deleted record
  const record = await delegate.findFirst({
    where: {
      ...decomposedWhere,
      [deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE },
    },
  });

  if (!record) return { record: null, cascaded: {} };

  const deletedAt = record[deletedAtField];

  // Restore children first (depth-first, reverse of cascade delete)
  const pkVal = extractPrimaryKey(modelName, record);
  const cascaded = await restoreCascadeChildren(tx, modelName, [pkVal], deletedAt);

  // Now restore the parent record
  const unmangledFields = unmangleUniqueFields(modelName, record);

  // Check for conflicts
  if (Object.keys(unmangledFields).length > 0) {
    for (const [field, value] of Object.entries(unmangledFields)) {
      const existing = await delegate.findFirst({
        where: {
          [field]: value,
          [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
        },
      });

      if (existing) {
        throw new Error(
          \`Cannot restore \${modelName}: unique field "\${field}" with value "\${value}" \` +
          \`already exists in an active record. Delete or modify the conflicting record first.\`
        );
      }
    }
  }

  const deletedByField = getDeletedByField(modelName);
  const updateData: Record<string, unknown> = {
    ...unmangledFields,
    [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
  };

  if (deletedByField) {
    updateData[deletedByField] = null;
  }

  const restoredRecord = await delegate.update({
    where: createPkWhereFromValues(modelName, pkVal),
    data: updateData,
  });

  return { record: restoredRecord, cascaded };
}

/**
 * Recursively restores cascade-deleted children.
 * Only restores children with matching deleted_at timestamp.
 */
async function restoreCascadeChildren(
  tx: Prisma.TransactionClient,
  parentModel: string,
  parentPkValues: Record<string, unknown>[],
  deletedAt: Date
): Promise<Record<string, number>> {
  const children = CASCADE_GRAPH[parentModel] ?? [];
  const cascaded: Record<string, number> = {};

  for (const child of children) {
    if (!child.isSoftDeletable || !child.deletedAtField) continue;

    const lowerChildModel = child.model.charAt(0).toLowerCase() + child.model.slice(1);
    const childDelegate = tx[lowerChildModel as keyof typeof tx] as any;

    // Build where clause to find children
    if (child.foreignKey.length === 0 || child.parentKey.length === 0) continue;

    const childWhereConditions = parentPkValues.map((pkVal) => {
      const condition: Record<string, unknown> = {};
      for (let i = 0; i < child.foreignKey.length; i++) {
        const fkField = child.foreignKey[i];
        const pkField = child.parentKey[i];
        if (fkField && pkField) {
          condition[fkField] = pkVal[pkField];
        }
      }
      return condition;
    });

    // Find children with matching deleted_at timestamp
    const childRecords = await childDelegate.findMany({
      where: {
        OR: childWhereConditions,
        [child.deletedAtField]: deletedAt, // Must match exact timestamp
      },
    });

    if (childRecords.length === 0) continue;

    // Get child PKs for recursive restore
    const childPkValues = childRecords.map((r: Record<string, unknown>) =>
      extractPrimaryKey(child.model, r)
    );

    // Recurse to grandchildren first
    const grandchildCascaded = await restoreCascadeChildren(tx, child.model, childPkValues, deletedAt);

    // Merge grandchild results
    for (const [model, count] of Object.entries(grandchildCascaded)) {
      cascaded[model] = (cascaded[model] ?? 0) + count;
    }

    // Now restore the children
    const childNeedsUnmangling = UNIQUE_STRATEGY === 'mangle' && (getUniqueStringFields(child.model).length > 0);

    if (childNeedsUnmangling) {
      // Per-record restore: unmangle unique fields individually
      for (const childRecord of childRecords) {
        const childPkVal = extractPrimaryKey(child.model, childRecord);
        const unmangledFields = unmangleUniqueFields(child.model, childRecord);

        // Check for conflicts
        if (Object.keys(unmangledFields).length > 0) {
          for (const [field, value] of Object.entries(unmangledFields)) {
            const existing = await childDelegate.findFirst({
              where: {
                [field]: value,
                [child.deletedAtField]: ACTIVE_DELETED_AT_VALUE,
              },
            });

            if (existing) {
              throw new Error(
                \`Cannot restore \${child.model}: unique field "\${field}" with value "\${value}" \` +
                \`already exists in an active record.\`
              );
            }
          }
        }

        const updateData: Record<string, unknown> = {
          ...unmangledFields,
          [child.deletedAtField]: ACTIVE_DELETED_AT_VALUE,
        };

        if (child.deletedByField) {
          updateData[child.deletedByField] = null;
        }

        await childDelegate.update({
          where: createPkWhereFromValues(child.model, childPkVal),
          data: updateData,
        });
      }
    } else {
      // Bulk restore: no unmangling needed
      const bulkUpdateData: Record<string, unknown> = {
        [child.deletedAtField]: ACTIVE_DELETED_AT_VALUE,
      };

      if (child.deletedByField) {
        bulkUpdateData[child.deletedByField] = null;
      }

      const childPkConditions = childPkValues;
      await childDelegate.updateMany({
        where: { OR: childPkConditions, [child.deletedAtField]: deletedAt },
        data: bulkUpdateData,
      });
    }

    // Track the count for this child model
    cascaded[child.model] = (cascaded[child.model] ?? 0) + childRecords.length;
  }

  return cascaded;
}

/**
 * Previews a soft delete with cascade (read-only, no writes)
 */
async function previewSoftDelete(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ wouldDelete: Record<string, number> }> {
  return prisma.$transaction(async (tx) => {
    return previewSoftDeleteInTx(tx, modelName, where);
  });
}

/**
 * Previews a soft delete with cascade within an existing transaction (read-only)
 */
async function previewSoftDeleteInTx(
  tx: Prisma.TransactionClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ wouldDelete: Record<string, number> }> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);
  const delegate = tx[lowerModelName as keyof typeof tx] as any;
  const decomposedWhere = decomposeCompoundKeyWhere(modelName, where);

  // Find all records that would be deleted
  const records = await delegate.findMany({
    where: {
      ...decomposedWhere,
      [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
    },
  });

  if (records.length === 0) return { wouldDelete: {} };

  const pkValues = records.map((r: Record<string, unknown>) =>
    extractPrimaryKey(modelName, r)
  );

  // Preview cascade to children (read-only)
  const cascaded = await previewCascadeChildren(tx, modelName, pkValues);

  const wouldDelete: Record<string, number> = { [modelName]: records.length };
  for (const [model, count] of Object.entries(cascaded)) {
    wouldDelete[model] = (wouldDelete[model] ?? 0) + count;
  }
  return { wouldDelete };
}

/**
 * Recursively previews cascade soft delete to children (read-only, no writes)
 */
async function previewCascadeChildren(
  tx: Prisma.TransactionClient,
  parentModel: string,
  parentPkValues: Record<string, unknown>[]
): Promise<Record<string, number>> {
  const children = CASCADE_GRAPH[parentModel] ?? [];
  const cascaded: Record<string, number> = {};

  for (const child of children) {
    const lowerChildModel = child.model.charAt(0).toLowerCase() + child.model.slice(1);
    const childDelegate = tx[lowerChildModel as keyof typeof tx] as any;

    if (child.foreignKey.length === 0 || child.parentKey.length === 0) continue;

    const childWhereConditions = parentPkValues.map((pkVal) => {
      const condition: Record<string, unknown> = {};
      for (let i = 0; i < child.foreignKey.length; i++) {
        const fkField = child.foreignKey[i];
        const pkField = child.parentKey[i];
        if (fkField && pkField) {
          condition[fkField] = pkVal[pkField];
        }
      }
      return condition;
    });

    const childRecords = await childDelegate.findMany({
      where: {
        OR: childWhereConditions,
        ...(child.deletedAtField ? { [child.deletedAtField]: ACTIVE_DELETED_AT_VALUE } : {}),
      },
    });

    if (childRecords.length === 0) continue;

    const childPkValues = childRecords.map((r: Record<string, unknown>) =>
      extractPrimaryKey(child.model, r)
    );

    // Recurse to grandchildren (read-only)
    const grandchildCascaded = await previewCascadeChildren(tx, child.model, childPkValues);

    for (const [model, count] of Object.entries(grandchildCascaded)) {
      cascaded[model] = (cascaded[model] ?? 0) + count;
    }

    // Count soft-deletable children (but don't update them)
    if (child.isSoftDeletable && child.deletedAtField) {
      cascaded[child.model] = (cascaded[child.model] ?? 0) + childRecords.length;
    }
  }

  return cascaded;
}`.trim();
}

function emitModelDelegate(model: ParsedModel, options: EmitRuntimeOptions): string {
  const name = model.name;
  const lowerName = toLowerFirst(name);

  if (model.isSoftDeletable && model.deletedAtField !== null) {
    const deletedAtField = model.deletedAtField;
    const simple = isSimpleModel(model, options);

    // Common parts shared between simple and complex delegates
    const findUniqueMethods = options.uniqueStrategy === 'sentinel'
      ? `
    findUnique: ((...args: any[]) => {
      const filtered = injectFilters(args[0], '${name}');
      if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${name}');
      return original.findUnique(filtered);
    }) as PrismaClient['${lowerName}']['findUnique'],
    findUniqueOrThrow: ((...args: any[]) => {
      const filtered = injectFilters(args[0], '${name}');
      if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${name}');
      return original.findUniqueOrThrow(filtered);
    }) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`
      : `
    findUnique: ((...args: any[]) => original.findUnique(injectFilters(args[0], '${name}'))) as PrismaClient['${lowerName}']['findUnique'],
    findUniqueOrThrow: ((...args: any[]) => original.findUniqueOrThrow(injectFilters(args[0], '${name}'))) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`;

    const readMethods = `
    // Wrapped methods with filter injection
    findMany: ((...args: any[]) => original.findMany(injectFilters(args[0], '${name}'))) as PrismaClient['${lowerName}']['findMany'],
    findFirst: ((...args: any[]) => original.findFirst(injectFilters(args[0], '${name}'))) as PrismaClient['${lowerName}']['findFirst'],
    findFirstOrThrow: ((...args: any[]) => original.findFirstOrThrow(injectFilters(args[0], '${name}'))) as PrismaClient['${lowerName}']['findFirstOrThrow'],${findUniqueMethods}
    count: ((...args: any[]) => original.count(injectFilters(args[0], '${name}'))) as PrismaClient['${lowerName}']['count'],
    aggregate: ((...args: any[]) => original.aggregate(injectFilters(args[0], '${name}'))) as PrismaClient['${lowerName}']['aggregate'],
    groupBy: ((...args: any[]) => original.groupBy(injectFilters(args[0], '${name}'))) as PrismaClient['${lowerName}']['groupBy'],`;

    const createMethods = options.uniqueStrategy === 'sentinel'
      ? `
    // Create methods - inject sentinel value for deleted_at
    create: ((args: any) => original.create({ ...args, data: { ...args.data, ['${deletedAtField}']: args.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE } })) as PrismaClient['${lowerName}']['create'],
    createMany: ((args: any) => {
      const data = Array.isArray(args.data)
        ? args.data.map((d: any) => ({ ...d, ['${deletedAtField}']: d['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }))
        : { ...args.data, ['${deletedAtField}']: args.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE };
      return original.createMany({ ...args, data });
    }) as PrismaClient['${lowerName}']['createMany'],
    createManyAndReturn: ((args: any) => {
      const data = Array.isArray(args.data)
        ? args.data.map((d: any) => ({ ...d, ['${deletedAtField}']: d['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }))
        : { ...args.data, ['${deletedAtField}']: args.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE };
      return original.createManyAndReturn({ ...args, data });
    }) as PrismaClient['${lowerName}']['createManyAndReturn'],`
      : `
    // Pass-through methods (no filter needed for creates)
    create: ((args: any) => original.create(args)) as PrismaClient['${lowerName}']['create'],
    createMany: ((args: any) => original.createMany(args)) as PrismaClient['${lowerName}']['createMany'],
    createManyAndReturn: ((args: any) => original.createManyAndReturn(args)) as PrismaClient['${lowerName}']['createManyAndReturn'],`;

    const upsertMethod = options.uniqueStrategy === 'sentinel'
      ? `
    upsert: ((args: any) => {
      const filtered = injectFilters({
        ...args,
        create: { ...args.create, ['${deletedAtField}']: args.create?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }
      }, '${name}');
      if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${name}');
      return original.upsert(filtered);
    }) as PrismaClient['${lowerName}']['upsert'],`
      : `
    upsert: ((args: any) => original.upsert(injectFilters(args, '${name}'))) as PrismaClient['${lowerName}']['upsert'],`;

    const writeMethods = `${createMethods}
    update: ((args: any) => original.update(injectFilters(args, '${name}'))) as PrismaClient['${lowerName}']['update'],
    updateMany: ((args: any) => original.updateMany(injectFilters(args, '${name}'))) as PrismaClient['${lowerName}']['updateMany'],
    updateManyAndReturn: ((args: any) => original.updateManyAndReturn(injectFilters(args, '${name}'))) as PrismaClient['${lowerName}']['updateManyAndReturn'],${upsertMethod}
    fields: original.fields,`;

    const restoreMethods = `
    // Restore methods
    restore: (async (args: any) => {
      return restoreRecord(prisma, '${name}', args.where);
    }) as Safe${name}Delegate['restore'],
    restoreMany: (async (args: any) => {
      return restoreManyRecords(prisma, '${name}', args.where);
    }) as Safe${name}Delegate['restoreMany'],
    restoreCascade: (async (args: any) => {
      const { record, cascaded } = await restoreWithCascade(prisma, '${name}', args.where);
      return { record, cascaded };
    }) as Safe${name}Delegate['restoreCascade'],`;

    const hardDeleteMethods = `
    // Hard delete (intentionally ugly name to discourage use)
    __dangerousHardDelete: ((args: any) => original.delete(args)) as PrismaClient['${lowerName}']['delete'],
    __dangerousHardDeleteMany: ((args: any) => original.deleteMany(args)) as PrismaClient['${lowerName}']['deleteMany'],`;

    const includingDeletedMethods = `
    // Access raw delegate without soft-delete filtering
    includingDeleted: {
      findMany: ((args?: any) => original.findMany(args)) as PrismaClient['${lowerName}']['findMany'],
      findFirst: ((args?: any) => original.findFirst(args)) as PrismaClient['${lowerName}']['findFirst'],
      findFirstOrThrow: ((args?: any) => original.findFirstOrThrow(args)) as PrismaClient['${lowerName}']['findFirstOrThrow'],
      findUnique: ((args?: any) => original.findUnique(args)) as PrismaClient['${lowerName}']['findUnique'],
      findUniqueOrThrow: ((args?: any) => original.findUniqueOrThrow(args)) as PrismaClient['${lowerName}']['findUniqueOrThrow'],
      count: ((args?: any) => original.count(args)) as PrismaClient['${lowerName}']['count'],
      aggregate: ((args?: any) => original.aggregate(args)) as PrismaClient['${lowerName}']['aggregate'],
      groupBy: ((args?: any) => original.groupBy(args)) as PrismaClient['${lowerName}']['groupBy'],
    },`;

    let softDeleteMethods: string;
    let previewMethod: string;

    if (simple) {
      // Fast path: use updateMany directly (no transaction, no per-record updates)
      const deletedByUpdate = model.deletedByField !== null
        ? `\n      const deletedByField = ${JSON.stringify(model.deletedByField)};\n      if (deletedByField && deletedBy) {\n        updateData[deletedByField] = deletedBy;\n      }`
        : '';

      softDeleteMethods = `
    // Soft delete methods (fast path - no cascade children, no unique mangling)
    softDelete: (async (args: any) => {
      const { deletedBy, ...rest } = args;
      const decomposedWhere = decomposeCompoundKeyWhere('${name}', rest.where);
      const now = new Date();
      const updateData: Record<string, unknown> = { ['${deletedAtField}']: now };${deletedByUpdate}
      await original.updateMany({
        where: { ...decomposedWhere, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },
        data: updateData,
      });
      const record = await original.findFirst({ where: decomposedWhere });
      return { record, cascaded: {} };
    }) as Safe${name}Delegate['softDelete'],
    softDeleteMany: (async (args: any) => {
      const { deletedBy, ...rest } = args;
      const updateData: Record<string, unknown> = { ['${deletedAtField}']: new Date() };${deletedByUpdate}
      const result = await original.updateMany({
        where: { ...rest.where, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },
        data: updateData,
      });
      return { count: result.count, cascaded: {} };
    }) as Safe${name}Delegate['softDeleteMany'],`;

      previewMethod = `
    // Preview soft delete (read-only)
    softDeletePreview: (async (args: any) => {
      const count = await original.count({
        where: { ...args.where, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },
      });
      return { wouldDelete: count > 0 ? { ['${name}']: count } : {} };
    }) as Safe${name}Delegate['softDeletePreview'],`;
    } else {
      // Complex path: use softDeleteWithCascade (transaction, per-record updates)
      softDeleteMethods = `
    // Soft delete methods (with cascade support)
    // NOTE: deletedBy requirement is enforced at COMPILE-TIME only via TypeScript types.
    // There is no runtime validation - callers bypassing TypeScript (e.g., plain JS) must
    // ensure they pass deletedBy for models with deleted_by fields.
    softDelete: (async (args: any) => {
      const { deletedBy, ...rest } = args;
      const { cascaded } = await softDeleteWithCascade(prisma, '${name}', rest.where, deletedBy);
      // Decompose compound key for findFirst
      const decomposedWhere = decomposeCompoundKeyWhere('${name}', rest.where);
      const record = await original.findFirst({ where: decomposedWhere });
      return { record, cascaded };
    }) as Safe${name}Delegate['softDelete'],
    softDeleteMany: (async (args: any) => {
      const { deletedBy, ...rest } = args;
      const { count, cascaded } = await softDeleteWithCascade(prisma, '${name}', rest.where, deletedBy);
      return { count, cascaded };
    }) as Safe${name}Delegate['softDeleteMany'],`;

      previewMethod = `
    // Preview soft delete with cascade (read-only)
    softDeletePreview: (async (args: any) => {
      return previewSoftDelete(prisma, '${name}', args.where);
    }) as Safe${name}Delegate['softDeletePreview'],`;
    }

    return `
/**
 * Creates a safe delegate for ${name} with soft-delete support
 */
function create${name}Delegate(prisma: PrismaClient): Safe${name}Delegate {
  const original = prisma.${lowerName};

  return {${readMethods}
${writeMethods}
${softDeleteMethods}
${previewMethod}
${restoreMethods}
${hardDeleteMethods}
${includingDeletedMethods}
  };
}`.trim();
  }

  return `
/**
 * Creates a delegate for ${name} (no soft-delete)
 */
function create${name}Delegate(prisma: PrismaClient): Safe${name}Delegate {
  return prisma.${lowerName};
}`.trim();
}

function emitIncludingDeletedClient(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Creates a client that includes soft-deleted records with filter propagation');
  lines.push(' */');
  lines.push('function createIncludingDeletedClient(prisma: PrismaClient): IncludingDeletedClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    if (model.isSoftDeletable && model.deletedAtField !== null) {
      // Soft-deletable models need wrapped methods to propagate 'include-deleted' mode
      lines.push(`    ${lowerName}: {`);
      lines.push(`      findMany: ((...args: any[]) => prisma.${lowerName}.findMany(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findMany'],`);
      lines.push(`      findFirst: ((...args: any[]) => prisma.${lowerName}.findFirst(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findFirst'],`);
      lines.push(`      findFirstOrThrow: ((...args: any[]) => prisma.${lowerName}.findFirstOrThrow(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findFirstOrThrow'],`);
      lines.push(`      findUnique: ((...args: any[]) => prisma.${lowerName}.findUnique(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findUnique'],`);
      lines.push(`      findUniqueOrThrow: ((...args: any[]) => prisma.${lowerName}.findUniqueOrThrow(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      lines.push(`      count: ((...args: any[]) => prisma.${lowerName}.count(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['count'],`);
      lines.push(`      aggregate: ((...args: any[]) => prisma.${lowerName}.aggregate(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['aggregate'],`);
      lines.push(`      groupBy: ((...args: any[]) => prisma.${lowerName}.groupBy(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['groupBy'],`);
      lines.push(`    },`);
    } else {
      // Non-soft-deletable models can use raw delegate
      lines.push(`    ${lowerName}: prisma.${lowerName},`);
    }
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitOnlyDeletedClient(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Creates a client that queries only soft-deleted records with filter propagation');
  lines.push(' */');
  lines.push('function createOnlyDeletedClient(prisma: PrismaClient): OnlyDeletedClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    if (model.isSoftDeletable && model.deletedAtField !== null) {
      const lowerName = toLowerFirst(model.name);
      lines.push(`    ${lowerName}: {`);
      lines.push(`      findMany: ((...args: any[]) => prisma.${lowerName}.findMany(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['findMany'],`);
      lines.push(`      findFirst: ((...args: any[]) => prisma.${lowerName}.findFirst(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['findFirst'],`);
      lines.push(`      findFirstOrThrow: ((...args: any[]) => prisma.${lowerName}.findFirstOrThrow(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['findFirstOrThrow'],`);
      lines.push(`      findUnique: ((...args: any[]) => prisma.${lowerName}.findUnique(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['findUnique'],`);
      lines.push(`      findUniqueOrThrow: ((...args: any[]) => prisma.${lowerName}.findUniqueOrThrow(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      lines.push(`      count: ((...args: any[]) => prisma.${lowerName}.count(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['count'],`);
      lines.push(`      aggregate: ((...args: any[]) => prisma.${lowerName}.aggregate(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['aggregate'],`);
      lines.push(`      groupBy: ((...args: any[]) => prisma.${lowerName}.groupBy(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['groupBy'],`);
      lines.push(`    },`);
    }
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitTransactionWrapper(schema: ParsedSchema, options: EmitRuntimeOptions): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Wraps a transaction client with soft-delete filtering and full API');
  lines.push(' */');
  lines.push('function wrapTransactionClient(tx: Prisma.TransactionClient): SafeTransactionClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    if (model.isSoftDeletable && model.deletedAtField !== null) {
      const simple = isSimpleModel(model, options);
      const deletedAtField = model.deletedAtField;
      lines.push(`    ${lowerName}: {`);
      // Read operations with filter injection
      lines.push(`      findMany: ((...args: any[]) => tx.${lowerName}.findMany(injectFilters(args[0], '${model.name}'))) as PrismaClient['${lowerName}']['findMany'],`);
      lines.push(`      findFirst: ((...args: any[]) => tx.${lowerName}.findFirst(injectFilters(args[0], '${model.name}'))) as PrismaClient['${lowerName}']['findFirst'],`);
      lines.push(`      findFirstOrThrow: ((...args: any[]) => tx.${lowerName}.findFirstOrThrow(injectFilters(args[0], '${model.name}'))) as PrismaClient['${lowerName}']['findFirstOrThrow'],`);
      if (options.uniqueStrategy === 'sentinel') {
        lines.push(`      findUnique: ((...args: any[]) => {`);
        lines.push(`        const filtered = injectFilters(args[0], '${model.name}');`);
        lines.push(`        if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${model.name}');`);
        lines.push(`        return tx.${lowerName}.findUnique(filtered);`);
        lines.push(`      }) as PrismaClient['${lowerName}']['findUnique'],`);
        lines.push(`      findUniqueOrThrow: ((...args: any[]) => {`);
        lines.push(`        const filtered = injectFilters(args[0], '${model.name}');`);
        lines.push(`        if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${model.name}');`);
        lines.push(`        return tx.${lowerName}.findUniqueOrThrow(filtered);`);
        lines.push(`      }) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      } else {
        lines.push(`      findUnique: ((...args: any[]) => tx.${lowerName}.findUnique(injectFilters(args[0], '${model.name}'))) as PrismaClient['${lowerName}']['findUnique'],`);
        lines.push(`      findUniqueOrThrow: ((...args: any[]) => tx.${lowerName}.findUniqueOrThrow(injectFilters(args[0], '${model.name}'))) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      }
      lines.push(`      count: ((...args: any[]) => tx.${lowerName}.count(injectFilters(args[0], '${model.name}'))) as PrismaClient['${lowerName}']['count'],`);
      lines.push(`      aggregate: ((...args: any[]) => tx.${lowerName}.aggregate(injectFilters(args[0], '${model.name}'))) as PrismaClient['${lowerName}']['aggregate'],`);
      lines.push(`      groupBy: ((...args: any[]) => tx.${lowerName}.groupBy(injectFilters(args[0], '${model.name}'))) as PrismaClient['${lowerName}']['groupBy'],`);
      // Write operations
      if (options.uniqueStrategy === 'sentinel') {
        lines.push(`      create: ((args: any) => tx.${lowerName}.create({ ...args, data: { ...args.data, ['${deletedAtField}']: args.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE } })) as PrismaClient['${lowerName}']['create'],`);
        lines.push(`      createMany: ((args: any) => {`);
        lines.push(`        const data = Array.isArray(args.data)`);
        lines.push(`          ? args.data.map((d: any) => ({ ...d, ['${deletedAtField}']: d['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }))`);
        lines.push(`          : { ...args.data, ['${deletedAtField}']: args.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE };`);
        lines.push(`        return tx.${lowerName}.createMany({ ...args, data });`);
        lines.push(`      }) as PrismaClient['${lowerName}']['createMany'],`);
        lines.push(`      createManyAndReturn: ((args: any) => {`);
        lines.push(`        const data = Array.isArray(args.data)`);
        lines.push(`          ? args.data.map((d: any) => ({ ...d, ['${deletedAtField}']: d['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }))`);
        lines.push(`          : { ...args.data, ['${deletedAtField}']: args.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE };`);
        lines.push(`        return tx.${lowerName}.createManyAndReturn({ ...args, data });`);
        lines.push(`      }) as PrismaClient['${lowerName}']['createManyAndReturn'],`);
      } else {
        lines.push(`      create: ((args: any) => tx.${lowerName}.create(args)) as PrismaClient['${lowerName}']['create'],`);
        lines.push(`      createMany: ((args: any) => tx.${lowerName}.createMany(args)) as PrismaClient['${lowerName}']['createMany'],`);
        lines.push(`      createManyAndReturn: ((args: any) => tx.${lowerName}.createManyAndReturn(args)) as PrismaClient['${lowerName}']['createManyAndReturn'],`);
      }
      lines.push(`      update: ((args: any) => tx.${lowerName}.update(injectFilters(args, '${model.name}'))) as PrismaClient['${lowerName}']['update'],`);
      lines.push(`      updateMany: ((args: any) => tx.${lowerName}.updateMany(injectFilters(args, '${model.name}'))) as PrismaClient['${lowerName}']['updateMany'],`);
      lines.push(`      updateManyAndReturn: ((args: any) => tx.${lowerName}.updateManyAndReturn(injectFilters(args, '${model.name}'))) as PrismaClient['${lowerName}']['updateManyAndReturn'],`);
      if (options.uniqueStrategy === 'sentinel') {
        lines.push(`      upsert: ((args: any) => {`);
        lines.push(`        const filtered = injectFilters({`);
        lines.push(`          ...args,`);
        lines.push(`          create: { ...args.create, ['${deletedAtField}']: args.create?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }`);
        lines.push(`        }, '${model.name}');`);
        lines.push(`        if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${model.name}');`);
        lines.push(`        return tx.${lowerName}.upsert(filtered);`);
        lines.push(`      }) as PrismaClient['${lowerName}']['upsert'],`);
      } else {
        lines.push(`      upsert: ((args: any) => tx.${lowerName}.upsert(injectFilters(args, '${model.name}'))) as PrismaClient['${lowerName}']['upsert'],`);
      }
      lines.push(`      fields: tx.${lowerName}.fields,`);

      if (simple) {
        // Fast path: use updateMany directly
        lines.push(`      softDelete: (async (args: any) => {`);
        lines.push(`        const { deletedBy, ...rest } = args;`);
        lines.push(`        const decomposedWhere = decomposeCompoundKeyWhere('${model.name}', rest.where);`);
        lines.push(`        const now = new Date();`);
        lines.push(`        const updateData: Record<string, unknown> = { ['${deletedAtField}']: now };`);
        if (model.deletedByField !== null) {
          lines.push(`        const deletedByField = ${JSON.stringify(model.deletedByField)};`);
          lines.push(`        if (deletedByField && deletedBy) {`);
          lines.push(`          updateData[deletedByField] = deletedBy;`);
          lines.push(`        }`);
        }
        lines.push(`        await tx.${lowerName}.updateMany({`);
        lines.push(`          where: { ...decomposedWhere, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },`);
        lines.push(`          data: updateData,`);
        lines.push(`        });`);
        lines.push(`        const record = await tx.${lowerName}.findFirst({ where: decomposedWhere });`);
        lines.push(`        return { record, cascaded: {} };`);
        lines.push(`      }) as Safe${model.name}Delegate['softDelete'],`);
        lines.push(`      softDeleteMany: (async (args: any) => {`);
        lines.push(`        const { deletedBy, ...rest } = args;`);
        lines.push(`        const updateData: Record<string, unknown> = { ['${deletedAtField}']: new Date() };`);
        if (model.deletedByField !== null) {
          lines.push(`        const deletedByField = ${JSON.stringify(model.deletedByField)};`);
          lines.push(`        if (deletedByField && deletedBy) {`);
          lines.push(`          updateData[deletedByField] = deletedBy;`);
          lines.push(`        }`);
        }
        lines.push(`        const result = await tx.${lowerName}.updateMany({`);
        lines.push(`          where: { ...rest.where, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },`);
        lines.push(`          data: updateData,`);
        lines.push(`        });`);
        lines.push(`        return { count: result.count, cascaded: {} };`);
        lines.push(`      }) as Safe${model.name}Delegate['softDeleteMany'],`);
        // Preview (fast path - simple count)
        lines.push(`      softDeletePreview: (async (args: any) => {`);
        lines.push(`        const count = await tx.${lowerName}.count({`);
        lines.push(`          where: { ...args.where, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },`);
        lines.push(`        });`);
        lines.push(`        return { wouldDelete: count > 0 ? { ['${model.name}']: count } : {} };`);
        lines.push(`      }) as Safe${model.name}Delegate['softDeletePreview'],`);
      } else {
        // Complex path: use softDeleteWithCascadeInTx
        lines.push(`      softDelete: (async (args: any) => {`);
        lines.push(`        const { deletedBy, ...rest } = args;`);
        lines.push(`        const { cascaded } = await softDeleteWithCascadeInTx(tx, '${model.name}', rest.where, deletedBy);`);
        lines.push(`        const decomposedWhere = decomposeCompoundKeyWhere('${model.name}', rest.where);`);
        lines.push(`        const record = await tx.${lowerName}.findFirst({ where: decomposedWhere });`);
        lines.push(`        return { record, cascaded };`);
        lines.push(`      }) as Safe${model.name}Delegate['softDelete'],`);
        lines.push(`      softDeleteMany: (async (args: any) => {`);
        lines.push(`        const { deletedBy, ...rest } = args;`);
        lines.push(`        const { count, cascaded } = await softDeleteWithCascadeInTx(tx, '${model.name}', rest.where, deletedBy);`);
        lines.push(`        return { count, cascaded };`);
        lines.push(`      }) as Safe${model.name}Delegate['softDeleteMany'],`);
        // Preview (complex path - cascade preview)
        lines.push(`      softDeletePreview: (async (args: any) => {`);
        lines.push(`        return previewSoftDeleteInTx(tx, '${model.name}', args.where);`);
        lines.push(`      }) as Safe${model.name}Delegate['softDeletePreview'],`);
      }

      // Restore methods
      lines.push(`      restore: (async (args: any) => {`);
      lines.push(`        return restoreRecordInTx(tx, '${model.name}', args.where);`);
      lines.push(`      }) as Safe${model.name}Delegate['restore'],`);
      lines.push(`      restoreMany: (async (args: any) => {`);
      lines.push(`        return restoreManyInTx(tx, '${model.name}', args.where);`);
      lines.push(`      }) as Safe${model.name}Delegate['restoreMany'],`);
      lines.push(`      restoreCascade: (async (args: any) => {`);
      lines.push(`        const { record, cascaded } = await restoreWithCascadeInTx(tx, '${model.name}', args.where);`);
      lines.push(`        return { record, cascaded };`);
      lines.push(`      }) as Safe${model.name}Delegate['restoreCascade'],`);
      // Hard delete methods (intentionally scary names)
      lines.push(`      __dangerousHardDelete: ((args: any) => tx.${lowerName}.delete(args)) as PrismaClient['${lowerName}']['delete'],`);
      lines.push(`      __dangerousHardDeleteMany: ((args: any) => tx.${lowerName}.deleteMany(args)) as PrismaClient['${lowerName}']['deleteMany'],`);
      // includingDeleted sub-object for raw access
      lines.push(`      includingDeleted: {`);
      lines.push(`        findMany: ((args?: any) => tx.${lowerName}.findMany(args)) as PrismaClient['${lowerName}']['findMany'],`);
      lines.push(`        findFirst: ((args?: any) => tx.${lowerName}.findFirst(args)) as PrismaClient['${lowerName}']['findFirst'],`);
      lines.push(`        findFirstOrThrow: ((args?: any) => tx.${lowerName}.findFirstOrThrow(args)) as PrismaClient['${lowerName}']['findFirstOrThrow'],`);
      lines.push(`        findUnique: ((args?: any) => tx.${lowerName}.findUnique(args)) as PrismaClient['${lowerName}']['findUnique'],`);
      lines.push(`        findUniqueOrThrow: ((args?: any) => tx.${lowerName}.findUniqueOrThrow(args)) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      lines.push(`        count: ((args?: any) => tx.${lowerName}.count(args)) as PrismaClient['${lowerName}']['count'],`);
      lines.push(`        aggregate: ((args?: any) => tx.${lowerName}.aggregate(args)) as PrismaClient['${lowerName}']['aggregate'],`);
      lines.push(`        groupBy: ((args?: any) => tx.${lowerName}.groupBy(args)) as PrismaClient['${lowerName}']['groupBy'],`);
      lines.push(`      },`);
      lines.push(`    },`);
    } else {
      lines.push(`    ${lowerName}: tx.${lowerName},`);
    }
  }

  // Add $onlyDeleted escape hatch
  lines.push('');
  lines.push('    /** Query only soft-deleted records with filter propagation */');
  lines.push('    $onlyDeleted: {');
  for (const model of schema.models) {
    if (model.isSoftDeletable && model.deletedAtField !== null) {
      const lowerName = toLowerFirst(model.name);
      lines.push(`      ${lowerName}: {`);
      lines.push(`        findMany: ((...args: any[]) => tx.${lowerName}.findMany(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['findMany'],`);
      lines.push(`        findFirst: ((...args: any[]) => tx.${lowerName}.findFirst(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['findFirst'],`);
      lines.push(`        findFirstOrThrow: ((...args: any[]) => tx.${lowerName}.findFirstOrThrow(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['findFirstOrThrow'],`);
      lines.push(`        findUnique: ((...args: any[]) => tx.${lowerName}.findUnique(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['findUnique'],`);
      lines.push(`        findUniqueOrThrow: ((...args: any[]) => tx.${lowerName}.findUniqueOrThrow(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      lines.push(`        count: ((...args: any[]) => tx.${lowerName}.count(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['count'],`);
      lines.push(`        aggregate: ((...args: any[]) => tx.${lowerName}.aggregate(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['aggregate'],`);
      lines.push(`        groupBy: ((...args: any[]) => tx.${lowerName}.groupBy(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['groupBy'],`);
      lines.push(`      },`);
    }
  }
  lines.push('    },');

  // Add $includingDeleted escape hatch
  lines.push('');
  lines.push('    /** Query including soft-deleted records with filter propagation */');
  lines.push('    $includingDeleted: {');
  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    if (model.isSoftDeletable && model.deletedAtField !== null) {
      lines.push(`      ${lowerName}: {`);
      lines.push(`        findMany: ((...args: any[]) => tx.${lowerName}.findMany(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findMany'],`);
      lines.push(`        findFirst: ((...args: any[]) => tx.${lowerName}.findFirst(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findFirst'],`);
      lines.push(`        findFirstOrThrow: ((...args: any[]) => tx.${lowerName}.findFirstOrThrow(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findFirstOrThrow'],`);
      lines.push(`        findUnique: ((...args: any[]) => tx.${lowerName}.findUnique(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findUnique'],`);
      lines.push(`        findUniqueOrThrow: ((...args: any[]) => tx.${lowerName}.findUniqueOrThrow(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      lines.push(`        count: ((...args: any[]) => tx.${lowerName}.count(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['count'],`);
      lines.push(`        aggregate: ((...args: any[]) => tx.${lowerName}.aggregate(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['aggregate'],`);
      lines.push(`        groupBy: ((...args: any[]) => tx.${lowerName}.groupBy(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['groupBy'],`);
      lines.push(`      },`);
    } else {
      lines.push(`      ${lowerName}: tx.${lowerName},`);
    }
  }
  lines.push('    },');
  lines.push('');
  lines.push('    // Raw query methods');
  lines.push("    $queryRaw: (tx.$queryRaw as any).bind(tx) as PrismaClient['$queryRaw'],");
  lines.push("    $executeRaw: (tx.$executeRaw as any).bind(tx) as PrismaClient['$executeRaw'],");
  lines.push("    $queryRawUnsafe: (tx.$queryRawUnsafe as any).bind(tx) as PrismaClient['$queryRawUnsafe'],");
  lines.push("    $executeRawUnsafe: (tx.$executeRawUnsafe as any).bind(tx) as PrismaClient['$executeRawUnsafe'],");

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitWrapperFunction(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Wraps a PrismaClient with soft-delete functionality');
  lines.push(' */');
  lines.push('export function wrapPrismaClient(prisma: PrismaClient): SafePrismaClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    lines.push(`    ${lowerName}: create${model.name}Delegate(prisma),`);
  }

  lines.push('');
  lines.push('    $connect: () => prisma.$connect(),');
  lines.push('    $disconnect: () => prisma.$disconnect(),');
  lines.push('    $on: (prisma.$on as any).bind(prisma) as PrismaClient[\'$on\'],');
  lines.push('    $transaction: ((arg: any, options?: any) => {');
  lines.push('      // Handle both sequential and interactive transactions');
  lines.push('      if (typeof arg === "function") {');
  lines.push('        // Interactive transaction - wrap the callback to provide safe delegates');
  lines.push('        return prisma.$transaction((tx: Prisma.TransactionClient) => {');
  lines.push('          const wrappedTx = wrapTransactionClient(tx);');
  lines.push('          return arg(wrappedTx);');
  lines.push('        }, options);');
  lines.push('      }');
  lines.push('      // Sequential transaction (array of promises)');
  lines.push('      return (prisma.$transaction as any)(arg, options);');
  lines.push("    }) as SafePrismaClient['$transaction'],");
  lines.push('    $extends: (prisma.$extends as any).bind(prisma) as PrismaClient[\'$extends\'],');
  lines.push('    $queryRaw: (prisma.$queryRaw as any).bind(prisma) as PrismaClient[\'$queryRaw\'],');
  lines.push('    $executeRaw: (prisma.$executeRaw as any).bind(prisma) as PrismaClient[\'$executeRaw\'],');
  lines.push('    $queryRawUnsafe: (prisma.$queryRawUnsafe as any).bind(prisma) as PrismaClient[\'$queryRawUnsafe\'],');
  lines.push('    $executeRawUnsafe: (prisma.$executeRawUnsafe as any).bind(prisma) as PrismaClient[\'$executeRawUnsafe\'],');
  lines.push('    $prisma: prisma,');
  lines.push('    $includingDeleted: createIncludingDeletedClient(prisma),');
  lines.push('    $onlyDeleted: createOnlyDeletedClient(prisma),');
  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function toLowerFirst(str: string): string {
  const first = str.charAt(0);
  return first.toLowerCase() + str.slice(1);
}
