import type { AuditOnlyModel, ParsedModel, ParsedSchema, SoftDeletableModel } from '../dmmf-parser.js';
import type { CascadeGraph } from '../cascade-graph.js';
import { emitAuditHelpers, type AuditTableConfig } from './emit-audit.js';

/**
 * Strategy for handling unique constraints on soft delete.
 */
type UniqueStrategy = 'mangle' | 'none' | 'sentinel';

interface EmitRuntimeOptions {
  uniqueStrategy: UniqueStrategy;
  cascadeGraph: CascadeGraph;
  auditTable?: AuditTableConfig | null;
}

/**
 * Determines if a model can use the fast path (single updateMany) for soft deletes.
 * Qualifying criteria: no cascade children AND (uniqueStrategy='none' OR no unique string fields).
 */
function isSimpleModel(model: ParsedModel, options: EmitRuntimeOptions): boolean {
  const children = options.cascadeGraph[model.name] ?? [];
  if (children.length > 0) return false;
  if (options.uniqueStrategy === 'none' || options.uniqueStrategy === 'sentinel') return true;
  return model.uniqueStringFields.length === 0;
}

/**
 * Generates the runtime wrapper functions
 * @param schema - The parsed Prisma schema
 * @param clientImportPath - The relative import path to the generated Prisma client (e.g., '../client')
 * @param options - Configuration options
 */
export function emitRuntime(
  schema: ParsedSchema,
  clientImportPath: string,
  options: EmitRuntimeOptions = { uniqueStrategy: 'mangle', cascadeGraph: {} },
): string {
  const lines: string[] = [];

  lines.push('/* eslint-disable */');
  lines.push('// @ts-nocheck');
  lines.push('// Auto-generated by prisma-safe-delete');
  lines.push('// Do not edit this file manually');
  lines.push('');
  lines.push(`import { type PrismaClient, Prisma } from '${clientImportPath}';`);
  lines.push("import { CASCADE_GRAPH } from './cascade-graph.js';");
  const delegateTypeImports = schema.models.map(m => `Safe${m.name}Delegate`).join(', ');
  const hasAuditModels = schema.models.some(m => m.isAuditable);
  const auditTypeImports = hasAuditModels && options.auditTable !== undefined && options.auditTable !== null ? ', WrapOptions, AuditContext' : '';
  lines.push(`import type { SafePrismaClient, SafeTransactionClient, IncludingDeletedClient, OnlyDeletedClient, ${delegateTypeImports}${auditTypeImports} } from './types.js';`);
  lines.push('');

  // Emit model metadata
  lines.push('/** Metadata about soft-deletable models */');
  lines.push('const SOFT_DELETABLE_MODELS: Record<string, { deletedAtField: string }> = {');
  for (const model of schema.models) {
    if (model.isSoftDeletable) {
      lines.push(`  ${model.name}: { deletedAtField: ${JSON.stringify(model.deletedAtField)} },`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit deleted_by metadata
  lines.push('/** Metadata about models with deleted_by fields */');
  lines.push('const DELETED_BY_MODELS: Record<string, { deletedByField: string }> = {');
  for (const model of schema.models) {
    if (model.deletedByField !== null) {
      lines.push(`  ${model.name}: { deletedByField: ${JSON.stringify(model.deletedByField)} },`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit primary key metadata
  lines.push('/** Primary key configuration per model */');
  lines.push('const PRIMARY_KEYS: Record<string, string | string[]> = {');
  for (const model of schema.models) {
    const pkValue = JSON.stringify(model.primaryKey);
    lines.push(`  ${model.name}: ${pkValue},`);
  }
  lines.push('};');
  lines.push('');

  // Emit relation models mapping (for proper relation target lookup)
  lines.push('/** Maps model.field to target model name */');
  lines.push('const RELATION_MODELS: Record<string, string> = {');
  for (const model of schema.models) {
    for (const relation of model.relations) {
      lines.push(`  '${model.name}.${relation.name}': '${relation.type}',`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit relation list metadata (for knowing if a relation supports where clause)
  lines.push('/** Maps model.field to whether it is a list relation */');
  lines.push('const RELATION_IS_LIST: Record<string, boolean> = {');
  for (const model of schema.models) {
    for (const relation of model.relations) {
      lines.push(`  '${model.name}.${relation.name}': ${String(relation.isList)},`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit to-one relations to soft-deletable models (for post-processing)
  lines.push('/** To-one relations pointing to soft-deletable models, per parent model */');
  lines.push('const TO_ONE_SOFT_DELETABLE_RELATIONS: Record<string, string[]> = {');
  for (const model of schema.models) {
    const toOneFields: string[] = [];
    for (const relation of model.relations) {
      if (relation.isList) continue;
      const target = schema.modelMap.get(relation.type);
      if (target?.isSoftDeletable === true) {
        toOneFields.push(relation.name);
      }
    }
    if (toOneFields.length > 0) {
      lines.push(`  ${model.name}: ${JSON.stringify(toOneFields)},`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit unique string fields metadata (for mangling on soft delete)
  lines.push('/**');
  lines.push(' * String fields with unique constraints that need mangling on soft delete.');
  lines.push(' * On soft delete, these fields get "__deleted_{pk}" appended to free up the unique value.');
  lines.push(' * For compound PKs, the suffix is "__deleted_{pk1}_{pk2}" (fields joined with underscore, sorted alphabetically).');
  lines.push(' */');
  lines.push('const UNIQUE_STRING_FIELDS: Record<string, string[]> = {');
  for (const model of schema.models) {
    if (model.uniqueStringFields.length > 0) {
      lines.push(`  ${model.name}: ${JSON.stringify(model.uniqueStringFields)},`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit unique constraints metadata (for compound unique conflict checking on restore)
  lines.push('/**');
  lines.push(' * Structured unique constraint info per model.');
  lines.push(' * Each entry lists the fields in that constraint. Compound constraints have multiple fields.');
  lines.push(' * Used for accurate conflict checking during restore (avoids false positives on compound uniques).');
  lines.push(' */');
  lines.push('const UNIQUE_CONSTRAINTS: Record<string, { fields: string[] }[]> = {');
  for (const model of schema.models) {
    // Only emit constraints for models that have unique string fields (those are the ones that get mangled/unmangled)
    const relevantConstraints = model.uniqueConstraints.filter(c =>
      c.fields.some(f => model.uniqueStringFields.includes(f))
    );
    if (relevantConstraints.length > 0) {
      const entries = relevantConstraints.map(c =>
        `{ fields: ${JSON.stringify(c.fields)} }`
      );
      lines.push(`  ${model.name}: [${entries.join(', ')}],`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit unique strategy constant
  lines.push('/**');
  lines.push(' * Strategy for handling unique constraints on soft delete.');
  lines.push(" * - 'mangle': Append \"__deleted_{pk}\" suffix to unique string fields");
  lines.push(" * - 'none': Skip mangling (user handles uniqueness via partial indexes)");
  lines.push(" * - 'sentinel': Use a far-future sentinel date instead of NULL for active records");
  lines.push(' */');
  lines.push(`const UNIQUE_STRATEGY: 'mangle' | 'none' | 'sentinel' = '${options.uniqueStrategy}';`);
  lines.push('');

  // Emit ACTIVE_DELETED_AT_VALUE constant
  lines.push('/**');
  lines.push(' * The value used to represent "active" (not deleted) in the deleted_at column.');
  lines.push(" * - For mangle/none strategies: null (deleted_at IS NULL means active)");
  lines.push(" * - For sentinel strategy: far-future date (deleted_at = sentinel means active)");
  lines.push(' */');
  if (options.uniqueStrategy === 'sentinel') {
    lines.push("const ACTIVE_DELETED_AT_VALUE: Date = new Date('9999-12-31T00:00:00.000Z');");
  } else {
    lines.push('const ACTIVE_DELETED_AT_VALUE: null = null;');
  }
  lines.push('');

  // Emit SENTINEL_COMPOUND_UNIQUES metadata (only for sentinel strategy)
  if (options.uniqueStrategy === 'sentinel') {
    lines.push('/**');
    lines.push(' * Compound unique constraints that include deleted_at, per model.');
    lines.push(' * Used to transform findUnique where clauses for sentinel strategy.');
    lines.push(' */');
    lines.push('const SENTINEL_COMPOUND_UNIQUES: Record<string, { keyName: string; fields: string[]; deletedAtField: string }[]> = {');
    for (const model of schema.models) {
      if (!model.isSoftDeletable) continue;
      const sentinelUniques = model.uniqueConstraints.filter(c => c.includesDeletedAt && c.compoundKeyName !== undefined);
      if (sentinelUniques.length === 0) continue;
      const entries = sentinelUniques.map(c =>
        `{ keyName: ${JSON.stringify(c.compoundKeyName)}, fields: ${JSON.stringify(c.fields)}, deletedAtField: ${JSON.stringify(model.deletedAtField)} }`
      );
      lines.push(`  ${model.name}: [${entries.join(', ')}],`);
    }
    lines.push('};');
    lines.push('');
  }

  // Emit helper functions
  lines.push(emitHelperFunctions());
  lines.push('');

  // Emit sentinel findUnique transformation helper (only for sentinel strategy)
  if (options.uniqueStrategy === 'sentinel') {
    lines.push(emitSentinelFindUniqueHelper());
    lines.push('');
  }

  // Emit to-one post-processing functions
  lines.push(emitToOnePostProcessing());
  lines.push('');

  // Emit injectFilters function
  lines.push(emitInjectFiltersFunction());
  lines.push('');

  // Emit audit helpers (if audit is configured)
  const hasAudit = options.auditTable !== undefined && options.auditTable !== null && schema.models.some((m) => m.isAuditable);
  if (hasAudit && options.auditTable !== undefined && options.auditTable !== null) {
    lines.push(emitAuditHelpers(schema, options.auditTable));
    lines.push('');
  }

  // Emit soft delete cascade function
  // softDeleteWithCascade (the wrapper) is no longer needed — all callers now use softDeleteWithCascadeInTx directly.
  // softDeleteWithCascadeInTx is always needed for any complex-path model (used by both main delegate and TX wrapper).
  lines.push(emitSoftDeleteCascadeFunction(false, hasAudit));
  lines.push('');

  // Emit model delegate wrappers
  for (const model of schema.models) {
    lines.push(emitModelDelegate(model, options, hasAudit));
    lines.push('');
  }

  // Emit includingDeleted and onlyDeleted clients
  lines.push(emitIncludingDeletedClient(schema));
  lines.push('');
  lines.push(emitOnlyDeletedClient(schema));
  lines.push('');

  // Emit transaction wrapper
  lines.push(emitTransactionWrapper(schema, options, hasAudit));
  lines.push('');

  // Emit main wrapper function
  lines.push(emitWrapperFunction(schema, hasAudit));
  lines.push('');

  // Emit filter helper utilities (exported for user use)
  lines.push(emitFilterHelpers());

  return lines.join('\n');
}

/**
 * Emits user-facing helper utilities for manual filtering
 */
function emitFilterHelpers(): string {
  return `
/**
 * Helper to filter for only soft-deleted records in where clauses.
 * Useful for nested relation filters where $onlyDeleted can't be used.
 *
 * @example
 * safePrisma.users.findMany({
 *   where: {
 *     memberships: {
 *       some: onlyDeleted('Membership', { organization_id: orgId })
 *     }
 *   }
 * });
 */
export function onlyDeleted<T extends Record<string, unknown>>(
  modelName: string,
  where: T = {} as T
): T & Record<string, unknown> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) return where;
  return { ...where, [deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE } } as T & Record<string, unknown>;
}

/**
 * Helper to filter for only non-deleted (active) records in where clauses.
 * This is the default behavior, but can be useful for explicit overrides.
 *
 * @example
 * safePrisma.$onlyDeleted.users.findFirst({
 *   include: {
 *     posts: {
 *       where: excludeDeleted('Post', { published: true })
 *     }
 *   }
 * });
 */
export function excludeDeleted<T extends Record<string, unknown>>(
  modelName: string,
  where: T = {} as T
): T & Record<string, unknown> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) return where;
  return { ...where, [deletedAtField]: ACTIVE_DELETED_AT_VALUE } as T & Record<string, unknown>;
}

/**
 * Helper to include all records (deleted + active) in where clauses.
 * This is a no-op function for clarity/documentation purposes.
 *
 * @example
 * safePrisma.users.findMany({
 *   where: includingDeleted({ status: 'premium' })
 * });
 */
export function includingDeleted<T extends Record<string, unknown>>(
  where: T = {} as T
): T {
  return where;
}`.trim();
}

function emitHelperFunctions(): string {
  return `
/**
 * Throws P2025 if softDelete matched 0 records, matching Prisma's delete behavior.
 */
function throwIfNotFound(count: number, modelName: string): void {
  if (count === 0) {
    throw new Prisma.PrismaClientKnownRequestError(
      'An operation failed because it depends on one or more records that were required but not found. Record to soft delete does not exist.',
      { code: 'P2025', clientVersion: 'prisma-safe-delete', meta: { modelName, cause: 'Record to soft delete does not exist.' } }
    );
  }
}

/**
 * Gets the deleted_at field name for a model
 */
function getDeletedAtField(modelName: string): string | null {
  return SOFT_DELETABLE_MODELS[modelName]?.deletedAtField ?? null;
}

/**
 * Extracts primary key values from a record
 */
function extractPrimaryKey(modelName: string, record: Record<string, unknown>): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return {};

  const keys = Array.isArray(pk) ? pk : [pk];
  const result: Record<string, unknown> = {};

  for (const key of keys) {
    result[key] = record[key];
  }

  return result;
}

/**
 * Creates a where clause for updating a record by its primary key values.
 * For simple PKs: { id: 'value' }
 * For compound PKs: { pk1_pk2: { pk1: 'v1', pk2: 'v2' } }
 */
function createPkWhereFromValues(modelName: string, pkValues: Record<string, unknown>): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return pkValues;

  if (Array.isArray(pk)) {
    // Compound key - Prisma expects { pk1_pk2: { pk1: v1, pk2: v2 } }
    const compoundName = pk.join('_');
    return { [compoundName]: pkValues };
  }

  // Simple key - just return the values as-is
  return pkValues;
}

/**
 * Gets the target model name for a relation field
 */
function getRelationModel(parentModel: string, fieldName: string): string | null {
  return RELATION_MODELS[\`\${parentModel}.\${fieldName}\`] ?? null;
}

/**
 * Checks if a relation is a list (to-many) relation
 */
function isListRelation(parentModel: string, fieldName: string): boolean {
  return RELATION_IS_LIST[\`\${parentModel}.\${fieldName}\`] ?? false;
}

/**
 * Gets all list (to-many) relation field names for a model
 */
function getListRelationsForModel(modelName: string): string[] {
  const prefix = modelName + '.';
  const relations: string[] = [];
  for (const key of Object.keys(RELATION_IS_LIST)) {
    if (key.startsWith(prefix) && RELATION_IS_LIST[key]) {
      relations.push(key.slice(prefix.length));
    }
  }
  return relations;
}

/**
 * Decomposes a compound key where clause into individual fields.
 * Converts { tenantId_userId: { tenantId: 'x', userId: 'y' } } into { tenantId: 'x', userId: 'y' }
 */
function decomposeCompoundKeyWhere(
  modelName: string,
  where: Record<string, unknown>
): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk || !Array.isArray(pk)) {
    return where;
  }

  // Check if where contains the compound key name
  const compoundKeyName = pk.join('_');
  const compoundValue = where[compoundKeyName];

  if (compoundValue && typeof compoundValue === 'object') {
    // Decompose the compound key
    const { [compoundKeyName]: _removed, ...rest } = where;
    return {
      ...rest,
      ...(compoundValue as Record<string, unknown>),
    };
  }

  return where;
}

/**
 * Builds a deterministic PK suffix for mangling unique fields.
 * For simple PKs: "__deleted_{pkValue}"
 * For compound PKs: "__deleted_{pk1Value}_{pk2Value}" (fields sorted alphabetically)
 */
function buildPkSuffix(modelName: string, record: Record<string, unknown>): string {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return '__deleted_unknown';

  const pkFields = Array.isArray(pk) ? [...pk].sort() : [pk];
  const pkValues = pkFields.map(field => String(record[field] ?? 'null'));
  return \`__deleted_\${pkValues.join('_')}\`;
}

/**
 * Gets the unique string fields for a model that need mangling on soft delete.
 */
function getUniqueStringFields(modelName: string): string[] {
  return UNIQUE_STRING_FIELDS[modelName] ?? [];
}

/**
 * Default max length for string fields (conservative estimate).
 * Most databases use 255 for varchar without explicit length.
 */
const DEFAULT_MAX_STRING_LENGTH = 255;

/**
 * Mangles unique string fields by appending the PK suffix.
 * Returns the update data object with mangled values, or throws if mangling would exceed max length.
 * Returns empty object if UNIQUE_STRATEGY is 'none'.
 */
function mangleUniqueFields(
  modelName: string,
  record: Record<string, unknown>,
  maxLength: number = DEFAULT_MAX_STRING_LENGTH
): Record<string, unknown> {
  // Skip mangling if strategy is 'none' or 'sentinel'
  if (UNIQUE_STRATEGY === 'none' || UNIQUE_STRATEGY === 'sentinel') return {};

  const uniqueFields = getUniqueStringFields(modelName);
  if (uniqueFields.length === 0) return {};

  const suffix = buildPkSuffix(modelName, record);
  const updates: Record<string, unknown> = {};

  for (const field of uniqueFields) {
    const currentValue = record[field];

    // Skip null/undefined values - they don't conflict with unique constraints
    if (currentValue === null || currentValue === undefined) {
      continue;
    }

    const strValue = String(currentValue);

    const mangledValue = strValue + suffix;

    // Check max length
    if (mangledValue.length > maxLength) {
      throw new Error(
        \`Cannot soft delete \${modelName}: mangling unique field "\${field}" would exceed max length \` +
        \`(\${mangledValue.length} > \${maxLength}, original length: \${strValue.length}). \` +
        \`Consider using a partial unique index instead, or hard delete the record.\`
      );
    }

    updates[field] = mangledValue;
  }

  return updates;
}

/**
 * Unmangles unique string fields by removing the PK suffix.
 * Returns the update data object with unmangled values.
 * Returns empty object if UNIQUE_STRATEGY is 'none'.
 */
function unmangleUniqueFields(
  modelName: string,
  record: Record<string, unknown>
): Record<string, unknown> {
  // Skip unmangling if strategy is 'none' or 'sentinel' (nothing was mangled)
  if (UNIQUE_STRATEGY === 'none' || UNIQUE_STRATEGY === 'sentinel') return {};

  const uniqueFields = getUniqueStringFields(modelName);
  if (uniqueFields.length === 0) return {};

  const suffix = buildPkSuffix(modelName, record);
  const updates: Record<string, unknown> = {};

  for (const field of uniqueFields) {
    const currentValue = record[field];

    // Skip null/undefined values
    if (currentValue === null || currentValue === undefined) {
      continue;
    }

    const strValue = String(currentValue);

    // Only unmangle if it has the suffix
    if (strValue.endsWith(suffix)) {
      updates[field] = strValue.slice(0, -suffix.length);
    }
  }

  return updates;
}`.trim();
}

function emitSentinelFindUniqueHelper(): string {
  return `
/**
 * Transforms a findUnique where clause for sentinel strategy.
 * When using @@unique([email, deleted_at]), Prisma requires { email_deleted_at: { email, deleted_at } }.
 * This helper detects when the user passes { email: "foo" } and rewrites it to the compound form
 * with ACTIVE_DELETED_AT_VALUE injected for deleted_at.
 */
function transformSentinelFindUniqueWhere(
  where: Record<string, unknown>,
  modelName: string
): Record<string, unknown> {
  const compoundUniques = SENTINEL_COMPOUND_UNIQUES[modelName];
  if (!compoundUniques || compoundUniques.length === 0) return where;

  let result: Record<string, unknown> = { ...where };
  const consumedFields = new Set<string>();

  for (const { keyName, fields, deletedAtField } of compoundUniques) {
    // Skip if already in compound form
    if (keyName in result) continue;

    // Check if all non-deleted_at fields are present in result and not yet consumed
    const nonDeletedAtFields = fields.filter((f: string) => f !== deletedAtField);
    const allFieldsPresent = nonDeletedAtFields.every((f: string) => f in result && !consumedFields.has(f));
    if (!allFieldsPresent) continue;

    // Build the compound key value
    const compoundValue: Record<string, unknown> = {};
    for (const f of fields) {
      if (f === deletedAtField) {
        compoundValue[f] = ACTIVE_DELETED_AT_VALUE;
      } else {
        compoundValue[f] = result[f];
      }
    }

    // Track consumed fields and remove them from result
    for (const f of nonDeletedAtFields) {
      consumedFields.add(f);
    }

    const newResult: Record<string, unknown> = {};
    for (const [k, v] of Object.entries(result)) {
      if (!consumedFields.has(k)) {
        newResult[k] = v;
      }
    }
    newResult[keyName] = compoundValue;
    result = newResult;
  }

  return result;
}`.trim();
}

function emitToOnePostProcessing(): string {
  return `
/**
 * Checks if a record is soft-deleted by examining its deleted_at field.
 * Handles both null-based (mangle/none) and sentinel strategies.
 */
function isRecordDeleted(record: Record<string, unknown>, deletedAtField: string): boolean {
  const value = record[deletedAtField];
  if (ACTIVE_DELETED_AT_VALUE === null) {
    // mangle/none strategy: active records have null deleted_at
    return value !== null && value !== undefined;
  }
  // sentinel strategy: active records have the sentinel date
  const sentinel = ACTIVE_DELETED_AT_VALUE as Date;
  if (value instanceof Date) {
    return value.getTime() !== sentinel.getTime();
  }
  // Handle string dates from DB
  if (typeof value === 'string') {
    return new Date(value).getTime() !== sentinel.getTime();
  }
  return false;
}

/**
 * Gets to-one relation field names for a model that point to soft-deletable targets.
 */
function getToOneSoftDeletableRelations(modelName: string): string[] {
  return TO_ONE_SOFT_DELETABLE_RELATIONS[modelName] ?? [];
}

/**
 * Recursively nullifies to-one relations pointing to soft-deleted records.
 * Walks the result tree and sets deleted to-one relations to null.
 */
function nullifyDeletedToOneRelations(
  result: unknown,
  modelName: string,
  args: Record<string, unknown> | undefined
): unknown {
  if (result === null || result === undefined) return result;

  if (Array.isArray(result)) {
    return result.map(item => nullifyDeletedToOneRelations(item, modelName, args));
  }

  if (typeof result !== 'object') return result;

  const record = result as Record<string, unknown>;
  const toOneRelations = getToOneSoftDeletableRelations(modelName);
  const includeOrSelect = (args?.include ?? args?.select) as Record<string, unknown> | undefined;

  const processed: Record<string, unknown> = { ...record };

  for (const field of toOneRelations) {
    if (!(field in processed)) continue;
    const related = processed[field];
    if (related === null || related === undefined) continue;
    if (typeof related !== 'object') continue;

    const relatedRecord = related as Record<string, unknown>;
    const targetModel = getRelationModel(modelName, field);
    if (!targetModel) continue;

    const deletedAtField = getDeletedAtField(targetModel);
    if (!deletedAtField) continue;

    // Check if this related record is deleted
    if (deletedAtField in relatedRecord && isRecordDeleted(relatedRecord, deletedAtField)) {
      processed[field] = null;
      continue;
    }

    // Recurse into live related records
    const nestedArgs = includeOrSelect?.[field];
    const nestedArgsObj = (nestedArgs && typeof nestedArgs === 'object') ? nestedArgs as Record<string, unknown> : undefined;
    processed[field] = nullifyDeletedToOneRelations(relatedRecord, targetModel, nestedArgsObj);
  }

  // Also recurse into to-many relations (they may have nested to-one relations)
  if (includeOrSelect) {
    for (const [field, spec] of Object.entries(includeOrSelect)) {
      if (toOneRelations.includes(field)) continue; // Already handled above
      if (!(field in processed)) continue;
      const value = processed[field];
      if (!value || typeof value !== 'object') continue;

      const targetModel = getRelationModel(modelName, field);
      if (!targetModel) continue;

      const nestedArgs = (spec && typeof spec === 'object') ? spec as Record<string, unknown> : undefined;
      processed[field] = nullifyDeletedToOneRelations(value, targetModel, nestedArgs);
    }
  }

  return processed;
}

/**
 * Pre-processes args to ensure deleted_at is available in select clauses
 * for to-one relations to soft-deletable models (so post-processing can check it).
 * Returns the modified args and a set of paths where deleted_at was injected.
 */
function injectDeletedAtIntoToOneSelects<T extends Record<string, unknown> | undefined>(
  args: T,
  modelName: string
): { args: T; injectedPaths: string[] } {
  if (!args) return { args, injectedPaths: [] };

  const injectedPaths: string[] = [];
  const processed = injectDeletedAtRecursive(args, modelName, '', injectedPaths);
  return { args: processed as T, injectedPaths };
}

function injectDeletedAtRecursive(
  args: Record<string, unknown>,
  modelName: string,
  pathPrefix: string,
  injectedPaths: string[]
): Record<string, unknown> {
  const result = { ...args };
  const toOneRelations = getToOneSoftDeletableRelations(modelName);

  // Process include
  if (result.include && typeof result.include === 'object') {
    const include = { ...(result.include as Record<string, unknown>) };
    for (const field of toOneRelations) {
      if (!(field in include)) continue;
      const spec = include[field];
      const targetModel = getRelationModel(modelName, field);
      if (!targetModel) continue;
      const deletedAtField = getDeletedAtField(targetModel);
      if (!deletedAtField) continue;

      const fieldPath = pathPrefix ? pathPrefix + '.' + field : field;

      if (spec && typeof spec === 'object') {
        const nested = spec as Record<string, unknown>;
        if (nested.select && typeof nested.select === 'object') {
          // select present — ensure deleted_at is included
          const select = { ...(nested.select as Record<string, unknown>) };
          if (!(deletedAtField in select)) {
            select[deletedAtField] = true;
            injectedPaths.push(fieldPath + '.' + deletedAtField);
          }
          include[field] = injectDeletedAtRecursive(
            { ...nested, select },
            targetModel,
            fieldPath,
            injectedPaths
          );
        } else {
          // No select — deleted_at will be fetched by default
          include[field] = injectDeletedAtRecursive(nested, targetModel, fieldPath, injectedPaths);
        }
      }
      // If spec === true, all fields are fetched, no injection needed
    }

    // Also recurse into non-to-one relations (to-many) that might have nested to-one
    for (const [field, spec] of Object.entries(include)) {
      if (toOneRelations.includes(field)) continue;
      if (!spec || typeof spec !== 'object') continue;
      const targetModel = getRelationModel(modelName, field);
      if (!targetModel) continue;
      const fieldPath = pathPrefix ? pathPrefix + '.' + field : field;
      include[field] = injectDeletedAtRecursive(spec as Record<string, unknown>, targetModel, fieldPath, injectedPaths);
    }

    result.include = include;
  }

  // Process select (for relations within select)
  if (result.select && typeof result.select === 'object') {
    const select = { ...(result.select as Record<string, unknown>) };
    for (const field of toOneRelations) {
      if (!(field in select)) continue;
      const spec = select[field];
      const targetModel = getRelationModel(modelName, field);
      if (!targetModel) continue;
      const deletedAtField = getDeletedAtField(targetModel);
      if (!deletedAtField) continue;

      const fieldPath = pathPrefix ? pathPrefix + '.' + field : field;

      if (spec && typeof spec === 'object') {
        const nested = spec as Record<string, unknown>;
        if (nested.select && typeof nested.select === 'object') {
          const innerSelect = { ...(nested.select as Record<string, unknown>) };
          if (!(deletedAtField in innerSelect)) {
            innerSelect[deletedAtField] = true;
            injectedPaths.push(fieldPath + '.' + deletedAtField);
          }
          select[field] = injectDeletedAtRecursive(
            { ...nested, select: innerSelect },
            targetModel,
            fieldPath,
            injectedPaths
          );
        } else {
          select[field] = injectDeletedAtRecursive(nested, targetModel, fieldPath, injectedPaths);
        }
      }
    }

    // Recurse into non-to-one relations
    for (const [field, spec] of Object.entries(select)) {
      if (toOneRelations.includes(field)) continue;
      if (!spec || typeof spec !== 'object') continue;
      const targetModel = getRelationModel(modelName, field);
      if (!targetModel) continue;
      const fieldPath = pathPrefix ? pathPrefix + '.' + field : field;
      select[field] = injectDeletedAtRecursive(spec as Record<string, unknown>, targetModel, fieldPath, injectedPaths);
    }

    result.select = select;
  }

  return result;
}

/**
 * Removes deleted_at fields that were injected into selects for post-processing.
 */
function stripInjectedFields(
  result: unknown,
  injectedPaths: string[]
): unknown {
  if (injectedPaths.length === 0) return result;
  return stripInjectedRecursive(result, injectedPaths, '');
}

function stripInjectedRecursive(
  result: unknown,
  injectedPaths: string[],
  currentPath: string
): unknown {
  if (result === null || result === undefined) return result;

  if (Array.isArray(result)) {
    return result.map(item => stripInjectedRecursive(item, injectedPaths, currentPath));
  }

  if (typeof result !== 'object') return result;

  const record = { ...(result as Record<string, unknown>) };

  for (const key of Object.keys(record)) {
    const fieldPath = currentPath ? currentPath + '.' + key : key;

    if (injectedPaths.includes(fieldPath)) {
      delete record[key];
    } else if (record[key] && typeof record[key] === 'object') {
      record[key] = stripInjectedRecursive(record[key], injectedPaths, fieldPath);
    }
  }

  return record;
}

/**
 * Post-processes read results: nullifies deleted to-one relations and strips injected fields.
 */
function postProcessRead<T>(
  promise: Promise<T>,
  modelName: string,
  args: Record<string, unknown> | undefined,
  injectedPaths: string[]
): Promise<T> {
  return promise.then(result => {
    if (result === null || result === undefined) return result;
    const nullified = nullifyDeletedToOneRelations(result, modelName, args);
    return stripInjectedFields(nullified, injectedPaths) as T;
  });
}

/**
 * Post-processes read results for $onlyDeleted: strips injected fields but does NOT
 * nullify deleted to-one relations (since we are intentionally querying deleted records).
 */
function postProcessReadOnlyDeleted<T>(
  promise: Promise<T>,
  injectedPaths: string[]
): Promise<T> {
  return promise.then(result => {
    if (result === null || result === undefined) return result;
    return stripInjectedFields(result, injectedPaths) as T;
  });
}`.trim();
}

function emitInjectFiltersFunction(): string {
  return `
/**
 * Filter mode for soft-delete behavior
 * - 'exclude-deleted': Only non-deleted records (default)
 * - 'include-deleted': All records (deleted + active)
 * - 'only-deleted': Only deleted records
 */
type FilterMode = 'exclude-deleted' | 'include-deleted' | 'only-deleted';

/**
 * Gets the filter value for a given mode and deleted_at field
 */
function getModeFilter(mode: FilterMode, deletedAtField: string): Record<string, unknown> | null {
  switch (mode) {
    case 'exclude-deleted':
      return { [deletedAtField]: ACTIVE_DELETED_AT_VALUE };
    case 'only-deleted':
      return { [deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE } };
    case 'include-deleted':
      return null; // No filter
  }
}

/**
 * Recursively injects soft-delete filters into query args based on mode
 */
function injectFilters<T extends Record<string, unknown>>(
  args: T | undefined,
  modelName: string,
  mode: FilterMode = 'exclude-deleted'
): T {
  if (!args) {
    const deletedAtField = getDeletedAtField(modelName);
    if (deletedAtField && mode !== 'include-deleted') {
      const filter = getModeFilter(mode, deletedAtField);
      return { where: filter } as unknown as T;
    }
    return {} as T;
  }

  const result: Record<string, unknown> = { ...args };
  const deletedAtField = getDeletedAtField(modelName);

  // Inject into top-level where and process relation filters
  if (deletedAtField && mode !== 'include-deleted') {
    const existingWhere = (result.where as Record<string, unknown>) ?? {};
    const modeFilter = getModeFilter(mode, deletedAtField);

    result.where = injectIntoWhere(
      { ...existingWhere, ...modeFilter },
      modelName,
      mode
    );
  } else if (result.where) {
    result.where = injectIntoWhere(
      result.where as Record<string, unknown>,
      modelName,
      mode
    );
  }

  // Process include
  if (result.include && typeof result.include === 'object') {
    result.include = injectIntoRelations(
      result.include as Record<string, unknown>,
      modelName,
      mode
    );
  }

  // Process select
  if (result.select && typeof result.select === 'object') {
    result.select = injectIntoRelations(
      result.select as Record<string, unknown>,
      modelName,
      mode
    );
  }

  return result as T;
}

/**
 * Injects soft delete filters into where clauses, including relation filters
 */
function injectIntoWhere(
  where: Record<string, unknown>,
  parentModel: string,
  mode: FilterMode = 'exclude-deleted'
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(where)) {
    // Check if this is a relation filter (some, every, none, is, isNot)
    const relationModel = getRelationModel(parentModel, key);

    if (relationModel && value && typeof value === 'object') {
      const relationFilter = value as Record<string, unknown>;
      const deletedAtField = getDeletedAtField(relationModel);
      const processedFilter: Record<string, unknown> = {};

      for (const [filterKey, filterValue] of Object.entries(relationFilter)) {
        if (['some', 'every', 'none'].includes(filterKey) && filterValue && typeof filterValue === 'object') {
          // Inject deleted_at filter into the relation condition
          const innerWhere = filterValue as Record<string, unknown>;
          if (deletedAtField && mode !== 'include-deleted') {
            // Check if user already specified a filter on this field (Phase 4)
            if (!(deletedAtField in innerWhere)) {
              const modeFilter = getModeFilter(mode, deletedAtField);
              processedFilter[filterKey] = injectIntoWhere(
                { ...innerWhere, ...modeFilter },
                relationModel,
                mode
              );
            } else {
              // Respect user's explicit filter
              processedFilter[filterKey] = injectIntoWhere(innerWhere, relationModel, mode);
            }
          } else {
            processedFilter[filterKey] = injectIntoWhere(innerWhere, relationModel, mode);
          }
        } else if (['is', 'isNot'].includes(filterKey) && filterValue && typeof filterValue === 'object') {
          // Handle is/isNot for single relations
          const innerWhere = filterValue as Record<string, unknown>;
          if (deletedAtField && mode !== 'include-deleted') {
            // Check if user already specified a filter on this field (Phase 4)
            if (!(deletedAtField in innerWhere)) {
              const modeFilter = getModeFilter(mode, deletedAtField);
              processedFilter[filterKey] = injectIntoWhere(
                { ...innerWhere, ...modeFilter },
                relationModel,
                mode
              );
            } else {
              // Respect user's explicit filter
              processedFilter[filterKey] = injectIntoWhere(innerWhere, relationModel, mode);
            }
          } else {
            processedFilter[filterKey] = injectIntoWhere(innerWhere, relationModel, mode);
          }
        } else {
          processedFilter[filterKey] = filterValue;
        }
      }

      result[key] = processedFilter;
    } else if (key === 'AND' && Array.isArray(value)) {
      result[key] = value.map(v =>
        typeof v === 'object' && v !== null
          ? injectIntoWhere(v as Record<string, unknown>, parentModel, mode)
          : v
      );
    } else if (key === 'OR' && Array.isArray(value)) {
      result[key] = value.map(v =>
        typeof v === 'object' && v !== null
          ? injectIntoWhere(v as Record<string, unknown>, parentModel, mode)
          : v
      );
    } else if (key === 'NOT' && value && typeof value === 'object') {
      result[key] = Array.isArray(value)
        ? value.map(v => typeof v === 'object' && v !== null
            ? injectIntoWhere(v as Record<string, unknown>, parentModel, mode)
            : v)
        : injectIntoWhere(value as Record<string, unknown>, parentModel, mode);
    } else {
      result[key] = value;
    }
  }

  return result;
}

/**
 * Injects filters into relation includes/selects with mode propagation
 */
function injectIntoRelations(
  relations: Record<string, unknown>,
  parentModel: string,
  mode: FilterMode = 'exclude-deleted'
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(relations)) {
    // Handle _count specially
    if (key === '_count') {
      if (value === true) {
        // Expand _count: true to _count: { select: { ...allListRelations } } with filters
        const listRelations = getListRelationsForModel(parentModel);
        const countSelect: Record<string, unknown> = {};
        for (const relName of listRelations) {
          const relationModel = getRelationModel(parentModel, relName);
          if (relationModel) {
            const deletedAtField = getDeletedAtField(relationModel);
            if (deletedAtField && mode !== 'include-deleted') {
              countSelect[relName] = { where: getModeFilter(mode, deletedAtField) };
            } else {
              countSelect[relName] = true;
            }
          } else {
            countSelect[relName] = true;
          }
        }
        result[key] = Object.keys(countSelect).length > 0 ? { select: countSelect } : true;
      } else if (value && typeof value === 'object') {
        const countObj = value as Record<string, unknown>;
        if (countObj.select && typeof countObj.select === 'object') {
          // _count: { select: { posts: true, comments: true } }
          const countSelect = countObj.select as Record<string, unknown>;
          const filteredCountSelect: Record<string, unknown> = {};

          for (const [relName, relValue] of Object.entries(countSelect)) {
            const relationModel = getRelationModel(parentModel, relName);
            if (relationModel) {
              const deletedAtField = getDeletedAtField(relationModel);
              if (deletedAtField && mode !== 'include-deleted' && relValue === true) {
                // Add where filter based on mode
                const modeFilter = getModeFilter(mode, deletedAtField);
                filteredCountSelect[relName] = {
                  where: modeFilter,
                };
              } else if (deletedAtField && mode !== 'include-deleted' && relValue && typeof relValue === 'object') {
                // Merge with existing where - respect user's explicit filter (Phase 4)
                const existing = relValue as Record<string, unknown>;
                const existingWhere = (existing.where as Record<string, unknown>) ?? {};

                if (!(deletedAtField in existingWhere)) {
                  const modeFilter = getModeFilter(mode, deletedAtField);
                  filteredCountSelect[relName] = {
                    ...existing,
                    where: { ...existingWhere, ...modeFilter },
                  };
                } else {
                  // User specified explicit filter - respect it
                  filteredCountSelect[relName] = relValue;
                }
              } else {
                filteredCountSelect[relName] = relValue;
              }
            } else {
              filteredCountSelect[relName] = relValue;
            }
          }

          result[key] = { ...countObj, select: filteredCountSelect };
        } else {
          result[key] = value;
        }
      } else {
        result[key] = value;
      }
      continue;
    }

    // Look up the actual target model for this relation field
    const relationModel = getRelationModel(parentModel, key);
    const isList = isListRelation(parentModel, key);

    if (value === true) {
      // Simple include - inject filter if relation target is soft-deletable
      // Only add where clause for list relations (non-list relations don't support where in include)
      if (relationModel && isList) {
        const deletedAtField = getDeletedAtField(relationModel);
        if (deletedAtField && mode !== 'include-deleted') {
          const modeFilter = getModeFilter(mode, deletedAtField);
          result[key] = {
            where: modeFilter,
          };
        } else {
          result[key] = value;
        }
      } else {
        result[key] = value;
      }
    } else if (value && typeof value === 'object') {
      // Nested include with options
      const nested = { ...(value as Record<string, unknown>) };

      if (relationModel) {
        // Only add where clause for list relations
        if (isList) {
          const deletedAtField = getDeletedAtField(relationModel);
          if (deletedAtField && mode !== 'include-deleted') {
            const existingWhere = (nested.where as Record<string, unknown>) ?? {};

            // Phase 4: Only inject if user hasn't already specified this field
            if (!(deletedAtField in existingWhere)) {
              const modeFilter = getModeFilter(mode, deletedAtField);
              nested.where = { ...existingWhere, ...modeFilter };
            }
            // else: User's explicit filter takes precedence
          }
        }

        // Recursively process nested includes with mode propagation
        if (nested.include && typeof nested.include === 'object') {
          nested.include = injectIntoRelations(
            nested.include as Record<string, unknown>,
            relationModel,
            mode // Propagate mode down
          );
        }

        // Recursively process nested selects with mode propagation
        if (nested.select && typeof nested.select === 'object') {
          nested.select = injectIntoRelations(
            nested.select as Record<string, unknown>,
            relationModel,
            mode // Propagate mode down
          );
        }
      }

      result[key] = nested;
    } else {
      result[key] = value;
    }
  }

  return result;
}`.trim();
}

function emitSoftDeleteCascadeFunction(includeWrapper = true, hasAudit = false): string {
  const wrapperFn = includeWrapper ? `
/**
 * Performs a soft delete with cascade (with its own transaction)
 */
async function softDeleteWithCascade(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>,
  deletedBy?: string
): Promise<{ count: number; cascaded: Record<string, number> }> {
  return prisma.$transaction(async (tx) => {
    return softDeleteWithCascadeInTx(tx, modelName, where, deletedBy);
  });
}
` : '';
  // Audit params are only emitted when hasAudit is true (avoids --noUnusedLocals errors)
  const auditParams = hasAudit ? `
  auditActorId?: string | null,
  auditWrapOptions?: any,
  auditCallCtx?: Record<string, unknown>,` : '';
  const auditCascadeParams = hasAudit ? `
  auditParentEventIds?: string[],
  auditActorId?: string | null,
  auditWrapOptions?: any,
  auditCallCtx?: Record<string, unknown>,` : '';
  return `${wrapperFn}
${hasAudit ? `/** Deduplicates audit chain break warnings — emits once per parent→child pair per process. */
const _auditChainBreakWarned = new Set<string>();
` : ''}
/**
 * Performs a soft delete with cascade within an existing transaction
 */
async function softDeleteWithCascadeInTx(
  tx: Prisma.TransactionClient,
  modelName: string,
  where: Record<string, unknown>,
  deletedBy?: string,${auditParams}
): Promise<{ count: number; cascaded: Record<string, number> }> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  const now = new Date();
  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);

  // Find all records to delete (pre-mutation snapshots for audit)
  const delegate = tx[lowerModelName as keyof typeof tx] as any;
  // Decompose compound key where clause if needed
  const decomposedWhere = decomposeCompoundKeyWhere(modelName, where);
  const records = await delegate.findMany({
    where: {
      ...decomposedWhere,
      [deletedAtField]: ACTIVE_DELETED_AT_VALUE, // Only active records
    },
  });

  if (records.length === 0) return { count: 0, cascaded: {} };

  // Get primary keys of records to delete
  const pkValues = records.map((r: Record<string, unknown>) =>
    extractPrimaryKey(modelName, r)
  );
${hasAudit ? `
  // Write audit events for parent records BEFORE mutation (pre-mutation snapshots)
  let parentEventIds: string[] | undefined;
  if (auditActorId !== undefined && isAuditable(modelName, 'delete')) {
    const ctx = await _mergeAuditContext(auditWrapOptions, auditCallCtx);
    parentEventIds = [];
    for (const record of records) {
      const eventId = await writeAuditEvent(
        tx, modelName, getEntityId(modelName, record), 'soft_delete',
        auditActorId, record, undefined, ctx,
      );
      parentEventIds.push(eventId);
    }
  }
` : ''}
  // Cascade to children (depth-first)
  const cascaded = await cascadeToChildren(tx, modelName, pkValues, now, deletedBy${hasAudit ? `,
    parentEventIds, auditActorId, auditWrapOptions, auditCallCtx` : ''});

  // Update parent records
  const needsMangling = UNIQUE_STRATEGY === 'mangle' && (getUniqueStringFields(modelName).length > 0);

  if (needsMangling) {
    // Per-record update: mangle unique fields individually (each record has its own PK suffix)
    for (const record of records) {
      const pkVal = extractPrimaryKey(modelName, record);
      const mangledFields = mangleUniqueFields(modelName, record);

      const updateData: Record<string, unknown> = {
        ...mangledFields,
        [deletedAtField]: now,
      };

      const deletedByField = getDeletedByField(modelName);
      if (deletedByField && deletedBy) {
        updateData[deletedByField] = deletedBy;
      }

      await delegate.update({
        where: createPkWhereFromValues(modelName, pkVal),
        data: updateData,
      });
    }
  } else {
    // Bulk update: no mangling needed, use updateMany for all records at once
    const bulkUpdateData: Record<string, unknown> = {
      [deletedAtField]: now,
    };

    const deletedByField = getDeletedByField(modelName);
    if (deletedByField && deletedBy) {
      bulkUpdateData[deletedByField] = deletedBy;
    }

    const pkConditions = pkValues;
    await delegate.updateMany({
      where: { OR: pkConditions, [deletedAtField]: ACTIVE_DELETED_AT_VALUE },
      data: bulkUpdateData,
    });
  }

  return { count: records.length, cascaded };
}

/**
 * Gets the deleted_by field name for a model
 */
function getDeletedByField(modelName: string): string | null {
  return DELETED_BY_MODELS[modelName]?.deletedByField ?? null;
}

/**
 * Recursively cascades soft delete to children
 */
async function cascadeToChildren(
  tx: Prisma.TransactionClient,
  parentModel: string,
  parentPkValues: Record<string, unknown>[],
  deletedAt: Date,
  deletedBy?: string,${auditCascadeParams}
): Promise<Record<string, number>> {
  const children = CASCADE_GRAPH[parentModel] ?? [];
  const cascaded: Record<string, number> = {};

  for (const child of children) {
    const lowerChildModel = child.model.charAt(0).toLowerCase() + child.model.slice(1);
    const childDelegate = tx[lowerChildModel as keyof typeof tx] as any;

    // Build where clause to find children - handle compound keys
    if (child.foreignKey.length === 0 || child.parentKey.length === 0) continue;

    // Build OR conditions for each parent record (supports compound keys)
    const childWhereConditions = parentPkValues.map((pkVal) => {
      const condition: Record<string, unknown> = {};
      for (let i = 0; i < child.foreignKey.length; i++) {
        const fkField = child.foreignKey[i];
        const pkField = child.parentKey[i];
        if (fkField && pkField) {
          condition[fkField] = pkVal[pkField];
        }
      }
      return condition;
    });

    // Find child records (pre-mutation snapshots)
    const childRecords = await childDelegate.findMany({
      where: {
        OR: childWhereConditions,
        ...(child.deletedAtField ? { [child.deletedAtField]: ACTIVE_DELETED_AT_VALUE } : {}),
      },
    });

    if (childRecords.length === 0) continue;

    // Get child PKs for recursive cascade
    const childPkValues = childRecords.map((r: Record<string, unknown>) =>
      extractPrimaryKey(child.model, r)
    );
${hasAudit ? `
    // Write audit events for child records BEFORE mutation, with parent_event_id linking
    let childEventIds: string[] | undefined;
    if (auditActorId !== undefined && isAuditable(child.model, 'delete') && auditParentEventIds) {
      const ctx = await _mergeAuditContext(auditWrapOptions, auditCallCtx);
      childEventIds = [];
      for (const childRecord of childRecords) {
        // Find which parent this child belongs to (match FK values)
        let parentEventId: string | undefined;
        for (let pi = 0; pi < parentPkValues.length; pi++) {
          const pkVal = parentPkValues[pi];
          if (!pkVal) continue;
          let matches = true;
          for (let fi = 0; fi < child.foreignKey.length; fi++) {
            const fk = child.foreignKey[fi];
            const pk = child.parentKey[fi];
            if (fk && pk && String(childRecord[fk]) !== String(pkVal[pk])) {
              matches = false;
              break;
            }
          }
          if (matches) {
            parentEventId = auditParentEventIds[pi];
            break;
          }
        }
        const eventId = await writeAuditEvent(
          tx, child.model, getEntityId(child.model, childRecord), 'soft_delete',
          auditActorId, childRecord, parentEventId, ctx,
        );
        childEventIds.push(eventId);
      }
    } else if (auditActorId !== undefined && !isAuditable(child.model, 'delete')) {
      // Non-auditable child: chain breaks, pass undefined for grandchildren.
      // Any soft-deletable grandchildren of this child will not receive a parent_event_id,
      // even if they are themselves auditable, because the linking chain is broken here.
      const warnKey = \`\${parentModel}->\${child.model}\`;
      if (!_auditChainBreakWarned.has(warnKey)) {
        _auditChainBreakWarned.add(warnKey);
        // eslint-disable-next-line no-console
        console.warn(
          \`[prisma-safe-delete] audit chain break: cascade from '\${parentModel}' through '\${child.model}' (\${child.model} is not auditable for 'delete'). \` +
          \`Any auditable grandchildren of '\${child.model}' will not have a parent_event_id. To preserve the chain, add @audit to '\${child.model}'.\`
        );
      }
      childEventIds = undefined;
    }
` : ''}
    if (child.isSoftDeletable && child.deletedAtField) {
      // Recurse to grandchildren first (depth-first) — only for soft-deletable children.
      // For non-soft-deletable children, we hard-delete them below and let DB ON DELETE CASCADE
      // handle their descendants. Recursing first would soft-delete grandchildren that the DB
      // cascade then destroys, causing data loss.
      const grandchildCascaded = await cascadeToChildren(tx, child.model, childPkValues, deletedAt, deletedBy${hasAudit ? `,
        childEventIds, auditActorId, auditWrapOptions, auditCallCtx` : ''});

      // Merge grandchild results
      for (const [model, count] of Object.entries(grandchildCascaded)) {
        cascaded[model] = (cascaded[model] ?? 0) + count;
      }

      // Soft delete children
      const childNeedsMangling = UNIQUE_STRATEGY === 'mangle' && (getUniqueStringFields(child.model).length > 0);

      if (childNeedsMangling) {
        // Per-record update: mangle unique fields for each child individually
        for (const childRecord of childRecords) {
          const childPkVal = extractPrimaryKey(child.model, childRecord);
          const mangledFields = mangleUniqueFields(child.model, childRecord);

          const updateData: Record<string, unknown> = {
            ...mangledFields,
            [child.deletedAtField]: deletedAt,
          };

          if (child.deletedByField && deletedBy) {
            updateData[child.deletedByField] = deletedBy;
          }

          await childDelegate.update({
            where: createPkWhereFromValues(child.model, childPkVal),
            data: updateData,
          });
        }
      } else {
        // Bulk update: no mangling needed
        const bulkUpdateData: Record<string, unknown> = {
          [child.deletedAtField]: deletedAt,
        };

        if (child.deletedByField && deletedBy) {
          bulkUpdateData[child.deletedByField] = deletedBy;
        }

        const childPkConditions = childPkValues;
        await childDelegate.updateMany({
          where: { OR: childPkConditions, [child.deletedAtField]: ACTIVE_DELETED_AT_VALUE },
          data: bulkUpdateData,
        });
      }

      // Track the count for this child model
      cascaded[child.model] = (cascaded[child.model] ?? 0) + childRecords.length;
    } else {
      // Non-soft-deletable children: hard delete them
      const childPkConditions = childRecords.map((r: Record<string, unknown>) =>
        extractPrimaryKey(child.model, r)
      );
${hasAudit ? `
      // Write audit events for hard-deleted non-soft-deletable children
      if (auditActorId !== undefined && isAuditable(child.model, 'delete') && auditParentEventIds) {
        const ctx = await _mergeAuditContext(auditWrapOptions, auditCallCtx);
        for (const childRecord of childRecords) {
          // Find which parent this child belongs to (match FK values)
          let parentEventId: string | undefined;
          for (let pi = 0; pi < parentPkValues.length; pi++) {
            const pkVal = parentPkValues[pi];
            if (!pkVal) continue;
            let matches = true;
            for (let fi = 0; fi < child.foreignKey.length; fi++) {
              const fk = child.foreignKey[fi];
              const pk = child.parentKey[fi];
              if (fk && pk && String(childRecord[fk]) !== String(pkVal[pk])) {
                matches = false;
                break;
              }
            }
            if (matches) {
              parentEventId = auditParentEventIds[pi];
              break;
            }
          }
          await writeAuditEvent(
            tx, child.model, getEntityId(child.model, childRecord), 'hard_delete',
            auditActorId, childRecord, parentEventId, ctx,
          );
        }
      }
` : ''}
      await childDelegate.deleteMany({ where: { OR: childPkConditions } });

      // Track the count for this child model
      cascaded[child.model] = (cascaded[child.model] ?? 0) + childRecords.length;
    }
  }

  return cascaded;
}

/**
 * Restores a soft-deleted record by setting deleted_at to null and unmangling unique fields.
 * Wrapped in a transaction for safety.
 * Throws if unmangled unique values would conflict with existing records.
 */
async function restoreRecord(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>,
  projection: Record<string, unknown> = {}
): Promise<Record<string, unknown> | null> {
  return prisma.$transaction(async (tx) => {
    return restoreRecordInTx(tx, modelName, where, projection);
  });
}

/**
 * Restores a soft-deleted record within a transaction.
 */
async function restoreRecordInTx(
  tx: Prisma.TransactionClient,
  modelName: string,
  where: Record<string, unknown>,
  projection: Record<string, unknown> = {}
): Promise<Record<string, unknown> | null> {
  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);
  const delegate = tx[lowerModelName as keyof typeof tx] as any;
  return restoreRecordWithDelegate(delegate, modelName, where, projection);
}

/**
 * Core restore logic used by both restoreRecord and restoreRecordInTx.
 */
async function restoreRecordWithDelegate(
  delegate: any,
  modelName: string,
  where: Record<string, unknown>,
  projection: Record<string, unknown> = {}
): Promise<Record<string, unknown> | null> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  // Decompose compound key where clause if needed
  const decomposedWhere = decomposeCompoundKeyWhere(modelName, where);

  // Find the soft-deleted record
  const record = await delegate.findFirst({
    where: {
      ...decomposedWhere,
      [deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE }, // Only deleted records
    },
  });

  if (!record) return null;

  // Get unmangled field values
  const unmangledFields = unmangleUniqueFields(modelName, record);

  // Check for conflicts before restoring (using compound unique constraints when available)
  if (Object.keys(unmangledFields).length > 0) {
    const constraints = UNIQUE_CONSTRAINTS[modelName] ?? [];
    // Build the full unmangled record for compound lookups
    const unmangledRecord: Record<string, unknown> = { ...record, ...unmangledFields };

    if (constraints.length > 0) {
      // Use structured constraints for accurate compound checking
      for (const constraint of constraints) {
        // Only check constraints that involve unmangled fields
        const involvesUnmangled = constraint.fields.some((f: string) => f in unmangledFields);
        if (!involvesUnmangled) continue;

        // Build compound where clause from all fields in this constraint
        const constraintWhere: Record<string, unknown> = {
          [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
        };
        let hasAllFields = true;
        for (const f of constraint.fields) {
          const val = unmangledRecord[f];
          if (val === null || val === undefined) {
            // Null values don't conflict with unique constraints
            hasAllFields = false;
            break;
          }
          constraintWhere[f] = val;
        }
        if (!hasAllFields) continue;

        const existing = await delegate.findFirst({ where: constraintWhere });
        if (existing) {
          const fieldNames = constraint.fields.join(', ');
          throw new Error(
            \`Cannot restore \${modelName}: unique constraint on (\${fieldNames}) \` +
            \`already satisfied by an active record. Delete or modify the conflicting record first.\`
          );
        }
      }
    } else {
      // Fallback: check each unmangled field individually (single-field uniques)
      for (const [field, value] of Object.entries(unmangledFields)) {
        const existing = await delegate.findFirst({
          where: {
            [field]: value,
            [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
          },
        });

        if (existing) {
          throw new Error(
            \`Cannot restore \${modelName}: unique field "\${field}" with value "\${value}" \` +
            \`already exists in an active record. Delete or modify the conflicting record first.\`
          );
        }
      }
    }
  }

  // Restore the record
  const pkVal = extractPrimaryKey(modelName, record);
  const deletedByField = getDeletedByField(modelName);

  const updateData: Record<string, unknown> = {
    ...unmangledFields,
    [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
  };

  // Clear deleted_by if the model has that field
  if (deletedByField) {
    updateData[deletedByField] = null;
  }

  try {
    return await delegate.update({
      where: createPkWhereFromValues(modelName, pkVal),
      data: updateData,
      ...projection,
    });
  } catch (e: unknown) {
    if (e && typeof e === 'object' && 'code' in e && (e as Record<string, unknown>).code === 'P2002') {
      const meta = (e as Record<string, unknown>).meta as Record<string, unknown> | undefined;
      const fields = meta?.target ? String(meta.target) : 'unknown';
      throw new Error(
        \`Cannot restore \${modelName}: unique constraint violation on (\${fields}). \` +
        \`An active record with the same unique value was created concurrently.\`
      );
    }
    throw e;
  }
}

/**
 * Restores multiple soft-deleted records.
 * Wrapped in a transaction for safety.
 * Throws if any unmangled unique values would conflict.
 */
async function restoreManyRecords(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ count: number }> {
  return prisma.$transaction(async (tx) => {
    return restoreManyInTx(tx, modelName, where);
  });
}

/**
 * Restores multiple soft-deleted records within a transaction.
 */
async function restoreManyInTx(
  tx: Prisma.TransactionClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ count: number }> {
  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);
  const delegate = tx[lowerModelName as keyof typeof tx] as any;
  return restoreManyWithDelegate(delegate, modelName, where);
}

/**
 * Core restoreMany logic used by both restoreManyRecords and restoreManyInTx.
 */
async function restoreManyWithDelegate(
  delegate: any,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ count: number }> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  // Find all soft-deleted records matching the criteria
  const records = await delegate.findMany({
    where: {
      ...where,
      [deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE },
    },
  });

  if (records.length === 0) return { count: 0 };

  const deletedByField = getDeletedByField(modelName);
  const needsUnmangling = UNIQUE_STRATEGY === 'mangle' && (getUniqueStringFields(modelName).length > 0);

  if (needsUnmangling) {
    // Per-record restore: unmangle unique fields individually and check conflicts
    let restoredCount = 0;

    for (const record of records) {
      const unmangledFields = unmangleUniqueFields(modelName, record);

      // Check for conflicts (using compound unique constraints when available)
      if (Object.keys(unmangledFields).length > 0) {
        const constraints = UNIQUE_CONSTRAINTS[modelName] ?? [];
        const unmangledRecord: Record<string, unknown> = { ...record, ...unmangledFields };

        if (constraints.length > 0) {
          for (const constraint of constraints) {
            const involvesUnmangled = constraint.fields.some((f: string) => f in unmangledFields);
            if (!involvesUnmangled) continue;

            const constraintWhere: Record<string, unknown> = {
              [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
            };
            let hasAllFields = true;
            for (const f of constraint.fields) {
              const val = unmangledRecord[f];
              if (val === null || val === undefined) {
                hasAllFields = false;
                break;
              }
              constraintWhere[f] = val;
            }
            if (!hasAllFields) continue;

            const existing = await delegate.findFirst({ where: constraintWhere });
            if (existing) {
              const fieldNames = constraint.fields.join(', ');
              throw new Error(
                \`Cannot restore \${modelName}: unique constraint on (\${fieldNames}) \` +
                \`already satisfied by an active record. Delete or modify the conflicting record first.\`
              );
            }
          }
        } else {
          for (const [field, value] of Object.entries(unmangledFields)) {
            const existing = await delegate.findFirst({
              where: {
                [field]: value,
                [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
              },
            });

            if (existing) {
              throw new Error(
                \`Cannot restore \${modelName}: unique field "\${field}" with value "\${value}" \` +
                \`already exists in an active record. Delete or modify the conflicting record first.\`
              );
            }
          }
        }
      }

      const pkVal = extractPrimaryKey(modelName, record);
      const updateData: Record<string, unknown> = {
        ...unmangledFields,
        [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
      };

      if (deletedByField) {
        updateData[deletedByField] = null;
      }

      try {
        await delegate.update({
          where: createPkWhereFromValues(modelName, pkVal),
          data: updateData,
        });
      } catch (e: unknown) {
        if (e && typeof e === 'object' && 'code' in e && (e as Record<string, unknown>).code === 'P2002') {
          const meta = (e as Record<string, unknown>).meta as Record<string, unknown> | undefined;
          const fields = meta?.target ? String(meta.target) : 'unknown';
          throw new Error(
            \`Cannot restore \${modelName}: unique constraint violation on (\${fields}). \` +
            \`An active record with the same unique value was created concurrently.\`
          );
        }
        throw e;
      }

      restoredCount++;
    }

    return { count: restoredCount };
  } else {
    // Bulk restore: no unmangling needed
    const bulkUpdateData: Record<string, unknown> = {
      [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
    };

    if (deletedByField) {
      bulkUpdateData[deletedByField] = null;
    }

    const pkConditions = records.map((r: Record<string, unknown>) =>
      extractPrimaryKey(modelName, r)
    );
    const result = await delegate.updateMany({
      where: { OR: pkConditions, [deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE } },
      data: bulkUpdateData,
    });

    return { count: result.count };
  }
}

/**
 * Restores a soft-deleted record AND all its cascade-deleted children.
 * Children are identified by having the same deleted_at timestamp as the parent.
 * Wrapped in a transaction.
 */
async function restoreWithCascade(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>,
  projection: Record<string, unknown> = {}
): Promise<{ record: Record<string, unknown> | null; cascaded: Record<string, number> }> {
  return prisma.$transaction(async (tx) => {
    return restoreWithCascadeInTx(tx, modelName, where, projection);
  });
}

/**
 * Restores a soft-deleted record AND all its cascade-deleted children within a transaction.
 */
async function restoreWithCascadeInTx(
  tx: Prisma.TransactionClient,
  modelName: string,
  where: Record<string, unknown>,
  projection: Record<string, unknown> = {},${hasAudit ? `
  auditActorId?: string | null,
  auditWrapOptions?: any,
  auditCallCtx?: Record<string, unknown>,` : ''}
): Promise<{ record: Record<string, unknown> | null; cascaded: Record<string, number> }> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);
  const delegate = tx[lowerModelName as keyof typeof tx] as any;

  // Decompose compound key where clause if needed
  const decomposedWhere = decomposeCompoundKeyWhere(modelName, where);

  // Find the soft-deleted record
  const record = await delegate.findFirst({
    where: {
      ...decomposedWhere,
      [deletedAtField]: { not: ACTIVE_DELETED_AT_VALUE },
    },
  });

  if (!record) return { record: null, cascaded: {} };

  const deletedAt = record[deletedAtField];

  // Restore children first (depth-first, reverse of cascade delete)
  const pkVal = extractPrimaryKey(modelName, record);
  const cascaded = await restoreCascadeChildren(tx, modelName, [pkVal], deletedAt${hasAudit ? `,
    auditActorId, auditWrapOptions, auditCallCtx` : ''});

  // Now restore the parent record
  const unmangledFields = unmangleUniqueFields(modelName, record);

  // Check for conflicts (using compound unique constraints when available)
  if (Object.keys(unmangledFields).length > 0) {
    const constraints = UNIQUE_CONSTRAINTS[modelName] ?? [];
    const unmangledRecord: Record<string, unknown> = { ...record, ...unmangledFields };

    if (constraints.length > 0) {
      for (const constraint of constraints) {
        const involvesUnmangled = constraint.fields.some((f: string) => f in unmangledFields);
        if (!involvesUnmangled) continue;

        const constraintWhere: Record<string, unknown> = {
          [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
        };
        let hasAllFields = true;
        for (const f of constraint.fields) {
          const val = unmangledRecord[f];
          if (val === null || val === undefined) {
            hasAllFields = false;
            break;
          }
          constraintWhere[f] = val;
        }
        if (!hasAllFields) continue;

        const existing = await delegate.findFirst({ where: constraintWhere });
        if (existing) {
          const fieldNames = constraint.fields.join(', ');
          throw new Error(
            \`Cannot restore \${modelName}: unique constraint on (\${fieldNames}) \` +
            \`already satisfied by an active record. Delete or modify the conflicting record first.\`
          );
        }
      }
    } else {
      for (const [field, value] of Object.entries(unmangledFields)) {
        const existing = await delegate.findFirst({
          where: {
            [field]: value,
            [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
          },
        });

        if (existing) {
          throw new Error(
            \`Cannot restore \${modelName}: unique field "\${field}" with value "\${value}" \` +
            \`already exists in an active record. Delete or modify the conflicting record first.\`
          );
        }
      }
    }
  }

  const deletedByField = getDeletedByField(modelName);
  const updateData: Record<string, unknown> = {
    ...unmangledFields,
    [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
  };

  if (deletedByField) {
    updateData[deletedByField] = null;
  }

  let restoredRecord;
  try {
    restoredRecord = await delegate.update({
      where: createPkWhereFromValues(modelName, pkVal),
      data: updateData,
      ...projection,
    });
  } catch (e: unknown) {
    if (e && typeof e === 'object' && 'code' in e && (e as Record<string, unknown>).code === 'P2002') {
      const meta = (e as Record<string, unknown>).meta as Record<string, unknown> | undefined;
      const fields = meta?.target ? String(meta.target) : 'unknown';
      throw new Error(
        \`Cannot restore \${modelName}: unique constraint violation on (\${fields}). \` +
        \`An active record with the same unique value was created concurrently.\`
      );
    }
    throw e;
  }

  return { record: restoredRecord, cascaded };
}

/**
 * Recursively restores cascade-deleted children.
 * Only restores children with matching deleted_at timestamp.
 */
async function restoreCascadeChildren(
  tx: Prisma.TransactionClient,
  parentModel: string,
  parentPkValues: Record<string, unknown>[],
  deletedAt: Date,${hasAudit ? `
  auditActorId?: string | null,
  auditWrapOptions?: any,
  auditCallCtx?: Record<string, unknown>,` : ''}
): Promise<Record<string, number>> {
  const children = CASCADE_GRAPH[parentModel] ?? [];
  const cascaded: Record<string, number> = {};

  for (const child of children) {
    // Skip non-soft-deletable children — they were hard-deleted during the original cascade
    // and cannot be restored. DB ON DELETE CASCADE handled their descendants.
    if (!child.isSoftDeletable || !child.deletedAtField) continue;

    const lowerChildModel = child.model.charAt(0).toLowerCase() + child.model.slice(1);
    const childDelegate = tx[lowerChildModel as keyof typeof tx] as any;

    if (child.foreignKey.length === 0 || child.parentKey.length === 0) continue;

    const childWhereConditions = parentPkValues.map((pkVal) => {
      const condition: Record<string, unknown> = {};
      for (let i = 0; i < child.foreignKey.length; i++) {
        const fkField = child.foreignKey[i];
        const pkField = child.parentKey[i];
        if (fkField && pkField) {
          condition[fkField] = pkVal[pkField];
        }
      }
      return condition;
    });

    // Find children with matching deleted_at timestamp
    const childRecords = await childDelegate.findMany({
      where: {
        OR: childWhereConditions,
        [child.deletedAtField]: deletedAt,
      },
    });

    if (childRecords.length === 0) continue;

    const childPkValues = childRecords.map((r: Record<string, unknown>) =>
      extractPrimaryKey(child.model, r)
    );

    // Recurse to grandchildren first (depth-first, reverse of cascade delete)
    const grandchildCascaded = await restoreCascadeChildren(tx, child.model, childPkValues, deletedAt${hasAudit ? `,
      auditActorId, auditWrapOptions, auditCallCtx` : ''});

    // Merge grandchild results
    for (const [model, count] of Object.entries(grandchildCascaded)) {
      cascaded[model] = (cascaded[model] ?? 0) + count;
    }

    const childNeedsUnmangling = UNIQUE_STRATEGY === 'mangle' && (getUniqueStringFields(child.model).length > 0);

    if (childNeedsUnmangling) {
      // Per-record restore: unmangle unique fields individually
      for (const childRecord of childRecords) {
        const childPkVal = extractPrimaryKey(child.model, childRecord);
        const unmangledFields = unmangleUniqueFields(child.model, childRecord);

        // Check for conflicts (using compound unique constraints when available)
        if (Object.keys(unmangledFields).length > 0) {
          const constraints = UNIQUE_CONSTRAINTS[child.model] ?? [];
          const unmangledRecord: Record<string, unknown> = { ...childRecord, ...unmangledFields };

          if (constraints.length > 0) {
            for (const constraint of constraints) {
              const involvesUnmangled = constraint.fields.some((f: string) => f in unmangledFields);
              if (!involvesUnmangled) continue;

              const constraintWhere: Record<string, unknown> = {
                [child.deletedAtField]: ACTIVE_DELETED_AT_VALUE,
              };
              let hasAllFields = true;
              for (const f of constraint.fields) {
                const val = unmangledRecord[f];
                if (val === null || val === undefined) {
                  hasAllFields = false;
                  break;
                }
                constraintWhere[f] = val;
              }
              if (!hasAllFields) continue;

              const existing = await childDelegate.findFirst({ where: constraintWhere });
              if (existing) {
                const fieldNames = constraint.fields.join(', ');
                throw new Error(
                  \`Cannot restore \${child.model}: unique constraint on (\${fieldNames}) \` +
                  \`already satisfied by an active record.\`
                );
              }
            }
          } else {
            for (const [field, value] of Object.entries(unmangledFields)) {
              const existing = await childDelegate.findFirst({
                where: {
                  [field]: value,
                  [child.deletedAtField]: ACTIVE_DELETED_AT_VALUE,
                },
              });

              if (existing) {
                throw new Error(
                  \`Cannot restore \${child.model}: unique field "\${field}" with value "\${value}" \` +
                  \`already exists in an active record.\`
                );
              }
            }
          }
        }

        const updateData: Record<string, unknown> = {
          ...unmangledFields,
          [child.deletedAtField]: ACTIVE_DELETED_AT_VALUE,
        };

        if (child.deletedByField) {
          updateData[child.deletedByField] = null;
        }

        try {
          await childDelegate.update({
            where: createPkWhereFromValues(child.model, childPkVal),
            data: updateData,
          });
        } catch (e: unknown) {
          if (e && typeof e === 'object' && 'code' in e && (e as Record<string, unknown>).code === 'P2002') {
            const meta = (e as Record<string, unknown>).meta as Record<string, unknown> | undefined;
            const fields = meta?.target ? String(meta.target) : 'unknown';
            throw new Error(
              \`Cannot restore \${child.model}: unique constraint violation on (\${fields}). \` +
              \`An active record with the same unique value was created concurrently.\`
            );
          }
          throw e;
        }
      }
    } else {
      // Bulk restore: no unmangling needed
      const bulkUpdateData: Record<string, unknown> = {
        [child.deletedAtField]: ACTIVE_DELETED_AT_VALUE,
      };

      if (child.deletedByField) {
        bulkUpdateData[child.deletedByField] = null;
      }

      const childPkConditions = childPkValues;
      await childDelegate.updateMany({
        where: { OR: childPkConditions, [child.deletedAtField]: deletedAt },
        data: bulkUpdateData,
      });
    }
${hasAudit ? `
    // Write audit events for restored children (restore is an update action)
    if (auditActorId !== undefined && isAuditable(child.model, 'update')) {
      const ctx = await _mergeAuditContext(auditWrapOptions, auditCallCtx);
      for (const childRecord of childRecords) {
        await writeAuditEvent(
          tx, child.model, getEntityId(child.model, childRecord), 'restore',
          auditActorId, childRecord, undefined, ctx,
        );
      }
    }
` : ''}
    // Track the count for this child model
    cascaded[child.model] = (cascaded[child.model] ?? 0) + childRecords.length;
  }

  return cascaded;
}

/**
 * Previews a soft delete with cascade (read-only, no writes)
 */
async function previewSoftDelete(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ wouldDelete: Record<string, number> }> {
  return prisma.$transaction(async (tx) => {
    return previewSoftDeleteInTx(tx, modelName, where);
  });
}

/**
 * Previews a soft delete with cascade within an existing transaction (read-only)
 */
async function previewSoftDeleteInTx(
  tx: Prisma.TransactionClient,
  modelName: string,
  where: Record<string, unknown>
): Promise<{ wouldDelete: Record<string, number> }> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);
  const delegate = tx[lowerModelName as keyof typeof tx] as any;
  const decomposedWhere = decomposeCompoundKeyWhere(modelName, where);

  // Find all records that would be deleted
  const records = await delegate.findMany({
    where: {
      ...decomposedWhere,
      [deletedAtField]: ACTIVE_DELETED_AT_VALUE,
    },
  });

  if (records.length === 0) return { wouldDelete: {} };

  const pkValues = records.map((r: Record<string, unknown>) =>
    extractPrimaryKey(modelName, r)
  );

  // Preview cascade to children (read-only)
  const cascaded = await previewCascadeChildren(tx, modelName, pkValues);

  const wouldDelete: Record<string, number> = { [modelName]: records.length };
  for (const [model, count] of Object.entries(cascaded)) {
    wouldDelete[model] = (wouldDelete[model] ?? 0) + count;
  }
  return { wouldDelete };
}

/**
 * Recursively previews cascade soft delete to children (read-only, no writes)
 */
async function previewCascadeChildren(
  tx: Prisma.TransactionClient,
  parentModel: string,
  parentPkValues: Record<string, unknown>[]
): Promise<Record<string, number>> {
  const children = CASCADE_GRAPH[parentModel] ?? [];
  const cascaded: Record<string, number> = {};

  for (const child of children) {
    const lowerChildModel = child.model.charAt(0).toLowerCase() + child.model.slice(1);
    const childDelegate = tx[lowerChildModel as keyof typeof tx] as any;

    if (child.foreignKey.length === 0 || child.parentKey.length === 0) continue;

    const childWhereConditions = parentPkValues.map((pkVal) => {
      const condition: Record<string, unknown> = {};
      for (let i = 0; i < child.foreignKey.length; i++) {
        const fkField = child.foreignKey[i];
        const pkField = child.parentKey[i];
        if (fkField && pkField) {
          condition[fkField] = pkVal[pkField];
        }
      }
      return condition;
    });

    const childRecords = await childDelegate.findMany({
      where: {
        OR: childWhereConditions,
        ...(child.deletedAtField ? { [child.deletedAtField]: ACTIVE_DELETED_AT_VALUE } : {}),
      },
    });

    if (childRecords.length === 0) continue;

    // Count this child model — both soft-deletable (will be soft-deleted) and
    // non-soft-deletable (will be hard-deleted) children are affected by the cascade.
    cascaded[child.model] = (cascaded[child.model] ?? 0) + childRecords.length;

    // Only recurse into soft-deletable children — our code handles their descendants.
    // Non-soft-deletable children are hard-deleted and DB ON DELETE CASCADE handles
    // their descendants, which we don't preview.
    if (child.isSoftDeletable && child.deletedAtField) {
      const childPkValues = childRecords.map((r: Record<string, unknown>) =>
        extractPrimaryKey(child.model, r)
      );

      const grandchildCascaded = await previewCascadeChildren(tx, child.model, childPkValues);

      for (const [model, count] of Object.entries(grandchildCascaded)) {
        cascaded[model] = (cascaded[model] ?? 0) + count;
      }
    }
  }

  return cascaded;
}`.trim();
}

function emitModelDelegate(model: ParsedModel, options: EmitRuntimeOptions, hasAudit: boolean): string {
  const name = model.name;
  const lowerName = toLowerFirst(name);

  if (model.isSoftDeletable) {
    const deletedAtField = model.deletedAtField;
    const simple = isSimpleModel(model, options);

    // Common parts shared between simple and complex delegates
    const findUniqueMethods = options.uniqueStrategy === 'sentinel'
      ? `
    findUnique: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      const filtered = injectFilters(pp, '${name}');
      if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${name}');
      return postProcessRead(original.findUnique(filtered), '${name}', filtered, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['findUnique'],
    findUniqueOrThrow: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      const filtered = injectFilters(pp, '${name}');
      if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${name}');
      return postProcessRead(original.findUniqueOrThrow(filtered), '${name}', filtered, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`
      : `
    findUnique: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      const filtered = injectFilters(pp, '${name}');
      return postProcessRead(original.findUnique(filtered), '${name}', filtered, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['findUnique'],
    findUniqueOrThrow: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      const filtered = injectFilters(pp, '${name}');
      return postProcessRead(original.findUniqueOrThrow(filtered), '${name}', filtered, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`;

    const readMethods = `
    // Wrapped methods with filter injection and to-one post-processing
    findMany: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      const filtered = injectFilters(pp, '${name}');
      return postProcessRead(original.findMany(filtered), '${name}', filtered, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['findMany'],
    findFirst: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      const filtered = injectFilters(pp, '${name}');
      return postProcessRead(original.findFirst(filtered), '${name}', filtered, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['findFirst'],
    findFirstOrThrow: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      const filtered = injectFilters(pp, '${name}');
      return postProcessRead(original.findFirstOrThrow(filtered), '${name}', filtered, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['findFirstOrThrow'],${findUniqueMethods}
    count: ((...args: any[]) => original.count(injectFilters(args[0], '${name}'))) as PrismaClient['${lowerName}']['count'],
    aggregate: ((...args: any[]) => original.aggregate(injectFilters(args[0], '${name}'))) as PrismaClient['${lowerName}']['aggregate'],
    groupBy: ((...args: any[]) => original.groupBy(injectFilters(args[0], '${name}'))) as PrismaClient['${lowerName}']['groupBy'],`;

    const createMethods = options.uniqueStrategy === 'sentinel'
      ? `
    // Create methods - inject sentinel value for deleted_at, post-process to-one relations
    create: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      const withSentinel = { ...pp, data: { ...pp?.data, ['${deletedAtField}']: pp?.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE } };
      return postProcessRead(original.create(withSentinel), '${name}', withSentinel, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['create'],
    createMany: ((args: any) => {
      const data = Array.isArray(args.data)
        ? args.data.map((d: any) => ({ ...d, ['${deletedAtField}']: d['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }))
        : { ...args.data, ['${deletedAtField}']: args.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE };
      return original.createMany({ ...args, data });
    }) as PrismaClient['${lowerName}']['createMany'],
    createManyAndReturn: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      const data = Array.isArray(pp?.data)
        ? pp.data.map((d: any) => ({ ...d, ['${deletedAtField}']: d['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }))
        : { ...pp?.data, ['${deletedAtField}']: pp?.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE };
      return postProcessRead(original.createManyAndReturn({ ...pp, data }), '${name}', pp, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['createManyAndReturn'],`
      : `
    // Create methods with to-one post-processing
    create: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      return postProcessRead(original.create(pp), '${name}', pp, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['create'],
    createMany: ((args: any) => original.createMany(args)) as PrismaClient['${lowerName}']['createMany'],
    createManyAndReturn: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      return postProcessRead(original.createManyAndReturn(pp), '${name}', pp, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['createManyAndReturn'],`;

    const upsertMethod = options.uniqueStrategy === 'sentinel'
      ? `
    upsert: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      const filtered = injectFilters({
        ...pp,
        create: { ...pp?.create, ['${deletedAtField}']: pp?.create?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }
      }, '${name}');
      if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${name}');
      return postProcessRead(original.upsert(filtered), '${name}', filtered, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['upsert'],`
      : `
    upsert: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      const filtered = injectFilters(pp, '${name}');
      return postProcessRead(original.upsert(filtered), '${name}', filtered, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['upsert'],`;

    const writeMethods = `${createMethods}
    update: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      const filtered = injectFilters(pp, '${name}');
      return postProcessRead(original.update(filtered), '${name}', filtered, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['update'],
    updateMany: ((args: any) => original.updateMany(injectFilters(args, '${name}'))) as PrismaClient['${lowerName}']['updateMany'],
    updateManyAndReturn: ((...args: any[]) => {
      const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${name}');
      const filtered = injectFilters(pp, '${name}');
      return postProcessRead(original.updateManyAndReturn(filtered), '${name}', filtered, injectedPaths) as any;
    }) as PrismaClient['${lowerName}']['updateManyAndReturn'],${upsertMethod}
    fields: original.fields,`;

    let restoreMethods: string;
    if (model.isAuditable && hasAudit) {
      restoreMethods = `
    // Restore methods (audited)
    restore: (async (args: any) => {
      const { actorId, auditContext: callCtx, ...rest } = args;
      const { where, ...restProjection } = rest;
      const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${name}');
      return prisma.$transaction(async (tx: Prisma.TransactionClient) => {
        const record = await restoreRecordInTx(tx, '${name}', where, projection);
        const processed = await postProcessRead(Promise.resolve(record), '${name}', { where, ...projection }, injectedPaths);
        if (isAuditable('${name}', 'update') && processed) {
          const ctx = await _mergeAuditContext(wrapOptions, callCtx);
          await writeAuditEvent(tx, '${name}', getEntityId('${name}', processed), 'restore', actorId ?? null, processed, undefined, ctx);
        }
        return processed;
      });
    }) as Safe${name}Delegate['restore'],
    restoreMany: (async (args: any) => {
      const { actorId, auditContext: callCtx, ...rest } = args;
      return prisma.$transaction(async (tx: Prisma.TransactionClient) => {
        const deletedAtField = getDeletedAtField('${name}');
        const recordsBefore = isAuditable('${name}', 'update')
          ? await tx.${lowerName}.findMany({ where: { ...decomposeCompoundKeyWhere('${name}', rest.where), [deletedAtField!]: { not: ACTIVE_DELETED_AT_VALUE } } })
          : [];
        const result = await restoreManyInTx(tx, '${name}', rest.where);
        if (isAuditable('${name}', 'update') && recordsBefore.length > 0) {
          const ctx = await _mergeAuditContext(wrapOptions, callCtx);
          await Promise.all(recordsBefore.map((record: any) =>
            writeAuditEvent(tx, '${name}', getEntityId('${name}', record), 'restore', actorId ?? null, record, undefined, ctx),
          ));
        }
        return result;
      });
    }) as Safe${name}Delegate['restoreMany'],
    restoreCascade: (async (args: any) => {
      const { actorId, auditContext: callCtx, ...rest } = args;
      const { where, ...restProjection } = rest;
      const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${name}');
      return prisma.$transaction(async (tx: Prisma.TransactionClient) => {
        const { record, cascaded } = await restoreWithCascadeInTx(tx, '${name}', where, projection, actorId ?? null, wrapOptions, callCtx);
        const processed = await postProcessRead(Promise.resolve(record), '${name}', { where, ...projection }, injectedPaths);
        if (isAuditable('${name}', 'update') && processed) {
          const ctx = await _mergeAuditContext(wrapOptions, callCtx);
          await writeAuditEvent(tx, '${name}', getEntityId('${name}', processed), 'restore', actorId ?? null, processed, undefined, ctx);
        }
        return { record: processed, cascaded };
      });
    }) as Safe${name}Delegate['restoreCascade'],`;
    } else {
      restoreMethods = `
    // Restore methods
    restore: (async (args: any) => {
      const { where, ...restProjection } = args;
      const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${name}');
      const record = await restoreRecord(prisma, '${name}', where, projection);
      return postProcessRead(Promise.resolve(record), '${name}', { where, ...projection }, injectedPaths);
    }) as Safe${name}Delegate['restore'],
    restoreMany: (async (args: any) => {
      return restoreManyRecords(prisma, '${name}', args.where);
    }) as Safe${name}Delegate['restoreMany'],
    restoreCascade: (async (args: any) => {
      const { where, ...restProjection } = args;
      const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${name}');
      const { record, cascaded } = await restoreWithCascade(prisma, '${name}', where, projection);
      const processed = await postProcessRead(Promise.resolve(record), '${name}', { where, ...projection }, injectedPaths);
      return { record: processed, cascaded };
    }) as Safe${name}Delegate['restoreCascade'],`;
    }

    let hardDeleteMethods: string;
    if (model.isAuditable && hasAudit) {
      hardDeleteMethods = `
    // Hard delete with audit (intentionally ugly name to discourage use)
    __dangerousHardDelete: (async (args: any) => {
      const { actorId, auditContext: callCtx, ...rest } = args;
      return prisma.$transaction(async (tx: Prisma.TransactionClient) => _auditedHardDelete(tx, tx.${lowerName}, rest, '${name}', actorId ?? null, wrapOptions, callCtx));
    }) as Safe${name}Delegate['__dangerousHardDelete'],
    __dangerousHardDeleteMany: (async (args: any) => {
      const { actorId, auditContext: callCtx, ...rest } = args;
      return prisma.$transaction(async (tx: Prisma.TransactionClient) => _auditedHardDeleteMany(tx, tx.${lowerName}, rest, '${name}', actorId ?? null, wrapOptions, callCtx));
    }) as Safe${name}Delegate['__dangerousHardDeleteMany'],`;
    } else {
      hardDeleteMethods = `
    // Hard delete (intentionally ugly name to discourage use)
    __dangerousHardDelete: ((args: any) => original.delete(args)) as PrismaClient['${lowerName}']['delete'],
    __dangerousHardDeleteMany: ((args: any) => original.deleteMany(args)) as PrismaClient['${lowerName}']['deleteMany'],`;
    }

    const includingDeletedMethods = `
    // Access raw delegate without soft-delete filtering
    includingDeleted: {
      findMany: ((args?: any) => original.findMany(args)) as PrismaClient['${lowerName}']['findMany'],
      findFirst: ((args?: any) => original.findFirst(args)) as PrismaClient['${lowerName}']['findFirst'],
      findFirstOrThrow: ((args?: any) => original.findFirstOrThrow(args)) as PrismaClient['${lowerName}']['findFirstOrThrow'],
      findUnique: ((args?: any) => original.findUnique(args)) as PrismaClient['${lowerName}']['findUnique'],
      findUniqueOrThrow: ((args?: any) => original.findUniqueOrThrow(args)) as PrismaClient['${lowerName}']['findUniqueOrThrow'],
      count: ((args?: any) => original.count(args)) as PrismaClient['${lowerName}']['count'],
      aggregate: ((args?: any) => original.aggregate(args)) as PrismaClient['${lowerName}']['aggregate'],
      groupBy: ((args?: any) => original.groupBy(args)) as PrismaClient['${lowerName}']['groupBy'],
    },`;

    // For audited models, the user-facing parameter is actorId (which also sets deleted_by).
    // For non-audited models, the parameter is deletedBy.
    const identityField = model.isAuditable && hasAudit ? 'actorId' : 'deletedBy';

    let softDeleteMethods: string;
    let previewMethod: string;

    if (simple) {
      // Fast path: use updateMany directly (no cascade children, no unique mangling)
      const deletedByUpdate = model.deletedByField !== null
        ? `\n      const deletedByField = ${JSON.stringify(model.deletedByField)};\n      if (deletedByField && ${identityField}) {\n        updateData[deletedByField] = ${identityField};\n      }`
        : '';

      if (model.isAuditable && hasAudit) {
        // Audited simple path: wrap in transaction for atomic audit event writing
        const deletedByUpdateTx = model.deletedByField !== null
          ? `\n        const deletedByField = ${JSON.stringify(model.deletedByField)};\n        if (deletedByField && actorId) {\n          updateData[deletedByField] = actorId;\n        }`
          : '';
        softDeleteMethods = `
    // Soft delete methods (fast path, audited)
    softDelete: (async (args: any) => {
      const { actorId, auditContext: callCtx, ...rest } = args;
      const { where, ...restProjection } = rest;
      const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${name}');
      return prisma.$transaction(async (tx: Prisma.TransactionClient) => {
        const decomposedWhere = decomposeCompoundKeyWhere('${name}', where);
        // Capture pre-mutation snapshot for audit (full record, no projection)
        const preMutationSnapshot = await tx.${lowerName}.findFirst({ where: { ...decomposedWhere, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE } });
        const now = new Date();
        const updateData: Record<string, unknown> = { ['${deletedAtField}']: now };${deletedByUpdateTx}
        const result = await tx.${lowerName}.updateMany({
          where: { ...decomposedWhere, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },
          data: updateData,
        });
        throwIfNotFound(result.count, '${name}');
        const record = await tx.${lowerName}.findFirst({ where: decomposedWhere, ...projection });
        const processed = await postProcessRead(Promise.resolve(record), '${name}', { where: decomposedWhere, ...projection }, injectedPaths);
        if (isAuditable('${name}', 'delete') && preMutationSnapshot) {
          const ctx = await _mergeAuditContext(wrapOptions, callCtx);
          await writeAuditEvent(tx, '${name}', getEntityId('${name}', preMutationSnapshot), 'soft_delete', actorId ?? null, preMutationSnapshot, undefined, ctx);
        }
        return { record: processed, cascaded: {} };
      });
    }) as Safe${name}Delegate['softDelete'],
    softDeleteMany: (async (args: any) => {
      const { actorId, auditContext: callCtx, ...rest } = args;
      return prisma.$transaction(async (tx: Prisma.TransactionClient) => {
        const updateData: Record<string, unknown> = { ['${deletedAtField}']: new Date() };${deletedByUpdateTx}
        const decomposedWhere = decomposeCompoundKeyWhere('${name}', rest.where);
        const records = isAuditable('${name}', 'delete')
          ? await tx.${lowerName}.findMany({ where: { ...decomposedWhere, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE } })
          : [];
        const result = await tx.${lowerName}.updateMany({
          where: { ...decomposedWhere, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },
          data: updateData,
        });
        if (isAuditable('${name}', 'delete') && records.length > 0) {
          const ctx = await _mergeAuditContext(wrapOptions, callCtx);
          await Promise.all(records.map((record: any) =>
            writeAuditEvent(tx, '${name}', getEntityId('${name}', record), 'soft_delete', actorId ?? null, record, undefined, ctx),
          ));
        }
        return { count: result.count, cascaded: {} };
      });
    }) as Safe${name}Delegate['softDeleteMany'],`;
      } else {
        softDeleteMethods = `
    // Soft delete methods (fast path - no cascade children, no unique mangling)
    softDelete: (async (args: any) => {
      const { ${identityField}, ...rest } = args;
      const { where, ...restProjection } = rest;
      const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${name}');
      return prisma.$transaction(async (tx: Prisma.TransactionClient) => {
        const decomposedWhere = decomposeCompoundKeyWhere('${name}', where);
        const now = new Date();
        const updateData: Record<string, unknown> = { ['${deletedAtField}']: now };${deletedByUpdate}
        const result = await tx.${lowerName}.updateMany({
          where: { ...decomposedWhere, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },
          data: updateData,
        });
        throwIfNotFound(result.count, '${name}');
        const record = await tx.${lowerName}.findFirst({ where: decomposedWhere, ...projection });
        const processed = await postProcessRead(Promise.resolve(record), '${name}', { where: decomposedWhere, ...projection }, injectedPaths);
        return { record: processed, cascaded: {} };
      });
    }) as Safe${name}Delegate['softDelete'],
    softDeleteMany: (async (args: any) => {
      const { ${identityField}, ...rest } = args;
      return prisma.$transaction(async (tx: Prisma.TransactionClient) => {
        const updateData: Record<string, unknown> = { ['${deletedAtField}']: new Date() };${deletedByUpdate}
        const result = await tx.${lowerName}.updateMany({
          where: { ...rest.where, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },
          data: updateData,
        });
        return { count: result.count, cascaded: {} };
      });
    }) as Safe${name}Delegate['softDeleteMany'],`;
      }

      previewMethod = `
    // Preview soft delete (read-only)
    softDeletePreview: (async (args: any) => {
      const count = await original.count({
        where: { ...args.where, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },
      });
      return { wouldDelete: count > 0 ? { ['${name}']: count } : {} };
    }) as Safe${name}Delegate['softDeletePreview'],`;
    } else {
      if (model.isAuditable && hasAudit) {
        // Audited complex path: use softDeleteWithCascadeInTx within broader transaction
        softDeleteMethods = `
    // Soft delete methods (with cascade support, audited)
    softDelete: (async (args: any) => {
      const { actorId, auditContext: callCtx, ...rest } = args;
      const { where, ...restProjection } = rest;
      const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${name}');
      return prisma.$transaction(async (tx: Prisma.TransactionClient) => {
        // actorId is passed as deletedBy (4th arg) to set the model's deleted_by field,
        // and as auditActorId (5th arg, coerced to null if undefined) to populate the
        // audit event's actor_id. null auditActorId still writes the audit event (actor unknown).
        const { count, cascaded } = await softDeleteWithCascadeInTx(tx, '${name}', where, actorId, actorId ?? null, wrapOptions, callCtx);
        throwIfNotFound(count, '${name}');
        const decomposedWhere = decomposeCompoundKeyWhere('${name}', where);
        const record = await tx.${lowerName}.findFirst({ where: decomposedWhere, ...projection });
        const processed = await postProcessRead(Promise.resolve(record), '${name}', { where: decomposedWhere, ...projection }, injectedPaths);
        return { record: processed, cascaded };
      });
    }) as Safe${name}Delegate['softDelete'],
    softDeleteMany: (async (args: any) => {
      const { actorId, auditContext: callCtx, ...rest } = args;
      return prisma.$transaction(async (tx: Prisma.TransactionClient) => {
        const { count, cascaded } = await softDeleteWithCascadeInTx(tx, '${name}', rest.where, actorId, actorId ?? null, wrapOptions, callCtx);
        return { count, cascaded };
      });
    }) as Safe${name}Delegate['softDeleteMany'],`;
      } else {
        // Complex path: use softDeleteWithCascadeInTx (within transaction for atomicity)
        softDeleteMethods = `
    // Soft delete methods (with cascade support)
    softDelete: (async (args: any) => {
      const { ${identityField}, ...rest } = args;
      const { where, ...restProjection } = rest;
      const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${name}');
      return prisma.$transaction(async (tx: Prisma.TransactionClient) => {
        const { count, cascaded } = await softDeleteWithCascadeInTx(tx, '${name}', where, ${identityField});
        throwIfNotFound(count, '${name}');
        const decomposedWhere = decomposeCompoundKeyWhere('${name}', where);
        const record = await tx.${lowerName}.findFirst({ where: decomposedWhere, ...projection });
        const processed = await postProcessRead(Promise.resolve(record), '${name}', { where: decomposedWhere, ...projection }, injectedPaths);
        return { record: processed, cascaded };
      });
    }) as Safe${name}Delegate['softDelete'],
    softDeleteMany: (async (args: any) => {
      const { ${identityField}, ...rest } = args;
      return prisma.$transaction(async (tx: Prisma.TransactionClient) => {
        const { count, cascaded } = await softDeleteWithCascadeInTx(tx, '${name}', rest.where, ${identityField});
        return { count, cascaded };
      });
    }) as Safe${name}Delegate['softDeleteMany'],`;
      }

      previewMethod = `
    // Preview soft delete with cascade (read-only)
    softDeletePreview: (async (args: any) => {
      return previewSoftDelete(prisma, '${name}', args.where);
    }) as Safe${name}Delegate['softDeletePreview'],`;
    }

    // For audited + soft-deletable models, we need to wrap write methods
    // to extract actorId and write audit events
    let auditedWriteMethods = '';
    if (model.isAuditable && hasAudit) {
      auditedWriteMethods = emitAuditedWriteMethods(model, options);
    }

    const wrapOptsParam = hasAudit ? 'wrapOptions?: WrapOptions' : '';

    return `
/**
 * Creates a safe delegate for ${name} with soft-delete support
 */
function create${name}Delegate(prisma: PrismaClient${wrapOptsParam ? ', ' + wrapOptsParam : ''}): Safe${name}Delegate {
  const original = prisma.${lowerName};

  return {${readMethods}
${model.isAuditable && hasAudit ? auditedWriteMethods : writeMethods}
${softDeleteMethods}
${previewMethod}
${restoreMethods}
${hardDeleteMethods}
${includingDeletedMethods}
  };
}`.trim();
  }

  // Audit-only model (no soft-delete)
  if (model.isAuditable && hasAudit) {
    return emitAuditOnlyDelegate(model, lowerName, options);
  }

  // Audit table model: read-only delegate to prevent tampering with audit trail
  if (model.isAuditTable) {
    return `
/**
 * Creates a read-only delegate for ${name} (audit table)
 */
function create${name}Delegate(prisma: PrismaClient${hasAudit ? ', wrapOptions?: WrapOptions' : ''}): Safe${name}Delegate {
  const original = prisma.${lowerName};
  return {
    findMany: original.findMany.bind(original),
    findFirst: original.findFirst.bind(original),
    findFirstOrThrow: original.findFirstOrThrow.bind(original),
    findUnique: original.findUnique.bind(original),
    findUniqueOrThrow: original.findUniqueOrThrow.bind(original),
    count: original.count.bind(original),
    aggregate: original.aggregate.bind(original),
    groupBy: original.groupBy.bind(original),
  } as Safe${name}Delegate;
}`.trim();
  }

  return `
/**
 * Creates a delegate for ${name} (no soft-delete)
 */
function create${name}Delegate(prisma: PrismaClient${hasAudit ? ', wrapOptions?: WrapOptions' : ''}): Safe${name}Delegate {
  return prisma.${lowerName};
}`.trim();
}

/**
 * Method descriptors for audited methods. Maps Prisma method names to their audit action
 * and helper function name.
 */
interface AuditMethodDescriptor {
  method: string;
  action: 'create' | 'update' | 'delete' | 'upsert';
  helper: string;
}

const AUDIT_WRITE_METHODS: AuditMethodDescriptor[] = [
  { method: 'create', action: 'create', helper: '_auditedCreate' },
  { method: 'createMany', action: 'create', helper: '_auditedCreateMany' },
  { method: 'createManyAndReturn', action: 'create', helper: '_auditedCreateManyAndReturn' },
  { method: 'update', action: 'update', helper: '_auditedUpdate' },
  { method: 'updateMany', action: 'update', helper: '_auditedUpdateMany' },
  { method: 'updateManyAndReturn', action: 'update', helper: '_auditedUpdateManyAndReturn' },
  { method: 'upsert', action: 'upsert', helper: '_auditedUpsert' },
];

const AUDIT_DELETE_METHODS: AuditMethodDescriptor[] = [
  { method: 'delete', action: 'delete', helper: '_auditedDelete' },
  { method: 'deleteMany', action: 'delete', helper: '_auditedDeleteMany' },
];

/**
 * Generates a single audited method call site.
 *
 * context.wrapInTransaction: true for main delegate (wraps in prisma.$transaction)
 * context.indent: indentation prefix
 *
 * Soft-deletable behavior (injectFilters, postProcessRead, etc.) is derived from model.isSoftDeletable.
 */
function emitAuditedMethodCallSite(
  lines: string[],
  desc: AuditMethodDescriptor,
  model: SoftDeletableModel | AuditOnlyModel,
  options: EmitRuntimeOptions,
  context: {
    wrapInTransaction: boolean;
    indent: string;
    delegateExpr: string; // e.g. 'prisma' or 'tx'
  },
): void {
  const { method, action, helper } = desc;
  const name = model.name;
  const lowerName = toLowerFirst(name);
  const ind = context.indent;
  const softDeletable = model.isSoftDeletable;
  const isAuditableAction = action === 'upsert' || model.auditActions.includes(action);

  // For non-auditable actions, emit a simple passthrough that strips actorId
  if (!isAuditableAction) {
    if (model.isSoftDeletable) {
      emitNonAuditedSoftDeletablePassthrough(lines, method, name, lowerName, model, options, context);
    } else {
      lines.push(`${ind}${method}: (async (args: any) => {`);
      lines.push(`${ind}  const { actorId, auditContext: _callCtx, ...rest } = args;`);
      lines.push(`${ind}  return ${context.delegateExpr}.${lowerName}.${method}(rest);`);
      lines.push(`${ind}}) as Safe${name}Delegate['${method}'],`);
    }
    return;
  }

  // For auditable actions, call the _audited* helper
  const needsPostProcess = softDeletable && ['create', 'createManyAndReturn', 'update', 'updateManyAndReturn', 'upsert'].includes(method);
  const needsInjectFilters = softDeletable && ['update', 'updateMany', 'updateManyAndReturn', 'upsert'].includes(method);
  const needsInjectToOne = softDeletable && ['create', 'createManyAndReturn', 'update', 'updateManyAndReturn', 'upsert'].includes(method);
  // After narrowing via model.isSoftDeletable, deletedAtField is string (never null)
  const deletedAtField = model.isSoftDeletable ? model.deletedAtField : null;

  lines.push(`${ind}${method}: (async (args: any) => {`);
  lines.push(`${ind}  const { actorId, auditContext: callCtx, ...rest } = args;`);

  // Build the args to pass to the helper
  let argsExpr = 'rest';
  let ppInjected = false;

  if (needsInjectToOne) {
    lines.push(`${ind}  const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(rest, '${name}');`);
    ppInjected = true;
    argsExpr = 'pp';
  }

  if (needsInjectFilters) {
    if (method === 'upsert' && options.uniqueStrategy === 'sentinel' && deletedAtField !== null) {
      lines.push(`${ind}  const filtered = injectFilters({`);
      lines.push(`${ind}    ...${argsExpr},`);
      lines.push(`${ind}    create: { ...${argsExpr}?.create, ['${deletedAtField}']: ${argsExpr}?.create?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }`);
      lines.push(`${ind}  }, '${name}');`);
      lines.push(`${ind}  if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${name}');`);
    } else {
      lines.push(`${ind}  const filtered = injectFilters(${argsExpr}, '${name}');`);
    }
    argsExpr = 'filtered';
  }

  // Sentinel create handling
  if (softDeletable && options.uniqueStrategy === 'sentinel' && deletedAtField !== null) {
    if (method === 'create') {
      lines.push(`${ind}  const withSentinel = { ...${argsExpr}, data: { ...${argsExpr}?.data, ['${deletedAtField}']: ${argsExpr}?.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE } };`);
      argsExpr = 'withSentinel';
    } else if (method === 'createMany' || method === 'createManyAndReturn') {
      lines.push(`${ind}  const data = Array.isArray(${argsExpr}${ppInjected ? '?' : ''}.data)`);
      lines.push(`${ind}    ? ${argsExpr}.data.map((d: any) => ({ ...d, ['${deletedAtField}']: d['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }))`);
      lines.push(`${ind}    : { ...${argsExpr}${ppInjected ? '?' : ''}.data, ['${deletedAtField}']: ${argsExpr}${ppInjected ? '?' : ''}.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE };`);
      lines.push(`${ind}  const withSentinel = { ...${argsExpr}, data };`);
      argsExpr = 'withSentinel';
    }
  }

  // Build the helper call
  const txExpr = context.wrapInTransaction ? 'tx' : context.delegateExpr;
  const delegateAccess = `${txExpr}.${lowerName}`;
  const helperCall = `${helper}(${txExpr}, ${delegateAccess}, ${argsExpr}, '${name}', actorId ?? null, wrapOptions, callCtx)`;

  if (context.wrapInTransaction) {
    if (needsPostProcess) {
      lines.push(`${ind}  return prisma.$transaction(async (tx: Prisma.TransactionClient) => {`);
      lines.push(`${ind}    const result = await ${helperCall};`);
      lines.push(`${ind}    return postProcessRead(Promise.resolve(result), '${name}', ${argsExpr}, ${ppInjected ? 'injectedPaths' : '[]'});`);
      lines.push(`${ind}  });`);
    } else {
      lines.push(`${ind}  return prisma.$transaction(async (tx: Prisma.TransactionClient) => ${helperCall});`);
    }
  } else {
    if (needsPostProcess) {
      lines.push(`${ind}  const result = await ${helperCall};`);
      lines.push(`${ind}  return postProcessRead(Promise.resolve(result), '${name}', ${argsExpr}, ${ppInjected ? 'injectedPaths' : '[]'});`);
    } else {
      lines.push(`${ind}  return ${helperCall};`);
    }
  }

  lines.push(`${ind}}) as Safe${name}Delegate['${method}'],`);
}

/**
 * Emits a non-audited passthrough for a soft-deletable model method.
 * These are methods where the action is not in the model's auditActions,
 * so they just strip actorId and do normal soft-delete processing.
 */
function emitNonAuditedSoftDeletablePassthrough(
  lines: string[],
  method: string,
  name: string,
  lowerName: string,
  model: SoftDeletableModel,
  options: EmitRuntimeOptions,
  context: {
    wrapInTransaction: boolean;
    indent: string;
    delegateExpr: string;
  },
): void {
  const ind = context.indent;
  const d = context.wrapInTransaction ? `prisma.${lowerName}` : `${context.delegateExpr}.${lowerName}`;
  const isSentinel = options.uniqueStrategy === 'sentinel';
  const deletedAtField = model.deletedAtField;
  // Reproduce the standard soft-deletable write method, just strip actorId + auditContext first
  lines.push(`${ind}${method}: (async (args: any) => {`);
  lines.push(`${ind}  const { actorId, auditContext: _callCtx, ...rest } = args;`);

  switch (method) {
    case 'create': {
      lines.push(`${ind}  const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(rest, '${name}');`);
      if (isSentinel) {
        lines.push(`${ind}  const withSentinel = { ...pp, data: { ...pp?.data, ['${deletedAtField}']: pp?.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE } };`);
        lines.push(`${ind}  return postProcessRead(${d}.create(withSentinel), '${name}', withSentinel, injectedPaths) as any;`);
      } else {
        lines.push(`${ind}  return postProcessRead(${d}.create(pp), '${name}', pp, injectedPaths) as any;`);
      }
      break;
    }
    case 'createMany': {
      if (isSentinel) {
        lines.push(`${ind}  const data = Array.isArray(rest.data)`);
        lines.push(`${ind}    ? rest.data.map((d: any) => ({ ...d, ['${deletedAtField}']: d['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }))`);
        lines.push(`${ind}    : { ...rest.data, ['${deletedAtField}']: rest.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE };`);
        lines.push(`${ind}  return ${d}.createMany({ ...rest, data });`);
      } else {
        lines.push(`${ind}  return ${d}.createMany(rest);`);
      }
      break;
    }
    case 'createManyAndReturn': {
      lines.push(`${ind}  const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(rest, '${name}');`);
      if (isSentinel) {
        lines.push(`${ind}  const data = Array.isArray(pp.data)`);
        lines.push(`${ind}    ? pp.data.map((d: any) => ({ ...d, ['${deletedAtField}']: d['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }))`);
        lines.push(`${ind}    : { ...pp.data, ['${deletedAtField}']: pp.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE };`);
        lines.push(`${ind}  const withSentinel = { ...pp, data };`);
        lines.push(`${ind}  return postProcessRead(${d}.createManyAndReturn(withSentinel), '${name}', withSentinel, injectedPaths) as any;`);
      } else {
        lines.push(`${ind}  return postProcessRead(${d}.createManyAndReturn(pp), '${name}', pp, injectedPaths) as any;`);
      }
      break;
    }
    case 'update': {
      lines.push(`${ind}  const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(rest, '${name}');`);
      lines.push(`${ind}  const filtered = injectFilters(pp, '${name}');`);
      lines.push(`${ind}  return postProcessRead(${d}.update(filtered), '${name}', filtered, injectedPaths) as any;`);
      break;
    }
    case 'updateMany': {
      lines.push(`${ind}  return ${d}.updateMany(injectFilters(rest, '${name}'));`);
      break;
    }
    case 'updateManyAndReturn': {
      lines.push(`${ind}  const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(rest, '${name}');`);
      lines.push(`${ind}  const filtered = injectFilters(pp, '${name}');`);
      lines.push(`${ind}  return postProcessRead(${d}.updateManyAndReturn(filtered), '${name}', filtered, injectedPaths) as any;`);
      break;
    }
    case 'upsert': {
      lines.push(`${ind}  const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(rest, '${name}');`);
      if (isSentinel) {
        lines.push(`${ind}  const filtered = injectFilters({`);
        lines.push(`${ind}    ...pp,`);
        lines.push(`${ind}    create: { ...pp?.create, ['${deletedAtField}']: pp?.create?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }`);
        lines.push(`${ind}  }, '${name}');`);
        lines.push(`${ind}  if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${name}');`);
      } else {
        lines.push(`${ind}  const filtered = injectFilters(pp, '${name}');`);
      }
      lines.push(`${ind}  return postProcessRead(${d}.upsert(filtered), '${name}', filtered, injectedPaths) as any;`);
      break;
    }
  }

  lines.push(`${ind}}) as Safe${name}Delegate['${method}'],`);
}

/**
 * Emits audited write methods for a soft-deletable + audited model (main delegate).
 * Uses shared _audited* helpers via emitAuditedMethodCallSite.
 */
function emitAuditedWriteMethods(model: SoftDeletableModel, options: EmitRuntimeOptions): string {
  const lines: string[] = [];
  const context = {
    wrapInTransaction: true,
    indent: '    ',
    delegateExpr: 'prisma',
  };

  for (const desc of AUDIT_WRITE_METHODS) {
    emitAuditedMethodCallSite(lines, desc, model, options, context);
  }

  lines.push(`    fields: original.fields,`);

  return '\n' + lines.join('\n');
}

/**
 * Emits a delegate for an audit-only model (no soft-delete).
 * Uses shared _audited* helpers via emitAuditedMethodCallSite.
 */
function emitAuditOnlyDelegate(model: AuditOnlyModel, lowerName: string, options: EmitRuntimeOptions): string {
  const name = model.name;
  const lines: string[] = [];
  const allDescs = [...AUDIT_WRITE_METHODS, ...AUDIT_DELETE_METHODS];
  const context = {
    wrapInTransaction: true,
    indent: '    ',
    delegateExpr: 'prisma',
  };

  lines.push(`/**`);
  lines.push(` * Creates an audit-enabled delegate for ${name}`);
  lines.push(` */`);
  lines.push(`function create${name}Delegate(prisma: PrismaClient, wrapOptions?: WrapOptions): Safe${name}Delegate {`);
  lines.push(`  const original = prisma.${lowerName};`);
  lines.push(``);
  lines.push(`  return {`);
  lines.push(`    ...original,`);

  for (const desc of allDescs) {
    emitAuditedMethodCallSite(lines, desc, model, options, context);
  }

  lines.push(`  } as Safe${name}Delegate;`);
  lines.push(`}`);

  return lines.join('\n');
}

function emitIncludingDeletedClient(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Creates a client that includes soft-deleted records with filter propagation');
  lines.push(' */');
  lines.push('function createIncludingDeletedClient(prisma: PrismaClient): IncludingDeletedClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    if (model.isSoftDeletable) {
      // Soft-deletable models need wrapped methods to propagate 'include-deleted' mode
      lines.push(`    ${lowerName}: {`);
      lines.push(`      findMany: ((...args: any[]) => prisma.${lowerName}.findMany(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findMany'],`);
      lines.push(`      findFirst: ((...args: any[]) => prisma.${lowerName}.findFirst(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findFirst'],`);
      lines.push(`      findFirstOrThrow: ((...args: any[]) => prisma.${lowerName}.findFirstOrThrow(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findFirstOrThrow'],`);
      lines.push(`      findUnique: ((...args: any[]) => prisma.${lowerName}.findUnique(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findUnique'],`);
      lines.push(`      findUniqueOrThrow: ((...args: any[]) => prisma.${lowerName}.findUniqueOrThrow(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      lines.push(`      count: ((...args: any[]) => prisma.${lowerName}.count(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['count'],`);
      lines.push(`      aggregate: ((...args: any[]) => prisma.${lowerName}.aggregate(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['aggregate'],`);
      lines.push(`      groupBy: ((...args: any[]) => prisma.${lowerName}.groupBy(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['groupBy'],`);
      lines.push(`    },`);
    } else if (model.isAuditTable) {
      // Audit table: read-only in $includingDeleted too
      lines.push(`    ${lowerName}: create${model.name}Delegate(prisma),`);
    } else {
      // Non-soft-deletable models can use raw delegate
      lines.push(`    ${lowerName}: prisma.${lowerName},`);
    }
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitOnlyDeletedClient(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Creates a client that queries only soft-deleted records with filter propagation');
  lines.push(' */');
  lines.push('function createOnlyDeletedClient(prisma: PrismaClient): OnlyDeletedClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    if (model.isSoftDeletable) {
      const lowerName = toLowerFirst(model.name);
      lines.push(`    ${lowerName}: {`);
      lines.push(`      findMany: ((...args: any[]) => {`);
      lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
      lines.push(`        const filtered = injectFilters(pp, '${model.name}', 'only-deleted');`);
      lines.push(`        return postProcessReadOnlyDeleted(prisma.${lowerName}.findMany(filtered), injectedPaths) as any;`);
      lines.push(`      }) as PrismaClient['${lowerName}']['findMany'],`);
      lines.push(`      findFirst: ((...args: any[]) => {`);
      lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
      lines.push(`        const filtered = injectFilters(pp, '${model.name}', 'only-deleted');`);
      lines.push(`        return postProcessReadOnlyDeleted(prisma.${lowerName}.findFirst(filtered), injectedPaths) as any;`);
      lines.push(`      }) as PrismaClient['${lowerName}']['findFirst'],`);
      lines.push(`      findFirstOrThrow: ((...args: any[]) => {`);
      lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
      lines.push(`        const filtered = injectFilters(pp, '${model.name}', 'only-deleted');`);
      lines.push(`        return postProcessReadOnlyDeleted(prisma.${lowerName}.findFirstOrThrow(filtered), injectedPaths) as any;`);
      lines.push(`      }) as PrismaClient['${lowerName}']['findFirstOrThrow'],`);
      lines.push(`      findUnique: ((...args: any[]) => {`);
      lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
      lines.push(`        const filtered = injectFilters(pp, '${model.name}', 'only-deleted');`);
      lines.push(`        return postProcessReadOnlyDeleted(prisma.${lowerName}.findUnique(filtered), injectedPaths) as any;`);
      lines.push(`      }) as PrismaClient['${lowerName}']['findUnique'],`);
      lines.push(`      findUniqueOrThrow: ((...args: any[]) => {`);
      lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
      lines.push(`        const filtered = injectFilters(pp, '${model.name}', 'only-deleted');`);
      lines.push(`        return postProcessReadOnlyDeleted(prisma.${lowerName}.findUniqueOrThrow(filtered), injectedPaths) as any;`);
      lines.push(`      }) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      lines.push(`      count: ((...args: any[]) => prisma.${lowerName}.count(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['count'],`);
      lines.push(`      aggregate: ((...args: any[]) => prisma.${lowerName}.aggregate(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['aggregate'],`);
      lines.push(`      groupBy: ((...args: any[]) => prisma.${lowerName}.groupBy(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['groupBy'],`);
      lines.push(`    },`);
    }
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitTransactionWrapper(schema: ParsedSchema, options: EmitRuntimeOptions, hasAudit: boolean): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Wraps a transaction client with soft-delete filtering and full API');
  lines.push(' */');
  const wrapOptsParam = hasAudit ? ', wrapOptions?: WrapOptions' : '';
  lines.push(`function wrapTransactionClient(tx: Prisma.TransactionClient${wrapOptsParam}): SafeTransactionClient {`);
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    if (model.isSoftDeletable) {
      const simple = isSimpleModel(model, options);
      const deletedAtField = model.deletedAtField;
      lines.push(`    ${lowerName}: {`);
      // Read operations with filter injection and to-one post-processing
      lines.push(`      findMany: ((...args: any[]) => {`);
      lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
      lines.push(`        const filtered = injectFilters(pp, '${model.name}');`);
      lines.push(`        return postProcessRead(tx.${lowerName}.findMany(filtered), '${model.name}', filtered, injectedPaths) as any;`);
      lines.push(`      }) as PrismaClient['${lowerName}']['findMany'],`);
      lines.push(`      findFirst: ((...args: any[]) => {`);
      lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
      lines.push(`        const filtered = injectFilters(pp, '${model.name}');`);
      lines.push(`        return postProcessRead(tx.${lowerName}.findFirst(filtered), '${model.name}', filtered, injectedPaths) as any;`);
      lines.push(`      }) as PrismaClient['${lowerName}']['findFirst'],`);
      lines.push(`      findFirstOrThrow: ((...args: any[]) => {`);
      lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
      lines.push(`        const filtered = injectFilters(pp, '${model.name}');`);
      lines.push(`        return postProcessRead(tx.${lowerName}.findFirstOrThrow(filtered), '${model.name}', filtered, injectedPaths) as any;`);
      lines.push(`      }) as PrismaClient['${lowerName}']['findFirstOrThrow'],`);
      if (options.uniqueStrategy === 'sentinel') {
        lines.push(`      findUnique: ((...args: any[]) => {`);
        lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
        lines.push(`        const filtered = injectFilters(pp, '${model.name}');`);
        lines.push(`        if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${model.name}');`);
        lines.push(`        return postProcessRead(tx.${lowerName}.findUnique(filtered), '${model.name}', filtered, injectedPaths) as any;`);
        lines.push(`      }) as PrismaClient['${lowerName}']['findUnique'],`);
        lines.push(`      findUniqueOrThrow: ((...args: any[]) => {`);
        lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
        lines.push(`        const filtered = injectFilters(pp, '${model.name}');`);
        lines.push(`        if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${model.name}');`);
        lines.push(`        return postProcessRead(tx.${lowerName}.findUniqueOrThrow(filtered), '${model.name}', filtered, injectedPaths) as any;`);
        lines.push(`      }) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      } else {
        lines.push(`      findUnique: ((...args: any[]) => {`);
        lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
        lines.push(`        const filtered = injectFilters(pp, '${model.name}');`);
        lines.push(`        return postProcessRead(tx.${lowerName}.findUnique(filtered), '${model.name}', filtered, injectedPaths) as any;`);
        lines.push(`      }) as PrismaClient['${lowerName}']['findUnique'],`);
        lines.push(`      findUniqueOrThrow: ((...args: any[]) => {`);
        lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
        lines.push(`        const filtered = injectFilters(pp, '${model.name}');`);
        lines.push(`        return postProcessRead(tx.${lowerName}.findUniqueOrThrow(filtered), '${model.name}', filtered, injectedPaths) as any;`);
        lines.push(`      }) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      }
      lines.push(`      count: ((...args: any[]) => tx.${lowerName}.count(injectFilters(args[0], '${model.name}'))) as PrismaClient['${lowerName}']['count'],`);
      lines.push(`      aggregate: ((...args: any[]) => tx.${lowerName}.aggregate(injectFilters(args[0], '${model.name}'))) as PrismaClient['${lowerName}']['aggregate'],`);
      lines.push(`      groupBy: ((...args: any[]) => tx.${lowerName}.groupBy(injectFilters(args[0], '${model.name}'))) as PrismaClient['${lowerName}']['groupBy'],`);
      // Write operations with to-one post-processing
      if (model.isAuditable && hasAudit) {
        // Audited soft-deletable model: use shared _audited* helpers with tx directly
        const txAuditContext = {
          wrapInTransaction: false,
          indent: '      ',
          delegateExpr: 'tx',
        };
        for (const desc of AUDIT_WRITE_METHODS) {
          emitAuditedMethodCallSite(lines, desc, model, options, txAuditContext);
        }
      } else {
        // Non-audited: standard write operations with to-one post-processing
        if (options.uniqueStrategy === 'sentinel') {
          lines.push(`      create: ((...args: any[]) => {`);
          lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
          lines.push(`        const withSentinel = { ...pp, data: { ...pp?.data, ['${deletedAtField}']: pp?.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE } };`);
          lines.push(`        return postProcessRead(tx.${lowerName}.create(withSentinel), '${model.name}', withSentinel, injectedPaths) as any;`);
          lines.push(`      }) as PrismaClient['${lowerName}']['create'],`);
          lines.push(`      createMany: ((args: any) => {`);
          lines.push(`        const data = Array.isArray(args.data)`);
          lines.push(`          ? args.data.map((d: any) => ({ ...d, ['${deletedAtField}']: d['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }))`);
          lines.push(`          : { ...args.data, ['${deletedAtField}']: args.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE };`);
          lines.push(`        return tx.${lowerName}.createMany({ ...args, data });`);
          lines.push(`      }) as PrismaClient['${lowerName}']['createMany'],`);
          lines.push(`      createManyAndReturn: ((...args: any[]) => {`);
          lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
          lines.push(`        const data = Array.isArray(pp?.data)`);
          lines.push(`          ? pp.data.map((d: any) => ({ ...d, ['${deletedAtField}']: d['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }))`);
          lines.push(`          : { ...pp?.data, ['${deletedAtField}']: pp?.data?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE };`);
          lines.push(`        return postProcessRead(tx.${lowerName}.createManyAndReturn({ ...pp, data }), '${model.name}', pp, injectedPaths) as any;`);
          lines.push(`      }) as PrismaClient['${lowerName}']['createManyAndReturn'],`);
        } else {
          lines.push(`      create: ((...args: any[]) => {`);
          lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
          lines.push(`        return postProcessRead(tx.${lowerName}.create(pp), '${model.name}', pp, injectedPaths) as any;`);
          lines.push(`      }) as PrismaClient['${lowerName}']['create'],`);
          lines.push(`      createMany: ((args: any) => tx.${lowerName}.createMany(args)) as PrismaClient['${lowerName}']['createMany'],`);
          lines.push(`      createManyAndReturn: ((...args: any[]) => {`);
          lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
          lines.push(`        return postProcessRead(tx.${lowerName}.createManyAndReturn(pp), '${model.name}', pp, injectedPaths) as any;`);
          lines.push(`      }) as PrismaClient['${lowerName}']['createManyAndReturn'],`);
        }
        lines.push(`      update: ((...args: any[]) => {`);
        lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
        lines.push(`        const filtered = injectFilters(pp, '${model.name}');`);
        lines.push(`        return postProcessRead(tx.${lowerName}.update(filtered), '${model.name}', filtered, injectedPaths) as any;`);
        lines.push(`      }) as PrismaClient['${lowerName}']['update'],`);
        lines.push(`      updateMany: ((args: any) => tx.${lowerName}.updateMany(injectFilters(args, '${model.name}'))) as PrismaClient['${lowerName}']['updateMany'],`);
        lines.push(`      updateManyAndReturn: ((...args: any[]) => {`);
        lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
        lines.push(`        const filtered = injectFilters(pp, '${model.name}');`);
        lines.push(`        return postProcessRead(tx.${lowerName}.updateManyAndReturn(filtered), '${model.name}', filtered, injectedPaths) as any;`);
        lines.push(`      }) as PrismaClient['${lowerName}']['updateManyAndReturn'],`);
        if (options.uniqueStrategy === 'sentinel') {
          lines.push(`      upsert: ((...args: any[]) => {`);
          lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
          lines.push(`        const filtered = injectFilters({`);
          lines.push(`          ...pp,`);
          lines.push(`          create: { ...pp?.create, ['${deletedAtField}']: pp?.create?.['${deletedAtField}'] ?? ACTIVE_DELETED_AT_VALUE }`);
          lines.push(`        }, '${model.name}');`);
          lines.push(`        if (filtered.where) filtered.where = transformSentinelFindUniqueWhere(filtered.where, '${model.name}');`);
          lines.push(`        return postProcessRead(tx.${lowerName}.upsert(filtered), '${model.name}', filtered, injectedPaths) as any;`);
          lines.push(`      }) as PrismaClient['${lowerName}']['upsert'],`);
        } else {
          lines.push(`      upsert: ((...args: any[]) => {`);
          lines.push(`        const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
          lines.push(`        const filtered = injectFilters(pp, '${model.name}');`);
          lines.push(`        return postProcessRead(tx.${lowerName}.upsert(filtered), '${model.name}', filtered, injectedPaths) as any;`);
          lines.push(`      }) as PrismaClient['${lowerName}']['upsert'],`);
        }
      }
      lines.push(`      fields: tx.${lowerName}.fields,`);

      // For audited models, use actorId instead of deletedBy
      const identityField = model.isAuditable && hasAudit ? 'actorId' : 'deletedBy';
      if (simple) {
        if (model.isAuditable && hasAudit) {
          // Audited fast path in transaction: already inside tx, add audit event writing
          lines.push(`      softDelete: (async (args: any) => {`);
          lines.push(`        const { actorId, auditContext: callCtx, ...rest } = args;`);
          lines.push(`        const { where, ...restProjection } = rest;`);
          lines.push(`        const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${model.name}');`);
          lines.push(`        const decomposedWhere = decomposeCompoundKeyWhere('${model.name}', where);`);
          lines.push(`        // Capture pre-mutation snapshot for audit (full record, no projection)`);
          lines.push(`        const preMutationSnapshot = await tx.${lowerName}.findFirst({ where: { ...decomposedWhere, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE } });`);
          lines.push(`        const now = new Date();`);
          lines.push(`        const updateData: Record<string, unknown> = { ['${deletedAtField}']: now };`);
          if (model.deletedByField !== null) {
            lines.push(`        const deletedByField = ${JSON.stringify(model.deletedByField)};`);
            lines.push(`        if (deletedByField && actorId) {`);
            lines.push(`          updateData[deletedByField] = actorId;`);
            lines.push(`        }`);
          }
          lines.push(`        const result = await tx.${lowerName}.updateMany({`);
          lines.push(`          where: { ...decomposedWhere, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },`);
          lines.push(`          data: updateData,`);
          lines.push(`        });`);
          lines.push(`        throwIfNotFound(result.count, '${model.name}');`);
          lines.push(`        const record = await tx.${lowerName}.findFirst({ where: decomposedWhere, ...projection });`);
          lines.push(`        const processed = await postProcessRead(Promise.resolve(record), '${model.name}', { where: decomposedWhere, ...projection }, injectedPaths);`);
          lines.push(`        if (isAuditable('${model.name}', 'delete') && preMutationSnapshot) {`);
          lines.push(`          const ctx = await _mergeAuditContext(wrapOptions, callCtx);`);
          lines.push(`          await writeAuditEvent(tx, '${model.name}', getEntityId('${model.name}', preMutationSnapshot), 'soft_delete', actorId ?? null, preMutationSnapshot, undefined, ctx);`);
          lines.push(`        }`);
          lines.push(`        return { record: processed, cascaded: {} };`);
          lines.push(`      }) as Safe${model.name}Delegate['softDelete'],`);
          lines.push(`      softDeleteMany: (async (args: any) => {`);
          lines.push(`        const { actorId, auditContext: callCtx, ...rest } = args;`);
          lines.push(`        const updateData: Record<string, unknown> = { ['${deletedAtField}']: new Date() };`);
          if (model.deletedByField !== null) {
            lines.push(`        const deletedByField = ${JSON.stringify(model.deletedByField)};`);
            lines.push(`        if (deletedByField && actorId) {`);
            lines.push(`          updateData[deletedByField] = actorId;`);
            lines.push(`        }`);
          }
          lines.push(`        const decomposedWhere = decomposeCompoundKeyWhere('${model.name}', rest.where);`);
          lines.push(`        const records = isAuditable('${model.name}', 'delete')`);
          lines.push(`          ? await tx.${lowerName}.findMany({ where: { ...decomposedWhere, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE } })`);
          lines.push(`          : [];`);
          lines.push(`        const result = await tx.${lowerName}.updateMany({`);
          lines.push(`          where: { ...decomposedWhere, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },`);
          lines.push(`          data: updateData,`);
          lines.push(`        });`);
          lines.push(`        if (isAuditable('${model.name}', 'delete') && records.length > 0) {`);
          lines.push(`          const ctx = await _mergeAuditContext(wrapOptions, callCtx);`);
          lines.push(`          await Promise.all(records.map((record: any) =>`);
          lines.push(`            writeAuditEvent(tx, '${model.name}', getEntityId('${model.name}', record), 'soft_delete', actorId ?? null, record, undefined, ctx),`);
          lines.push(`          ));`);
          lines.push(`        }`);
          lines.push(`        return { count: result.count, cascaded: {} };`);
          lines.push(`      }) as Safe${model.name}Delegate['softDeleteMany'],`);
        } else {
          // Non-audited fast path: use updateMany directly
          lines.push(`      softDelete: (async (args: any) => {`);
          lines.push(`        const { ${identityField}, ...rest } = args;`);
          lines.push(`        const { where, ...restProjection } = rest;`);
          lines.push(`        const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${model.name}');`);
          lines.push(`        const decomposedWhere = decomposeCompoundKeyWhere('${model.name}', where);`);
          lines.push(`        const now = new Date();`);
          lines.push(`        const updateData: Record<string, unknown> = { ['${deletedAtField}']: now };`);
          if (model.deletedByField !== null) {
            lines.push(`        const deletedByField = ${JSON.stringify(model.deletedByField)};`);
            lines.push(`        if (deletedByField && ${identityField}) {`);
            lines.push(`          updateData[deletedByField] = ${identityField};`);
            lines.push(`        }`);
          }
          lines.push(`        const result = await tx.${lowerName}.updateMany({`);
          lines.push(`          where: { ...decomposedWhere, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },`);
          lines.push(`          data: updateData,`);
          lines.push(`        });`);
          lines.push(`        throwIfNotFound(result.count, '${model.name}');`);
          lines.push(`        const record = await tx.${lowerName}.findFirst({ where: decomposedWhere, ...projection });`);
          lines.push(`        const processed = await postProcessRead(Promise.resolve(record), '${model.name}', { where: decomposedWhere, ...projection }, injectedPaths);`);
          lines.push(`        return { record: processed, cascaded: {} };`);
          lines.push(`      }) as Safe${model.name}Delegate['softDelete'],`);
          lines.push(`      softDeleteMany: (async (args: any) => {`);
          lines.push(`        const { ${identityField}, ...rest } = args;`);
          lines.push(`        const updateData: Record<string, unknown> = { ['${deletedAtField}']: new Date() };`);
          if (model.deletedByField !== null) {
            lines.push(`        const deletedByField = ${JSON.stringify(model.deletedByField)};`);
            lines.push(`        if (deletedByField && ${identityField}) {`);
            lines.push(`          updateData[deletedByField] = ${identityField};`);
            lines.push(`        }`);
          }
          lines.push(`        const result = await tx.${lowerName}.updateMany({`);
          lines.push(`          where: { ...rest.where, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },`);
          lines.push(`          data: updateData,`);
          lines.push(`        });`);
          lines.push(`        return { count: result.count, cascaded: {} };`);
          lines.push(`      }) as Safe${model.name}Delegate['softDeleteMany'],`);
        }
        // Preview (fast path - simple count)
        lines.push(`      softDeletePreview: (async (args: any) => {`);
        lines.push(`        const count = await tx.${lowerName}.count({`);
        lines.push(`          where: { ...args.where, ['${deletedAtField}']: ACTIVE_DELETED_AT_VALUE },`);
        lines.push(`        });`);
        lines.push(`        return { wouldDelete: count > 0 ? { ['${model.name}']: count } : {} };`);
        lines.push(`      }) as Safe${model.name}Delegate['softDeletePreview'],`);
      } else {
        if (model.isAuditable && hasAudit) {
          // Audited complex path in transaction: already inside tx, add audit event writing
          lines.push(`      softDelete: (async (args: any) => {`);
          lines.push(`        const { actorId, auditContext: callCtx, ...rest } = args;`);
          lines.push(`        const { where, ...restProjection } = rest;`);
          lines.push(`        const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${model.name}');`);
          // actorId is passed as deletedBy (4th arg) to set the model's deleted_by field,
          // and as auditActorId (5th arg, coerced to null if undefined) to populate the
          // audit event's actor_id. null auditActorId still writes the audit event (actor unknown).
          lines.push(`        const { count, cascaded } = await softDeleteWithCascadeInTx(tx, '${model.name}', where, actorId, actorId ?? null, wrapOptions, callCtx);`);
          lines.push(`        throwIfNotFound(count, '${model.name}');`);
          lines.push(`        const decomposedWhere = decomposeCompoundKeyWhere('${model.name}', where);`);
          lines.push(`        const record = await tx.${lowerName}.findFirst({ where: decomposedWhere, ...projection });`);
          lines.push(`        const processed = await postProcessRead(Promise.resolve(record), '${model.name}', { where: decomposedWhere, ...projection }, injectedPaths);`);
          lines.push(`        return { record: processed, cascaded };`);
          lines.push(`      }) as Safe${model.name}Delegate['softDelete'],`);
          lines.push(`      softDeleteMany: (async (args: any) => {`);
          lines.push(`        const { actorId, auditContext: callCtx, ...rest } = args;`);
          lines.push(`        const { count, cascaded } = await softDeleteWithCascadeInTx(tx, '${model.name}', rest.where, actorId, actorId ?? null, wrapOptions, callCtx);`);
          lines.push(`        return { count, cascaded };`);
          lines.push(`      }) as Safe${model.name}Delegate['softDeleteMany'],`);
        } else {
          // Non-audited complex path: use softDeleteWithCascadeInTx
          lines.push(`      softDelete: (async (args: any) => {`);
          lines.push(`        const { ${identityField}, ...rest } = args;`);
          lines.push(`        const { where, ...restProjection } = rest;`);
          lines.push(`        const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${model.name}');`);
          lines.push(`        const { count, cascaded } = await softDeleteWithCascadeInTx(tx, '${model.name}', where, ${identityField});`);
          lines.push(`        throwIfNotFound(count, '${model.name}');`);
          lines.push(`        const decomposedWhere = decomposeCompoundKeyWhere('${model.name}', where);`);
          lines.push(`        const record = await tx.${lowerName}.findFirst({ where: decomposedWhere, ...projection });`);
          lines.push(`        const processed = await postProcessRead(Promise.resolve(record), '${model.name}', { where: decomposedWhere, ...projection }, injectedPaths);`);
          lines.push(`        return { record: processed, cascaded };`);
          lines.push(`      }) as Safe${model.name}Delegate['softDelete'],`);
          lines.push(`      softDeleteMany: (async (args: any) => {`);
          lines.push(`        const { ${identityField}, ...rest } = args;`);
          lines.push(`        const { count, cascaded } = await softDeleteWithCascadeInTx(tx, '${model.name}', rest.where, ${identityField});`);
          lines.push(`        return { count, cascaded };`);
          lines.push(`      }) as Safe${model.name}Delegate['softDeleteMany'],`);
        }
        // Preview (complex path - cascade preview)
        lines.push(`      softDeletePreview: (async (args: any) => {`);
        lines.push(`        return previewSoftDeleteInTx(tx, '${model.name}', args.where);`);
        lines.push(`      }) as Safe${model.name}Delegate['softDeletePreview'],`);
      }

      // Restore methods
      if (model.isAuditable && hasAudit) {
        lines.push(`      restore: (async (args: any) => {`);
        lines.push(`        const { actorId, auditContext: callCtx, ...rest } = args;`);
        lines.push(`        const { where, ...restProjection } = rest;`);
        lines.push(`        const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${model.name}');`);
        lines.push(`        const record = await restoreRecordInTx(tx, '${model.name}', where, projection);`);
        lines.push(`        const processed = await postProcessRead(Promise.resolve(record), '${model.name}', { where, ...projection }, injectedPaths);`);
        lines.push(`        if (isAuditable('${model.name}', 'update') && processed) {`);
        lines.push(`          const ctx = await _mergeAuditContext(wrapOptions, callCtx);`);
        lines.push(`          await writeAuditEvent(tx, '${model.name}', getEntityId('${model.name}', processed), 'restore', actorId ?? null, processed, undefined, ctx);`);
        lines.push(`        }`);
        lines.push(`        return processed;`);
        lines.push(`      }) as Safe${model.name}Delegate['restore'],`);
        lines.push(`      restoreMany: (async (args: any) => {`);
        lines.push(`        const { actorId, auditContext: callCtx, ...rest } = args;`);
        lines.push(`        const deletedAtField = getDeletedAtField('${model.name}');`);
        lines.push(`        const recordsBefore = isAuditable('${model.name}', 'update')`);
        lines.push(`          ? await tx.${lowerName}.findMany({ where: { ...decomposeCompoundKeyWhere('${model.name}', rest.where), [deletedAtField!]: { not: ACTIVE_DELETED_AT_VALUE } } })`);
        lines.push(`          : [];`);
        lines.push(`        const result = await restoreManyInTx(tx, '${model.name}', rest.where);`);
        lines.push(`        if (isAuditable('${model.name}', 'update') && recordsBefore.length > 0) {`);
        lines.push(`          const ctx = await _mergeAuditContext(wrapOptions, callCtx);`);
        lines.push(`          await Promise.all(recordsBefore.map((record: any) =>`);
        lines.push(`            writeAuditEvent(tx, '${model.name}', getEntityId('${model.name}', record), 'restore', actorId ?? null, record, undefined, ctx),`);
        lines.push(`          ));`);
        lines.push(`        }`);
        lines.push(`        return result;`);
        lines.push(`      }) as Safe${model.name}Delegate['restoreMany'],`);
        lines.push(`      restoreCascade: (async (args: any) => {`);
        lines.push(`        const { actorId, auditContext: callCtx, ...rest } = args;`);
        lines.push(`        const { where, ...restProjection } = rest;`);
        lines.push(`        const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${model.name}');`);
        lines.push(`        const { record, cascaded } = await restoreWithCascadeInTx(tx, '${model.name}', where, projection, actorId ?? null, wrapOptions, callCtx);`);
        lines.push(`        const processed = await postProcessRead(Promise.resolve(record), '${model.name}', { where, ...projection }, injectedPaths);`);
        lines.push(`        if (isAuditable('${model.name}', 'update') && processed) {`);
        lines.push(`          const ctx = await _mergeAuditContext(wrapOptions, callCtx);`);
        lines.push(`          await writeAuditEvent(tx, '${model.name}', getEntityId('${model.name}', processed), 'restore', actorId ?? null, processed, undefined, ctx);`);
        lines.push(`        }`);
        lines.push(`        return { record: processed, cascaded };`);
        lines.push(`      }) as Safe${model.name}Delegate['restoreCascade'],`);
      } else {
        lines.push(`      restore: (async (args: any) => {`);
        lines.push(`        const { where, ...restProjection } = args;`);
        lines.push(`        const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${model.name}');`);
        lines.push(`        const record = await restoreRecordInTx(tx, '${model.name}', where, projection);`);
        lines.push(`        return postProcessRead(Promise.resolve(record), '${model.name}', { where, ...projection }, injectedPaths);`);
        lines.push(`      }) as Safe${model.name}Delegate['restore'],`);
        lines.push(`      restoreMany: (async (args: any) => {`);
        lines.push(`        return restoreManyInTx(tx, '${model.name}', args.where);`);
        lines.push(`      }) as Safe${model.name}Delegate['restoreMany'],`);
        lines.push(`      restoreCascade: (async (args: any) => {`);
        lines.push(`        const { where, ...restProjection } = args;`);
        lines.push(`        const { args: projection, injectedPaths } = injectDeletedAtIntoToOneSelects(restProjection, '${model.name}');`);
        lines.push(`        const { record, cascaded } = await restoreWithCascadeInTx(tx, '${model.name}', where, projection);`);
        lines.push(`        const processed = await postProcessRead(Promise.resolve(record), '${model.name}', { where, ...projection }, injectedPaths);`);
        lines.push(`        return { record: processed, cascaded };`);
        lines.push(`      }) as Safe${model.name}Delegate['restoreCascade'],`);
      }
      // Hard delete methods (intentionally scary names)
      if (model.isAuditable && hasAudit) {
        lines.push(`      __dangerousHardDelete: (async (args: any) => {`);
        lines.push(`        const { actorId, auditContext: callCtx, ...rest } = args;`);
        lines.push(`        return _auditedHardDelete(tx, tx.${lowerName}, rest, '${model.name}', actorId ?? null, wrapOptions, callCtx);`);
        lines.push(`      }) as Safe${model.name}Delegate['__dangerousHardDelete'],`);
        lines.push(`      __dangerousHardDeleteMany: (async (args: any) => {`);
        lines.push(`        const { actorId, auditContext: callCtx, ...rest } = args;`);
        lines.push(`        return _auditedHardDeleteMany(tx, tx.${lowerName}, rest, '${model.name}', actorId ?? null, wrapOptions, callCtx);`);
        lines.push(`      }) as Safe${model.name}Delegate['__dangerousHardDeleteMany'],`);
      } else {
        lines.push(`      __dangerousHardDelete: ((args: any) => tx.${lowerName}.delete(args)) as PrismaClient['${lowerName}']['delete'],`);
        lines.push(`      __dangerousHardDeleteMany: ((args: any) => tx.${lowerName}.deleteMany(args)) as PrismaClient['${lowerName}']['deleteMany'],`);
      }
      // includingDeleted sub-object for raw access
      lines.push(`      includingDeleted: {`);
      lines.push(`        findMany: ((args?: any) => tx.${lowerName}.findMany(args)) as PrismaClient['${lowerName}']['findMany'],`);
      lines.push(`        findFirst: ((args?: any) => tx.${lowerName}.findFirst(args)) as PrismaClient['${lowerName}']['findFirst'],`);
      lines.push(`        findFirstOrThrow: ((args?: any) => tx.${lowerName}.findFirstOrThrow(args)) as PrismaClient['${lowerName}']['findFirstOrThrow'],`);
      lines.push(`        findUnique: ((args?: any) => tx.${lowerName}.findUnique(args)) as PrismaClient['${lowerName}']['findUnique'],`);
      lines.push(`        findUniqueOrThrow: ((args?: any) => tx.${lowerName}.findUniqueOrThrow(args)) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      lines.push(`        count: ((args?: any) => tx.${lowerName}.count(args)) as PrismaClient['${lowerName}']['count'],`);
      lines.push(`        aggregate: ((args?: any) => tx.${lowerName}.aggregate(args)) as PrismaClient['${lowerName}']['aggregate'],`);
      lines.push(`        groupBy: ((args?: any) => tx.${lowerName}.groupBy(args)) as PrismaClient['${lowerName}']['groupBy'],`);
      lines.push(`      },`);
      lines.push(`    },`);
    } else if (model.isAuditable && hasAudit) {
      // Audit-only model in transaction: use shared _audited* helpers with tx directly
      lines.push(`    ${lowerName}: {`);
      lines.push(`      ...tx.${lowerName},`);
      const txAuditOnlyContext = {
        wrapInTransaction: false,
        indent: '      ',
        delegateExpr: 'tx',
      };
      const allTxDescs = [...AUDIT_WRITE_METHODS, ...AUDIT_DELETE_METHODS];
      for (const desc of allTxDescs) {
        emitAuditedMethodCallSite(lines, desc, model, options, txAuditOnlyContext);
      }
      lines.push(`    } as Safe${model.name}Delegate,`);
    } else if (model.isAuditTable) {
      // Audit table in transaction: read-only access
      lines.push(`    ${lowerName}: {`);
      lines.push(`      findMany: tx.${lowerName}.findMany.bind(tx.${lowerName}),`);
      lines.push(`      findFirst: tx.${lowerName}.findFirst.bind(tx.${lowerName}),`);
      lines.push(`      findFirstOrThrow: tx.${lowerName}.findFirstOrThrow.bind(tx.${lowerName}),`);
      lines.push(`      findUnique: tx.${lowerName}.findUnique.bind(tx.${lowerName}),`);
      lines.push(`      findUniqueOrThrow: tx.${lowerName}.findUniqueOrThrow.bind(tx.${lowerName}),`);
      lines.push(`      count: tx.${lowerName}.count.bind(tx.${lowerName}),`);
      lines.push(`      aggregate: tx.${lowerName}.aggregate.bind(tx.${lowerName}),`);
      lines.push(`      groupBy: tx.${lowerName}.groupBy.bind(tx.${lowerName}),`);
      lines.push(`    } as Safe${model.name}Delegate,`);
    } else {
      lines.push(`    ${lowerName}: tx.${lowerName},`);
    }
  }

  // Add $onlyDeleted escape hatch
  lines.push('');
  lines.push('    /** Query only soft-deleted records with filter propagation */');
  lines.push('    $onlyDeleted: {');
  for (const model of schema.models) {
    if (model.isSoftDeletable) {
      const lowerName = toLowerFirst(model.name);
      lines.push(`      ${lowerName}: {`);
      lines.push(`        findMany: ((...args: any[]) => {`);
      lines.push(`          const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
      lines.push(`          const filtered = injectFilters(pp, '${model.name}', 'only-deleted');`);
      lines.push(`          return postProcessReadOnlyDeleted(tx.${lowerName}.findMany(filtered), injectedPaths) as any;`);
      lines.push(`        }) as PrismaClient['${lowerName}']['findMany'],`);
      lines.push(`        findFirst: ((...args: any[]) => {`);
      lines.push(`          const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
      lines.push(`          const filtered = injectFilters(pp, '${model.name}', 'only-deleted');`);
      lines.push(`          return postProcessReadOnlyDeleted(tx.${lowerName}.findFirst(filtered), injectedPaths) as any;`);
      lines.push(`        }) as PrismaClient['${lowerName}']['findFirst'],`);
      lines.push(`        findFirstOrThrow: ((...args: any[]) => {`);
      lines.push(`          const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
      lines.push(`          const filtered = injectFilters(pp, '${model.name}', 'only-deleted');`);
      lines.push(`          return postProcessReadOnlyDeleted(tx.${lowerName}.findFirstOrThrow(filtered), injectedPaths) as any;`);
      lines.push(`        }) as PrismaClient['${lowerName}']['findFirstOrThrow'],`);
      lines.push(`        findUnique: ((...args: any[]) => {`);
      lines.push(`          const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
      lines.push(`          const filtered = injectFilters(pp, '${model.name}', 'only-deleted');`);
      lines.push(`          return postProcessReadOnlyDeleted(tx.${lowerName}.findUnique(filtered), injectedPaths) as any;`);
      lines.push(`        }) as PrismaClient['${lowerName}']['findUnique'],`);
      lines.push(`        findUniqueOrThrow: ((...args: any[]) => {`);
      lines.push(`          const { args: pp, injectedPaths } = injectDeletedAtIntoToOneSelects(args[0], '${model.name}');`);
      lines.push(`          const filtered = injectFilters(pp, '${model.name}', 'only-deleted');`);
      lines.push(`          return postProcessReadOnlyDeleted(tx.${lowerName}.findUniqueOrThrow(filtered), injectedPaths) as any;`);
      lines.push(`        }) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      lines.push(`        count: ((...args: any[]) => tx.${lowerName}.count(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['count'],`);
      lines.push(`        aggregate: ((...args: any[]) => tx.${lowerName}.aggregate(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['aggregate'],`);
      lines.push(`        groupBy: ((...args: any[]) => tx.${lowerName}.groupBy(injectFilters(args[0], '${model.name}', 'only-deleted'))) as PrismaClient['${lowerName}']['groupBy'],`);
      lines.push(`      },`);
    }
  }
  lines.push('    },');

  // Add $includingDeleted escape hatch
  lines.push('');
  lines.push('    /** Query including soft-deleted records with filter propagation */');
  lines.push('    $includingDeleted: {');
  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    if (model.isSoftDeletable) {
      lines.push(`      ${lowerName}: {`);
      lines.push(`        findMany: ((...args: any[]) => tx.${lowerName}.findMany(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findMany'],`);
      lines.push(`        findFirst: ((...args: any[]) => tx.${lowerName}.findFirst(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findFirst'],`);
      lines.push(`        findFirstOrThrow: ((...args: any[]) => tx.${lowerName}.findFirstOrThrow(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findFirstOrThrow'],`);
      lines.push(`        findUnique: ((...args: any[]) => tx.${lowerName}.findUnique(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findUnique'],`);
      lines.push(`        findUniqueOrThrow: ((...args: any[]) => tx.${lowerName}.findUniqueOrThrow(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['findUniqueOrThrow'],`);
      lines.push(`        count: ((...args: any[]) => tx.${lowerName}.count(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['count'],`);
      lines.push(`        aggregate: ((...args: any[]) => tx.${lowerName}.aggregate(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['aggregate'],`);
      lines.push(`        groupBy: ((...args: any[]) => tx.${lowerName}.groupBy(injectFilters(args[0], '${model.name}', 'include-deleted'))) as PrismaClient['${lowerName}']['groupBy'],`);
      lines.push(`      },`);
    } else if (model.isAuditTable) {
      // Audit table: read-only in $includingDeleted too
      lines.push(`      ${lowerName}: {`);
      lines.push(`        findMany: tx.${lowerName}.findMany.bind(tx.${lowerName}),`);
      lines.push(`        findFirst: tx.${lowerName}.findFirst.bind(tx.${lowerName}),`);
      lines.push(`        findFirstOrThrow: tx.${lowerName}.findFirstOrThrow.bind(tx.${lowerName}),`);
      lines.push(`        findUnique: tx.${lowerName}.findUnique.bind(tx.${lowerName}),`);
      lines.push(`        findUniqueOrThrow: tx.${lowerName}.findUniqueOrThrow.bind(tx.${lowerName}),`);
      lines.push(`        count: tx.${lowerName}.count.bind(tx.${lowerName}),`);
      lines.push(`        aggregate: tx.${lowerName}.aggregate.bind(tx.${lowerName}),`);
      lines.push(`        groupBy: tx.${lowerName}.groupBy.bind(tx.${lowerName}),`);
      lines.push(`      } as Safe${model.name}Delegate,`);
    } else {
      lines.push(`      ${lowerName}: tx.${lowerName},`);
    }
  }
  lines.push('    },');
  lines.push('');
  lines.push('    // Raw query methods');
  lines.push("    $queryRaw: (tx.$queryRaw as any).bind(tx) as PrismaClient['$queryRaw'],");
  lines.push("    $executeRaw: (tx.$executeRaw as any).bind(tx) as PrismaClient['$executeRaw'],");
  lines.push("    $queryRawUnsafe: (tx.$queryRawUnsafe as any).bind(tx) as PrismaClient['$queryRawUnsafe'],");
  lines.push("    $executeRawUnsafe: (tx.$executeRawUnsafe as any).bind(tx) as PrismaClient['$executeRawUnsafe'],");

  if (hasAudit) {
    lines.push('');
    lines.push('    $writeAuditEvent: async (params: { entityType: string; entityId: string; action: string; actorId?: string | null; eventData: Prisma.InputJsonValue; parentEventId?: string; auditContext?: AuditContext }) => {');
    lines.push('      const ctx = await _mergeAuditContext(wrapOptions, params.auditContext);');
    lines.push('      return writeAuditEvent(tx, params.entityType, params.entityId, params.action, params.actorId ?? null, params.eventData, params.parentEventId, ctx);');
    lines.push('    },');
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitWrapperFunction(schema: ParsedSchema, hasAudit: boolean): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Wraps a PrismaClient with soft-delete functionality');
  lines.push(' */');

  if (hasAudit) {
    lines.push('export function wrapPrismaClient(prisma: PrismaClient, wrapOptions?: WrapOptions): SafePrismaClient {');
  } else {
    lines.push('export function wrapPrismaClient(prisma: PrismaClient): SafePrismaClient {');
  }
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    if (hasAudit && (model.isSoftDeletable || model.isAuditable)) {
      lines.push(`    ${lowerName}: create${model.name}Delegate(prisma, wrapOptions),`);
    } else {
      lines.push(`    ${lowerName}: create${model.name}Delegate(prisma),`);
    }
  }

  lines.push('');
  lines.push('    $connect: () => prisma.$connect(),');
  lines.push('    $disconnect: () => prisma.$disconnect(),');
  lines.push('    $on: (prisma.$on as any).bind(prisma) as PrismaClient[\'$on\'],');
  lines.push('    $transaction: ((arg: any, options?: any) => {');
  lines.push('      // Handle both sequential and interactive transactions');
  lines.push('      if (typeof arg === "function") {');
  lines.push('        // Interactive transaction - wrap the callback to provide safe delegates');
  lines.push('        return prisma.$transaction((tx: Prisma.TransactionClient) => {');
  if (hasAudit) {
    lines.push('          const wrappedTx = wrapTransactionClient(tx, wrapOptions);');
  } else {
    lines.push('          const wrappedTx = wrapTransactionClient(tx);');
  }
  lines.push('          return arg(wrappedTx);');
  lines.push('        }, options);');
  lines.push('      }');
  lines.push('      // Sequential transaction (array of promises)');
  lines.push('      return (prisma.$transaction as any)(arg, options);');
  lines.push("    }) as SafePrismaClient['$transaction'],");
  lines.push('    $queryRaw: (prisma.$queryRaw as any).bind(prisma) as PrismaClient[\'$queryRaw\'],');
  lines.push('    $executeRaw: (prisma.$executeRaw as any).bind(prisma) as PrismaClient[\'$executeRaw\'],');
  lines.push('    $queryRawUnsafe: (prisma.$queryRawUnsafe as any).bind(prisma) as PrismaClient[\'$queryRawUnsafe\'],');
  lines.push('    $executeRawUnsafe: (prisma.$executeRawUnsafe as any).bind(prisma) as PrismaClient[\'$executeRawUnsafe\'],');
  lines.push('    $prisma: prisma,');
  lines.push('    $includingDeleted: createIncludingDeletedClient(prisma),');
  lines.push('    $onlyDeleted: createOnlyDeletedClient(prisma),');

  if (hasAudit) {
    lines.push('    $writeAuditEvent: async (params: { entityType: string; entityId: string; action: string; actorId?: string | null; eventData: Prisma.InputJsonValue; parentEventId?: string; auditContext?: AuditContext }) => {');
    lines.push('      return prisma.$transaction(async (tx: Prisma.TransactionClient) => {');
    lines.push('        const ctx = await _mergeAuditContext(wrapOptions, params.auditContext);');
    lines.push('        return writeAuditEvent(tx, params.entityType, params.entityId, params.action, params.actorId ?? null, params.eventData, params.parentEventId, ctx);');
    lines.push('      });');
    lines.push('    },');
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function toLowerFirst(str: string): string {
  const first = str.charAt(0);
  return first.toLowerCase() + str.slice(1);
}
