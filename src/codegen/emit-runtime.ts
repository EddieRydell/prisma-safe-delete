import type { ParsedModel, ParsedSchema } from '../dmmf-parser.js';

/**
 * Generates the runtime wrapper functions
 */
export function emitRuntime(schema: ParsedSchema): string {
  const lines: string[] = [];

  lines.push('/* eslint-disable */');
  lines.push('// @ts-nocheck');
  lines.push('// Auto-generated by prisma-safe-delete');
  lines.push('// Do not edit this file manually');
  lines.push('');
  lines.push("import type { PrismaClient, Prisma } from '@prisma/client';");
  lines.push("import { CASCADE_GRAPH, type CascadeChild } from './cascade-graph.js';");
  lines.push("import type { SafePrismaClient, IncludingDeletedClient, OnlyDeletedClient } from './types.js';");
  lines.push('');

  // Emit model metadata
  lines.push('/** Metadata about soft-deletable models */');
  lines.push('const SOFT_DELETABLE_MODELS: Record<string, { deletedAtField: string }> = {');
  for (const model of schema.models) {
    if (model.isSoftDeletable && model.deletedAtField !== null) {
      lines.push(`  ${model.name}: { deletedAtField: ${JSON.stringify(model.deletedAtField)} },`);
    }
  }
  lines.push('};');
  lines.push('');

  // Emit primary key metadata
  lines.push('/** Primary key configuration per model */');
  lines.push('const PRIMARY_KEYS: Record<string, string | string[]> = {');
  for (const model of schema.models) {
    const pkValue = Array.isArray(model.primaryKey)
      ? JSON.stringify(model.primaryKey)
      : JSON.stringify(model.primaryKey);
    lines.push(`  ${model.name}: ${pkValue},`);
  }
  lines.push('};');
  lines.push('');

  // Emit helper functions
  lines.push(emitHelperFunctions());
  lines.push('');

  // Emit injectFilters function
  lines.push(emitInjectFiltersFunction());
  lines.push('');

  // Emit soft delete cascade function
  lines.push(emitSoftDeleteCascadeFunction());
  lines.push('');

  // Emit model delegate wrappers
  for (const model of schema.models) {
    lines.push(emitModelDelegate(model));
    lines.push('');
  }

  // Emit includingDeleted and onlyDeleted clients
  lines.push(emitIncludingDeletedClient(schema));
  lines.push('');
  lines.push(emitOnlyDeletedClient(schema));
  lines.push('');

  // Emit main wrapper function
  lines.push(emitWrapperFunction(schema));

  return lines.join('\n');
}

function emitHelperFunctions(): string {
  return `
/**
 * Checks if a model is soft-deletable
 */
function isSoftDeletable(modelName: string): boolean {
  return modelName in SOFT_DELETABLE_MODELS;
}

/**
 * Gets the deleted_at field name for a model
 */
function getDeletedAtField(modelName: string): string | null {
  return SOFT_DELETABLE_MODELS[modelName]?.deletedAtField ?? null;
}

/**
 * Extracts primary key values from a record
 */
function extractPrimaryKey(modelName: string, record: Record<string, unknown>): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return {};

  const keys = Array.isArray(pk) ? pk : [pk];
  const result: Record<string, unknown> = {};

  for (const key of keys) {
    result[key] = record[key];
  }

  return result;
}

/**
 * Creates a where clause for primary key lookup
 */
function createPkWhere(modelName: string, pkValues: Record<string, unknown>): Record<string, unknown> {
  const pk = PRIMARY_KEYS[modelName];
  if (!pk) return pkValues;

  if (Array.isArray(pk)) {
    // Compound key - use underscore-joined name
    const compoundName = pk.join('_');
    return { [compoundName]: pkValues };
  }

  return pkValues;
}`.trim();
}

function emitInjectFiltersFunction(): string {
  return `
/**
 * Recursively injects deleted_at: null filters into query args
 */
function injectFilters<T extends Record<string, unknown>>(
  args: T | undefined,
  modelName: string
): T {
  if (!args) {
    const deletedAtField = getDeletedAtField(modelName);
    if (deletedAtField) {
      return { where: { [deletedAtField]: null } } as T;
    }
    return {} as T;
  }

  const result = { ...args };
  const deletedAtField = getDeletedAtField(modelName);

  // Inject into top-level where
  if (deletedAtField) {
    result.where = {
      ...((result.where as Record<string, unknown>) ?? {}),
      [deletedAtField]: null,
    };
  }

  // Process include
  if (result.include && typeof result.include === 'object') {
    result.include = injectIntoRelations(
      result.include as Record<string, unknown>,
      modelName
    );
  }

  // Process select
  if (result.select && typeof result.select === 'object') {
    result.select = injectIntoRelations(
      result.select as Record<string, unknown>,
      modelName
    );
  }

  return result;
}

/**
 * Injects filters into relation includes/selects
 */
function injectIntoRelations(
  relations: Record<string, unknown>,
  _parentModel: string
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(relations)) {
    if (value === true) {
      // Simple include - check if relation target is soft-deletable
      // For now, we include as-is; full implementation would look up relation target
      result[key] = value;
    } else if (value && typeof value === 'object') {
      // Nested include with options
      const nested = value as Record<string, unknown>;
      const relationModel = key.charAt(0).toUpperCase() + key.slice(1);
      const deletedAtField = getDeletedAtField(relationModel);

      if (deletedAtField) {
        result[key] = {
          ...nested,
          where: {
            ...((nested.where as Record<string, unknown>) ?? {}),
            [deletedAtField]: null,
          },
        };
      } else {
        result[key] = nested;
      }
    } else {
      result[key] = value;
    }
  }

  return result;
}`.trim();
}

function emitSoftDeleteCascadeFunction(): string {
  return `
/**
 * Performs a soft delete with cascade
 */
async function softDeleteWithCascade(
  prisma: PrismaClient,
  modelName: string,
  where: Record<string, unknown>,
  deletedBy?: string
): Promise<void> {
  const deletedAtField = getDeletedAtField(modelName);
  if (!deletedAtField) {
    throw new Error(\`Model \${modelName} is not soft-deletable\`);
  }

  const now = new Date();
  const lowerModelName = modelName.charAt(0).toLowerCase() + modelName.slice(1);

  await prisma.$transaction(async (tx) => {
    // Find all records to delete
    const delegate = tx[lowerModelName as keyof typeof tx] as any;
    const records = await delegate.findMany({
      where: {
        ...where,
        [deletedAtField]: null, // Only non-deleted records
      },
    });

    if (records.length === 0) return;

    // Get primary keys of records to delete
    const pkValues = records.map((r: Record<string, unknown>) =>
      extractPrimaryKey(modelName, r)
    );

    // Cascade to children (depth-first)
    await cascadeToChildren(tx, modelName, pkValues, now, deletedBy);

    // Update parent records
    const pk = PRIMARY_KEYS[modelName];
    const pkField = Array.isArray(pk) ? pk.join('_') : pk;

    const updateData: Record<string, unknown> = { [deletedAtField]: now };
    const deletedByField = getDeletedByField(modelName);
    if (deletedByField && deletedBy) {
      updateData[deletedByField] = deletedBy;
    }

    await delegate.updateMany({
      where: {
        OR: pkValues.map((pkVal: Record<string, unknown>) => pkVal),
        [deletedAtField]: null,
      },
      data: updateData,
    });
  });
}

/**
 * Gets the deleted_by field name for a model
 */
function getDeletedByField(modelName: string): string | null {
  // This would be populated from schema metadata in a full implementation
  return null;
}

/**
 * Recursively cascades soft delete to children
 */
async function cascadeToChildren(
  tx: any,
  parentModel: string,
  parentPkValues: Record<string, unknown>[],
  deletedAt: Date,
  deletedBy?: string
): Promise<void> {
  const children = CASCADE_GRAPH[parentModel] ?? [];

  for (const child of children) {
    const lowerChildModel = child.model.charAt(0).toLowerCase() + child.model.slice(1);
    const childDelegate = tx[lowerChildModel as keyof typeof tx] as any;

    // Build where clause to find children
    const fkField = child.foreignKey[0];
    const pkField = child.parentKey[0];

    if (!fkField || !pkField) continue;

    const parentIds = parentPkValues.map((pk) => pk[pkField]);

    // Find child records
    const childRecords = await childDelegate.findMany({
      where: {
        [fkField]: { in: parentIds },
        ...(child.deletedAtField ? { [child.deletedAtField]: null } : {}),
      },
    });

    if (childRecords.length === 0) continue;

    // Get child PKs for recursive cascade
    const childPkValues = childRecords.map((r: Record<string, unknown>) =>
      extractPrimaryKey(child.model, r)
    );

    // Recurse to grandchildren first (depth-first)
    await cascadeToChildren(tx, child.model, childPkValues, deletedAt, deletedBy);

    // Soft delete children (if soft-deletable)
    if (child.isSoftDeletable && child.deletedAtField) {
      await childDelegate.updateMany({
        where: {
          [fkField]: { in: parentIds },
          [child.deletedAtField]: null,
        },
        data: {
          [child.deletedAtField]: deletedAt,
        },
      });
    }
  }
}`.trim();
}

function emitModelDelegate(model: ParsedModel): string {
  const name = model.name;
  const lowerName = toLowerFirst(name);

  if (model.isSoftDeletable) {
    return `
/**
 * Creates a safe delegate for ${name} with soft-delete support
 */
function create${name}Delegate(prisma: PrismaClient): any {
  const original = prisma.${lowerName};

  return {
    // Wrapped methods with filter injection
    findMany: (args?: any) => original.findMany(injectFilters(args, '${name}')),
    findFirst: (args?: any) => original.findFirst(injectFilters(args, '${name}')),
    findFirstOrThrow: (args?: any) => original.findFirstOrThrow(injectFilters(args, '${name}')),
    findUnique: (args?: any) => original.findUnique(injectFilters(args, '${name}')),
    findUniqueOrThrow: (args?: any) => original.findUniqueOrThrow(injectFilters(args, '${name}')),
    count: (args?: any) => original.count(injectFilters(args, '${name}')),
    aggregate: (args?: any) => original.aggregate(injectFilters(args, '${name}')),
    groupBy: (args?: any) => original.groupBy(injectFilters(args, '${name}')),

    // Pass-through methods (no filter needed for writes)
    create: (args: any) => original.create(args),
    createMany: (args: any) => original.createMany(args),
    createManyAndReturn: (args: any) => original.createManyAndReturn(args),
    update: (args: any) => original.update(args),
    updateMany: (args: any) => original.updateMany(args),
    upsert: (args: any) => original.upsert(args),

    // Soft delete methods
    softDelete: async (args: any) => {
      await softDeleteWithCascade(prisma, '${name}', args.where);
      return original.findFirst({ where: args.where });
    },
    softDeleteMany: async (args: any) => {
      const records = await original.findMany({
        where: { ...args.where, ${model.deletedAtField ?? 'deleted_at'}: null },
        select: { ${getPrimaryKeySelect(model)} },
      });
      await softDeleteWithCascade(prisma, '${name}', args.where);
      return { count: records.length };
    },

    // Hard delete (escape hatch)
    hardDelete: (args: any) => original.delete(args),
    hardDeleteMany: (args: any) => original.deleteMany(args),
  };
}`.trim();
  }

  return `
/**
 * Creates a delegate for ${name} (no soft-delete)
 */
function create${name}Delegate(prisma: PrismaClient): any {
  return prisma.${lowerName};
}`.trim();
}

function getPrimaryKeySelect(model: ParsedModel): string {
  if (Array.isArray(model.primaryKey)) {
    return model.primaryKey.map((k) => `${k}: true`).join(', ');
  }
  return `${model.primaryKey}: true`;
}

function emitIncludingDeletedClient(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Creates a client that includes soft-deleted records');
  lines.push(' */');
  lines.push('function createIncludingDeletedClient(prisma: PrismaClient): IncludingDeletedClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    lines.push(`    ${lowerName}: prisma.${lowerName},`);
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitOnlyDeletedClient(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Creates a client that queries only soft-deleted records');
  lines.push(' */');
  lines.push('function createOnlyDeletedClient(prisma: PrismaClient): OnlyDeletedClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    if (model.isSoftDeletable && model.deletedAtField !== null) {
      const lowerName = toLowerFirst(model.name);
      lines.push(`    ${lowerName}: {`);
      lines.push(`      findMany: (args?: any) => prisma.${lowerName}.findMany({`);
      lines.push(`        ...args,`);
      lines.push(`        where: { ...args?.where, ${model.deletedAtField}: { not: null } },`);
      lines.push(`      }),`);
      lines.push(`      findFirst: (args?: any) => prisma.${lowerName}.findFirst({`);
      lines.push(`        ...args,`);
      lines.push(`        where: { ...args?.where, ${model.deletedAtField}: { not: null } },`);
      lines.push(`      }),`);
      lines.push(`      findUnique: (args?: any) => prisma.${lowerName}.findUnique({`);
      lines.push(`        ...args,`);
      lines.push(`        where: { ...args?.where, ${model.deletedAtField}: { not: null } },`);
      lines.push(`      }),`);
      lines.push(`      count: (args?: any) => prisma.${lowerName}.count({`);
      lines.push(`        ...args,`);
      lines.push(`        where: { ...args?.where, ${model.deletedAtField}: { not: null } },`);
      lines.push(`      }),`);
      lines.push(`    },`);
    }
  }

  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function emitWrapperFunction(schema: ParsedSchema): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Wraps a PrismaClient with soft-delete functionality');
  lines.push(' */');
  lines.push('export function wrapPrismaClient(prisma: PrismaClient): SafePrismaClient {');
  lines.push('  return {');

  for (const model of schema.models) {
    const lowerName = toLowerFirst(model.name);
    lines.push(`    ${lowerName}: create${model.name}Delegate(prisma),`);
  }

  lines.push('');
  lines.push('    $connect: () => prisma.$connect(),');
  lines.push('    $disconnect: () => prisma.$disconnect(),');
  lines.push('    $on: (...args: any[]) => (prisma.$on as any)(...args),');
  lines.push('    $transaction: (...args: any[]) => (prisma.$transaction as any)(...args),');
  lines.push('    $use: (...args: any[]) => (prisma.$use as any)(...args),');
  lines.push('    $extends: (...args: any[]) => (prisma.$extends as any)(...args),');
  lines.push('    $queryRaw: (...args: any[]) => (prisma.$queryRaw as any)(...args),');
  lines.push('    $executeRaw: (...args: any[]) => (prisma.$executeRaw as any)(...args),');
  lines.push('    $queryRawUnsafe: (...args: any[]) => (prisma.$queryRawUnsafe as any)(...args),');
  lines.push('    $executeRawUnsafe: (...args: any[]) => (prisma.$executeRawUnsafe as any)(...args),');
  lines.push('    $prisma: prisma,');
  lines.push('    $includingDeleted: createIncludingDeletedClient(prisma),');
  lines.push('    $onlyDeleted: createOnlyDeletedClient(prisma),');
  lines.push('  };');
  lines.push('}');
  return lines.join('\n');
}

function toLowerFirst(str: string): string {
  const first = str.charAt(0);
  return first.toLowerCase() + str.slice(1);
}
